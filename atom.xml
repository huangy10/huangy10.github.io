<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>治部少辅</title>
  
  <subtitle>大一大万大吉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codewoody.com/"/>
  <updated>2019-07-11T07:31:14.251Z</updated>
  <id>http://www.codewoody.com/</id>
  
  <author>
    <name>Woody Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时空错乱的名称二则</title>
    <link href="http://www.codewoody.com/posts/53783/"/>
    <id>http://www.codewoody.com/posts/53783/</id>
    <published>2019-07-11T06:59:45.000Z</published>
    <updated>2019-07-11T07:31:14.251Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="荷兰豆">荷兰豆</h2><p>荷兰豆在中国叫荷兰豆，在荷兰叫中国豆，类似的情况还有：</p><ol type="1"><li><p>梅毒：意大利人叫那不勒斯症状、法国病、高卢病，法国人叫意大利病，俄罗斯叫波兰人病，日耳曼人叫西班牙病，阿拉伯人叫基督徒病，大溪地叫英国人病，日本叫唐疮，琉球疮，葡萄牙病，有意思的是，中国人称之为广东疮。这基本上反映了梅毒的传染过程。</p></li><li><p>过山车：在法国、意大利、葡萄牙、西班牙等一些地方，“过山车”的字面意思是“俄罗斯山峰”，这是因为过山车的原型是俄罗斯的雪橇，从雪山上滑下来。在法国，当时就叫Les Montagnes Russes（俄罗斯山峰）。重点来了，在俄罗斯，过山车叫&quot;американские горки&quot; [Amerikanskie gorki]，字面意思就是“美国山峰”。</p></li><li><p>手抓饼在大陆叫台湾手抓饼，在台湾叫天津葱抓饼。</p></li></ol><p>关于荷兰豆在荷兰被称为中国豆的<a href="https://www.guokr.com/post/342270/" target="_blank" rel="noopener">考证</a>：</p><p>(1)刚开始豌豆Pisum sativum是只吃豆的。</p><p>(2)然后在中国南部接近东南亚的地区，人们培育了一种可以吃豆荚的豌豆，我们叫荷兰豆，英语里叫Chinese snow pea, 学名为Pisum sativum var. saccharatum,豌豆苗是它的嫩芽</p><p>(3)再然后出现了另一种吃豆荚的豌豆snap pea, Pisum sativum var. macrocarpon,我们叫甜豆，豆荚更鼓。</p><p>最后美国人把2和3杂交了一下，就出现了sweet snap pea(4),适合完全生吃。所有这些生吃都无毒.</p><p>为什么要叫荷兰豆？应该是荷兰蔬菜育种比较强,所以被联系在了一起，跟荷兰人无关.</p><p>资料来源：Plant Breeding Reviews, Volume 21，Chapter 3. Origin, History, and Genetic Improvement of the Snap Pea (Pisum sativum L.)</p><p>下面是我搜索到的例子：</p><figure><img src="https://imgs.codewoody.com/uploads/big/4f2ff0133e781f7a2e4f1f8095786cbe.png" alt="Cooking Snow Peas"><figcaption><a href="https://whatscookingamerica.net/Q-A/Snowpeas.htm" target="_blank" rel="noopener">Cooking Snow Peas</a></figcaption></figure><h2 id="中情局十条诫令">中情局十条诫令</h2><blockquote><p>“十条诫令” : 这是此谣言在中国大陆地区使用的名称。其他名称包括：十条戒令，十大戒令。虽然此谣言在全世界各地都有不同版本和名称，最流行的二个国家是中国大陆和巴西。而且还会有不同的中文版本。其首次在1940年代的美国出现。现在在全世界不同国家继续流传，是有不同作者，不同版本的都会传奇。所以根本就没有原始文件的存在。美国的名称是“共产党革命章程”。巴西和西班牙则说是列宁写的十诫。中国大陆则谣传是美国中央情报局1951年的绝密文件。随着时间推移，谣言的内容也会不断增加。在中国大陆地区，现在已经出现美国中情局的十二条诫令，又加入了新的第一条，和最后第十二条。</p></blockquote><p>下面三张图，是我今天听说的北京四中的给高中生做的讲座的内容：</p><p><img src="https://imgs.codewoody.com/uploads/big/b83d2d8aba24f88fe22df2e7813339a2.jpg"></p><p><img src="https://imgs.codewoody.com/uploads/big/2053f33e3b536f8b5f8b57c4278f9b19.jpg"></p><p><img src="https://imgs.codewoody.com/uploads/big/34ad58b27d2789a8c3e9a16fd8702556.jpg"></p><p>美国版本为 Communist Rules for Revolution</p><p><img src="https://imgs.codewoody.com/uploads/big/4ecddf57c56d93d01eb41fb5215f2a2f.jpg"></p><p><a href="https://www.truthorfiction.com/communist-rules-for-revolution-found-by-allied-forces-in-dusseldorf-germany-fiction/" target="_blank" rel="noopener">谣传的内容</a>是协约国在德国Dusseldorf发现了Communist Rules for Revolution，翻译过来就是共产党革命章程的。其内容的精神，无外乎就是说应该通过腐化国家的年轻一代以策动革命。</p><p>从Google Books最早可以搜到提到“共产主义者革命章程”的书籍是出版于1964年。美国纽约时报，署名Donald Janson在1970年7月10日，就发表文章，指出这些内容是假的。根据该篇文章报导，1946年2月，最早的版本发表在‘新世界新闻’。</p><p>包括瑞士，法国，巴西，西班牙等地流传的版本，可以进一步看<a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E6%9D%A1%E8%AF%AB%E4%BB%A4#cite_note-snopes-2" target="_blank" rel="noopener">维基</a></p><p>我这边最早接触到这一「谣言」的渠道，是中国大陆军方人士制作的长达90分钟的宣传片《较量无声》中引用了“十条诫令”，并称是前美国中央情报总监艾伦·杜勒斯提出来颠覆中国共产政权的。</p><h2 id="结语">结语</h2><blockquote><p>我们的对外宣传部门挤满了没有脑子的翻译机器，但我毫无办法。-- 长者</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;荷兰豆在中国叫荷兰豆，在荷兰叫中国豆。
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="智商税" scheme="http://www.codewoody.com/tags/%E6%99%BA%E5%95%86%E7%A8%8E/"/>
    
      <category term="宗教" scheme="http://www.codewoody.com/tags/%E5%AE%97%E6%95%99/"/>
    
      <category term="政治" scheme="http://www.codewoody.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 3</title>
    <link href="http://www.codewoody.com/posts/41583/"/>
    <id>http://www.codewoody.com/posts/41583/</id>
    <published>2019-07-07T07:49:29.000Z</published>
    <updated>2019-07-12T06:07:29.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新闻">新闻</h2><h3 id="三体一在日本大卖">三体一在日本大卖</h3><figure><img src="https://imgs.codewoody.com/uploads/big/b0f83d6cc9c93cfdd25eae7d3ec7fb85.jpg" alt="日亚·三体"><figcaption>日亚·三体</figcaption></figure><p>见证三体逐渐成长为一个全球性的超级IP！</p><h3 id="北京市发布三个房屋出租合同范本"><a href="https://www.huxiu.com/article/307640.html?f=wangzhan" target="_blank" rel="noopener">北京市发布三个房屋出租合同范本</a></h3><p>7月8日，北京发布《北京市住房租赁合同》《北京市房屋出租经纪服务合同》《北京市房屋承租经纪服务合同》三个合同示范文本。示范文本均在说明中强调，不得改变房屋内部结构分割出租、出租房屋人均居住面积不得低于5平方米、每个房间居住的人数不得超过2人等有关禁止违法群租的文件规定内容。</p><p>此外，租金方面，合同明确规定，未经双方当事人协商一致，出租人不得在租赁期限内单方面提高租金。合同提前解除的，出租人应在合同解除后约定日期内退还已收但尚未发生的租金。承租人应当在合同解除后约定时间内搬离。</p><h3 id="逃犯条例修订已寿终正寝"><a href="https://cn.reuters.com/article/hk-chief-0709-tues-idCNKCS1U40B6?feedType=RSS&amp;feedName=CNTopGenNews" target="_blank" rel="noopener">《逃犯条例》修订已「寿终正寝」</a></h3><p>路透香港7月9日 - 香港特首林郑月娥周二称，社会目前的矛盾、纷争、愤怒等都由《逃犯条例》修例引起，承认有关工作是完全失败，并清晰说明《逃犯条例》修订已经“寿终正寝”，政府愿意聆听社会更广泛民意，平息纷争。</p><h3 id="ibm-以-340-亿美元收购red-hat">IBM 以 340 亿美元收购Red Hat</h3><p>根据路透社报道，IBM周二宣布以340亿美元正式收购红帽。这笔交易最初公布于去年十月，当时IBM表示将会以每股190美元的价格，用现金购买红帽的所有股份。</p><figure><img src="https://imgs.codewoody.com/uploads/big/8bd2e52ab04476ac85f1b92d09581c19.png" alt="IBM &amp; Red Hat"><figcaption>IBM &amp; Red Hat</figcaption></figure><p>此次交易也是IBM迄今为止最大规模的一次收购交易，在美国历史上也可以排在前列。撇开AOL和时代华纳的并购不谈，美国科技产业的前两大收购交易分别是2016年戴尔和EMC之间价值670亿美元的并购以及JDS Uniphase在2000年以410亿美元收购光学元件供应商SDL。</p><p>按照交易合约，这家开源企业软件制造商将并入IBM的混合云部门，而红帽的首席执行官吉姆·怀特赫斯特（Jim Whitehurst）将加入IBM的高管团队，向IBM的首席执行官罗睿兰（Ginni Rometty）汇报工作。</p><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E7%B4%85%E5%B8%BD%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">Red Hat</a></li></ul><h3 id="日本制裁韩国"><a href="https://www.guancha.cn/internation/2019_07_01_507678.shtml" target="_blank" rel="noopener">日本制裁韩国</a></h3><p>据日本《产经新闻》6月30日报道，日本政府将从7月4日开始限制对韩国出口部分半导体、OLED材料出口。韩联社称，韩国相关业界高度紧张，认为稍有不慎就会出现严重状况。日本经济产业省已经于7月1日上午，公布了相关决定。</p><p>涉及的被限制对韩出口的材料包括「氟聚酰亚胺」，「光刻胶」，以及「高纯度氟化氢」等三个品种。日本在这几个材料上的市场份额占据压倒性的优势。</p><p>日本之所以宣布制裁韩国，可能是日本不满韩国无视1965年协议，不断向日本发起「二战」劳工诉讼。不过日本方面否认了这一说法。日本内阁官房长官菅义伟2日向媒体表示，这是出于安全保障考虑而进行的适当的出口管理，并不是围绕“劳工”问题而采取的对抗措施。</p><p>3日，据韩联社报道，韩国执政的共同民主党、政府、青瓦台周三就日本限制对韩半导体材料出口的应对方案表示，政府推进对半导体材料、零部件、设备研发每年投入1万亿韩元（约合人民币58.8亿元）的方案，并正在对此进行可行性调查。日本此举也激怒了韩国民众，从3日开始，韩国网络上出现不少鼓励抵制日货的言论。《中央日报》称，被韩国网友点名的日本商品覆盖从知名家电到汽车、化妆品、服装、手表、酒类等数十个种类。不仅如此，韩国网络上还开始出现抵制赴日旅游的号召。韩联社称，韩国政府3日开始向WTO提出申诉，目前韩贸易部已开始审查相关法律文件。</p><figure><img src="https://imgs.codewoody.com/uploads/big/cecd35e56014638f312ca49592461279.jpg" alt="图片来自蒋校长"><figcaption>图片来自<a href="https://bbs.tiexue.net/post2_13465562_1.html" target="_blank" rel="noopener">蒋校长</a></figcaption></figure><blockquote><p>全世界都在打贸易战</p></blockquote><h3 id="阮一峰的科技爱好者周刊增加就业栏目">阮一峰的科技爱好者周刊增加就业栏目</h3><p>阮一峰也是非常有名的中文技术博客博主，我开始写Weekly就是受他的科技爱好者周刊的启发。<a href="http://www.ruanyifeng.com/blog/2019/07/weekly-issue-64.html" target="_blank" rel="noopener">本周阮一峰想要为他的周刊增加一个《就业栏目》</a>。</p><blockquote><p>向大家报告，我想为周刊增加一个 《就业栏目》 ，每周发布招聘信息。如果你的公司正在招人，欢迎联系我（邮箱：yifeng.ruan@gmail.com）。</p></blockquote><h2 id="软件推荐">软件推荐</h2><p><a href="https://languagetool.org/" target="_blank" rel="noopener">LanguageTool</a> 是一款支持中文、英语、德语、日语等 27 种语言的语法与拼写检查工具，拥有网页版、Chrome 和 Firefox 插件，LibreOffice、Google Docs、MS Word、甚至还有 Android、Emacs、Vim、VS Code 等平台插件，服务器端开源。</p><p><img src="https://imgs.codewoody.com/uploads/big/1f611c5a984fff3067370d3d61458ec4.png"></p><h2 id="资源">资源</h2><ul><li><p>学习Java以及JavaScript的网站： <a href="https://javabrains.io/" target="_blank" rel="noopener">Java Brains</a></p></li><li><p><a href="https://jalammar.github.io/visual-numpy/" target="_blank" rel="noopener">Numpy可视化介绍</a></p></li><li><p><a href="https://tableconvert.com/" target="_blank" rel="noopener">表格转化工具</a>，支持markdown, json, html, xml, yaml等数据格式</p></li></ul><h2 id="段子与言论">段子与言论</h2><ul><li><p>2017 年初，为了验证亚马逊公司的「无限云」，一名叫 Beaston02 的男子坚持录制了 2000 TB 色情片上传到亚马逊云。半年后，亚马逊停止了无限云服务。-- <a href="https://sspai.com/post/55622" target="_blank" rel="noopener">来源</a></p></li><li><p>马克思的学说在今天的遭遇，正如历史上被压迫阶级在解放斗争中的革命思想家和领袖的学说常有的遭遇一样。当伟大的革命家在世时，压迫阶级总是不断迫害他们，以最恶毒的敌意、最疯狂的仇恨、最放肆的造谣和诽谤对待他们的学说。在他们逝世以后，便试图把他们变为无害的神像，可以说是把他们偶像化，赋予他们的名字某种荣誉，以便“安慰”和愚弄被压迫阶级，同时却阉割革命学说的内容，磨去它的革命锋芒，把它庸俗化。现在资产阶级和工人运动中的机会主义者在对马克思主义作这种“加工”的事情上正一致起来。他们忘记、抹杀和歪曲这个学说的革命方面，革命灵魂。他们把资产阶级可以接受或者觉得资产阶级可以接受的东西放在第一位来加以颂扬。 -- 列宁</p></li><li><p>发达国家人均预期寿命：美国以冠绝全球，接近18%的医疗GDP占比，人均寿命如图。（<a href="https://ourworldindata.org/the-link-between-life-expectancy-and-health-spending-us-focus" target="_blank" rel="noopener">出处</a>）</p></li></ul><p><img src="https://imgs.codewoody.com/uploads/big/fbca06ae942781af6fe9cfccf85b0996.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/f7e6647dc85e02dcbaadb4609941a503.jpg&quot; alt=&quot;进击的巨人第四季要等到2020年了&quot;&gt;&lt;figcaption&gt;进击的巨人第四季要等到2020年了&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;终于看完了第三季，巨人可以说是近年来最优秀的动漫作品了。而且第三季的最后几集又将整个作品的世界观和精神层次提升了一大截，可以说是相当起来第四季艾主席的表现了。&lt;/p&gt;
    
    </summary>
    
      <category term="Weekly" scheme="http://www.codewoody.com/categories/Weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Weekly" scheme="http://www.codewoody.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Struct in Vector: 进一步讨论</title>
    <link href="http://www.codewoody.com/posts/62430/"/>
    <id>http://www.codewoody.com/posts/62430/</id>
    <published>2019-07-02T02:04:44.000Z</published>
    <updated>2019-07-12T06:10:07.074Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们讨论了<a href="C++中将结构体放置在std::vector容器内的操作风险">C++中将结构体放置在std::vector容器内的操作风险</a>。这里我们来进一步讨论如何处理在容器中存储的结构体数据。</p><a id="more"></a><p>前文中提到，如果我们尝试获取容器中的结构体时，我们直接拿到的是该结构体的拷贝，如果要对结构体成员修改，我们需要整体进行两次复制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct A&gt; data;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">val</span> = <span class="title">data</span>.<span class="title">at</span> (0);</span></span><br><span class="line">val.b = c;</span><br><span class="line">data[<span class="number">0</span>] = val;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">这种操作显然是不经济。一种『粗暴』的方法是使用`<span class="built_in">std</span>::<span class="built_in">vector</span>::data`函数获取底层数据的指针，然后操作这个指针。但是这种方法不太优雅，也不安全。合适的做法是使用引用</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct A&gt; data;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &amp; <span class="title">val</span> = <span class="title">data</span>[0];</span></span><br><span class="line">val.b = c;</span><br></pre></td></tr></table></figure><p>放在遍历的场景中，可以使用如下的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct A&gt; data;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : data) &#123;...&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们讨论了&lt;a href=&quot;C++中将结构体放置在std::vector容器内的操作风险&quot;&gt;C++中将结构体放置在std::vector容器内的操作风险&lt;/a&gt;。这里我们来进一步讨论如何处理在容器中存储的结构体数据。&lt;/p&gt;
    
    </summary>
    
      <category term="编程研究" scheme="http://www.codewoody.com/categories/%E7%BC%96%E7%A8%8B%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="C++" scheme="http://www.codewoody.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CPP: STL map的用法</title>
    <link href="http://www.codewoody.com/posts/3626/"/>
    <id>http://www.codewoody.com/posts/3626/</id>
    <published>2019-07-01T09:23:13.000Z</published>
    <updated>2019-07-12T06:10:21.731Z</updated>
    
    <content type="html"><![CDATA[<p>抛开具体的编程语言场景，map是一类非常基本的数据组织形式，其作用是将一个可Hash的值，映射到另一个值，而且一般来讲是一对一的（存在一对多的情况）。map内部使用了红黑树，这棵树具有对数据自动排序的功能，使得对map的检索意义达到非常高的效率。基于键值的查找的复杂度是Log(N)。</p><p>这里讲讲C++标准库里面map的用法。</p><a id="more"></a><h2 id="使用map">使用map</h2><p>头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明时需要指明键与值的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; persons;</span><br></pre></td></tr></table></figure><h2 id="数据插入">数据插入</h2><p>数据插入有三种方法：</p><ol type="1"><li>使用<code>insert</code>函数插入<code>pair</code>数据，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line">students.insert (<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; (<span class="number">1</span>, <span class="string">"Student A"</span>));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>用insert函数插入<code>value_type</code>的数据，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line">students.insert (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"Student A"</span>));</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>用Subscript方式插入数据，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line">students[<span class="number">1</span>] = <span class="string">"Student A"</span></span><br></pre></td></tr></table></figure><p>上面三种插入方式的区别在于，第三种默认会覆盖已经存在的映射，而前两个不会。前两个插入方式等价，在插入的键已经存在于映射中时，当前的插入语句会被忽略。那么如何知道插入是否成功呢？可以通过<code>insert</code>函数的返回值来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res为pair&lt;map&lt;int, string&gt;::iterator, bool&gt;乐行</span></span><br><span class="line"><span class="keyword">auto</span> res = students.insert (pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; (<span class="number">1</span>, <span class="string">"Student A"</span>));</span><br><span class="line"><span class="keyword">if</span> (res.second == <span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert successfully"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert fail"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="数据的遍历">数据的遍历</h2><p>使用迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = students.begin (); iter != students.end (); iter ++ )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// first为key，second为value</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="查找并获取map中的元素">查找并获取map中的元素</h2><p>查找是map的核心功能。我们可以使用<code>find</code>函数来进行查找。当找到目标时，返回一个迭代器，否则返回<code>end</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> iter = students.find (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (iter == students.end ())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"not found "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">string</span> studentName = iter.second;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素">删除元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> iter = students.find (<span class="number">1</span>);</span><br><span class="line">student.erase (iter);</span><br><span class="line"></span><br><span class="line">student.erase (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这会清空整个map</span></span><br><span class="line">student.erase (students.begin (), students.end ());</span><br></pre></td></tr></table></figure><h2 id="further-reading">Further Reading</h2><ul><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">C++中的STL中map用法详解</a></li><li><a href="http://www.cplusplus.com/reference/map/map/map/" target="_blank" rel="noopener">std::map::map</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抛开具体的编程语言场景，map是一类非常基本的数据组织形式，其作用是将一个可Hash的值，映射到另一个值，而且一般来讲是一对一的（存在一对多的情况）。map内部使用了红黑树，这棵树具有对数据自动排序的功能，使得对map的检索意义达到非常高的效率。基于键值的查找的复杂度是Log(N)。&lt;/p&gt;
&lt;p&gt;这里讲讲C++标准库里面map的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://www.codewoody.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 2</title>
    <link href="http://www.codewoody.com/posts/60429/"/>
    <id>http://www.codewoody.com/posts/60429/</id>
    <published>2019-07-01T03:28:09.000Z</published>
    <updated>2019-07-07T07:46:09.000Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="新闻">新闻</h2><h3 id="rick-and-morty-第四季将会在11月上映">Rick and Morty 第四季将会在11月上映</h3><figure><img src="https://imgs.codewoody.com/uploads/big/70077b2773d87db24e9407011d4830f9.jpeg" alt="Rick and Morty · Season 4"><figcaption>Rick and Morty · Season 4</figcaption></figure><h3 id="华为禁令取消"><a href="https://www.williamlong.info/archives/5750.html" target="_blank" rel="noopener">华为禁令「取消」</a></h3><p>6月29日，为期3天（6月27日至29日）的二十国集团领导人第十四次峰会刚刚在日本大阪落下帷幕。29日上午，中、美两国元首举行了约80分钟的会晤，此后两国共同宣布了两大成果：1）中美双方同意在平等和相互尊重的基础上重启经贸磋商。2）美方表示不再对中国出口产品加征新的关税。</p><p>在两国元首会谈之后，美国总统特朗普在记者会上表示，同意让美国公司继续销售产品给华为。</p><p>特朗普解释称，这些卖给华为的产品都是美国公司制造的，是很复杂很科学的产品，是只有美国拥有技术和在制造的产品。“实际上我们在硅谷做的事情令人难以执行，没有人能和我们竞争，所以我同意 -- 我很容易地就同意允许他们继续出售这些产品”，特朗普说，“我们让他们继续卖给华为。”</p><p>据华尔街日报报道，特朗普称将允许美企向华为供货，中国则将开始购买大量美国农产品。他强调了中国大宗采购美国农产品的意愿，将其归为允许向华为出售美国产品和推迟新关税的一大理由。据美国农业部，周五会谈前，中国采购了54.4万吨大豆。？</p><p>美国家经济委员会主席拉里·库德洛在电视采访中更加详细地解释了解禁一事。他表示解禁即将生效，美国商务部可能会考虑“授予一些临时许可证”，让美国公司与华为恢复业务。对于解禁范围，他强调华为仅可以购买“其它国家同样广泛销售的美国芯片产品”，否认这是“特赦”，表示国家安全仍然是最重要的考虑因素，只要不构成国家安全问题，华为可以恢复从美国企业采购产品。</p><h3 id="fuchsia官方开发者网站上线"><a href="https://www.phonearena.com/news/Google-launches-developer-site-for-Fuchsia_id117171" target="_blank" rel="noopener">Fuchsia官方开发者网站上线</a></h3><p>Fuchsia 是 Google 打造的下一代操作系统，它不基于 Linux 内核，运行方式也和 Android 完全不同，但可以通过相关工具让 Android 应用可以移植到新系统中。近日 Google 也正式上线了 Fuchsia 的 开发者网站，从这个网站中开发者可以了解到 Fuchsia 的系统开发进展及其采用的技术，为后续开发做好准备。</p><p>ps: Android的生态其实有点太过恶劣了：</p><blockquote><p>安卓碎片化严重到什么地步？安卓本身有12个版本，如果每个版本有12个厂商，每个厂商有12个手机型号，因此安卓生态至少包含1,728种&quot;版本- 品牌 - 设备&quot;的组合。</p></blockquote><h3 id="大兴机场竣工"><a href="https://www.ifanr.com/1230698?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=" target="_blank" rel="noopener">大兴机场竣工</a></h3><figure><img src="https://imgs.codewoody.com/uploads/big/e2e40d7ca813e5b6b63a3e9feae4efa0.jpg" alt="大兴机场"><figcaption>大兴机场</figcaption></figure><p>时 4 年半，北京大兴国际机场于 6 月 30 日正式竣工，9 月底将投入运营，各家航空公司也陆续公布了在新机场的航线投入计划。</p><p>各家航司的转场投运情况如下：</p><ul><li>国航系（国航、国货航、深航、山航、昆明航、国航内蒙、北京航、大连航）留守首都机场，但国航在大兴有 10% 航班时刻；</li><li>东航系（东航、上航、中联航、东航江苏、东航云南、东航武汉）转场大兴，但东航的京沪快线留守首都机场；</li><li>南航系（南航、厦航、河北航、江西航、重庆航、汕头航、珠海航、贵州航、南航河南）转场大兴；</li><li>海航、大新华航等留守首都机场；</li><li>首都航空转场大兴；</li><li>其他国内航司可选择首都机场或大兴机场任一机场运行，但不得两场运行；</li><li>允许外航及港澳台地区航空公司自行选择运行机场包括两场运行。</li></ul><h3 id="李彦宏演讲被砸场子"><a href="https://www.zhihu.com/question/333022816" target="_blank" rel="noopener">李彦宏演讲被砸场子</a></h3><p>只是为了这张图载一下这个新闻：</p><figure><img src="https://imgs.codewoody.com/uploads/big/94a887f5e808a756a8fded60d728edac.jpeg" alt="宏颜获水"><figcaption>宏颜获水</figcaption></figure><blockquote><p>7月3日，在2019年百度AI开发者大会上发生突发状况，百度董事长、CEO董事长李彦宏在展示完小度最新功能后，被台下观众泼水。由于事发突然，现场一度陷入沉默。面对这样的突发状态，现场观众集体给李彦宏加油打气，李彦宏也很快调整状态，并调侃道：发展AI的路上就是会遇到这种挫折。</p></blockquote><figure><img src="https://imgs.codewoody.com/uploads/big/adf636dd16a6ebf3dca5965471663920.gif" alt="事件现场"><figcaption>事件现场</figcaption></figure><h3 id="北京石景山发生枪战">北京石景山发生枪战</h3><p>应该与扫黑行动有关，据说肇事者已经被抓走了。具体情况不明，舆论被管控了。</p><h3 id="新城控股董事长王振华涉嫌猥亵女童"><a href="https://www.zhihu.com/question/333086645" target="_blank" rel="noopener">新城控股董事长王振华涉嫌猥亵女童</a></h3><figure><img src="https://imgs.codewoody.com/uploads/big/c0f7e4730be3bb36084336bd851b3f8b.jpg" alt="犯罪嫌疑人"><figcaption>犯罪嫌疑人</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/284c43e62d1f48e769b67565600e8f78.png" alt="警情通报"><figcaption>警情通报</figcaption></figure><p>据悉，犯罪行为发生于6月29日下午，地点为大渡河路一家五星级酒店。被猥亵女童事后向在江苏的母亲打电话哭诉，母亲即来沪报警，王某随即被采取强制措施。目前女童已验伤情，阴道有撕裂伤，构成轻伤。</p><p>据最新消息，带女童入住酒店的女子周某也已到案。周某49岁，江苏徐州人。据其供述，事发当天，她带了两个女孩入住酒店，一个9岁，一个12岁。两个女孩的母亲为周某朋友。周某谎称带两女孩去上海迪斯尼玩，从江苏带至上海。当天王某对9岁女童实施犯罪，事后给付周某现金1万元。</p><figure><img src="https://imgs.codewoody.com/uploads/big/d4af1fb2de3140c9a2695823155c924d.jpg" alt="王振华身家3000亿的帝国"><figcaption>王振华身家3000亿的帝国</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/198c60e8f0df06dc0443d0722566eea0.jpg" alt="王振华的更多背景资料"><figcaption>王振华的更多背景资料</figcaption></figure><h2 id="软件推荐">软件推荐</h2><p><a href="https://mathpix.com/" target="_blank" rel="noopener"><strong>Mathpix</strong></a>: 将图片转化成Latex公式，重点是这款软件是免费的！</p><p><img src="https://mathpix.com/images/snip-page/gif_2.gif"> <img src="https://mathpix.com/images/snip-page/gif_3.gif"></p><h2 id="文章与言论">文章与言论</h2><ul><li><p><a href="https://medium.com/swlh/why-defensive-programming-is-the-best-way-for-robust-coding-cfa790fe04cd" target="_blank" rel="noopener">Why defensive programming is the best way for robust coding</a></p></li><li><p><a href="https://www.zhihu.com/question/23979077/answer/730070106" target="_blank" rel="noopener">原生动物是如何演化成后生动物的？</a> <img src="https://imgs.codewoody.com/uploads/big/8aa938aa976af708b6f2a5496d68107b.jpg" alt="Nothing in biology makes sense except in the light of evolution. -- Dobzhansky"></p></li><li><p>日常劝退：<a href="https://www.sciencemag.org/careers/2019/06/it-s-ok-quit-your-phd" target="_blank" rel="noopener">It's ok to quit your Ph.D</a>，中文:<a href="https://zhuanlan.zhihu.com/p/71702212" target="_blank" rel="noopener">Science「劝退文」：读博压力山大，是时候退学了</a></p></li></ul><blockquote><p>读博无疑是一个痛苦的过程。甚至有人说，如今，读博已经变成了“赌博”。面对学业压力，很多博士生选择延期毕业。近日，《科学》杂志发表长文，提供了另一种选择：退学。美国研究生院理事会（Council of Graduate School）公布的数据显示，约1/4的美国科学与工程专业博士生在入学的头3年选择退学。《科学》杂志此次采访了9位博士阶段退学者，并总结了退学的3点理由：对研究失去兴趣，开始追寻其他事业，或是因在学术界的遭遇而心灰意冷。</p></blockquote><ul><li><a href="https://sspai.com/post/55433" target="_blank" rel="noopener">如何更快地读一本书</a></li></ul><figure><img src="https://imgs.codewoody.com/uploads/big/1bf513742dc4e3fe0aa2cd739cc6a1ee.jpeg" alt="呼吸读书法"><figcaption>呼吸读书法</figcaption></figure><ul><li><p>为什么<strong>供给能创造自己的需求</strong>呢？实际上，当生产者还没有生产或提供某种新的商品或消费品时，人们不能真正地看到或意识到这种东西带来的用处，因此很难想到对它的实际需求。就像是地铁，为什么10年前没有四通八达的地铁线路，人们也能按部就班地过日子，没有哭着喊着说没有地铁就不能活呢？这是因为当时人们还没有体会过地铁给他们带来的便捷，生活也并不依赖于它，因此并没有对于它有过于迫切的需求。相反，如果换成现在的我们失去了地铁，整个城市或许都会因此而崩溃。 -- <a href="https://www.toutiao.com/i6708094111167021572/?tt_from=weixin_moments&amp;utm_campaign=client_share&amp;wxshare_count=2&amp;from=timeline&amp;share_type=original&amp;timestamp=1562026117&amp;app=news_article&amp;utm_source=weixin_moments&amp;isappinstalled=0&amp;utm_medium=toutiao_android&amp;req_id=201907020808360100180692209643852&amp;group_id=6708094111167021572&amp;pbid=6677033007465252355" target="_blank" rel="noopener">地铁越修越多，交通反而拥挤</a></p></li><li><p>经济权力就是权力本身。-- <a href="https://www.zhihu.com/question/271847850/answer/726333668" target="_blank" rel="noopener">知乎 - 罗一觉</a></p></li><li><p>你问我宇宙大爆炸之前发生的事情，就像问我南极以南是什么地方。 -- 霍金</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/70077b2773d87db24e9407011d4830f9.jpeg&quot;&gt;
    
    </summary>
    
      <category term="Weekly" scheme="http://www.codewoody.com/categories/Weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Weekly" scheme="http://www.codewoody.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Hexo启用Han支持过程中发现的问题</title>
    <link href="http://www.codewoody.com/posts/36496/"/>
    <id>http://www.codewoody.com/posts/36496/</id>
    <published>2019-06-29T07:04:54.000Z</published>
    <updated>2019-07-12T06:10:47.333Z</updated>
    
    <content type="html"><![CDATA[<p>Han指的是<a href="https://hanzi.pro/manual/" target="_blank" rel="noopener">「汉字标准格式」</a>。 「汉字标准格式」是一个集合了「语意样式标准化」「文字设计」「高级排版功能」等三大概念的网页排版框架，使用Sass及JavaScript构架而成。其专为汉字网页提供的美观而标准化的环境，不仅符合传统阅读习惯、更为萤幕阅读提供了既成标准，得以完整解决现今汉字网页设计的排版需求。</p><figure><img src="https://hanzi.pro/img/typefaces.svg" alt="汉字标准格式"><figcaption>汉字标准格式</figcaption></figure><p>总而言之，使用Han这个框架可以让排版更好看。按道理，启用Han应该在NexT主题中的选项即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">han:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>不过这么设置之后还是不行。原因是启用之后只会引入CSS，而没有引入js渲染，导致一些比较高级的排版效果，如<a href="https://hanzi.pro/manual/hang_de_zucheng" target="_blank" rel="noopener">标点调整</a>无法使用。因此，还需要手动调整一下。于<code>themes/next/layout/_layout.swig</code>的<code>body</code>标签底部加入如下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ethantw.github.io/Han/latest/han.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.hinst = Han().setRoutine([</span></span><br><span class="line"><span class="javascript">      <span class="string">'initCond'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderElem'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderJiya'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderHanging'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderHWS'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'correctBasicBD'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'substCombLigaWithPUA'</span></span></span><br><span class="line"><span class="undefined">    ]).render()</span></span><br><span class="line"><span class="undefined">  &#125;()</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：<a href="https://hanzi.pro/manual/anzhuang_yu_qiyong" target="_blank" rel="noopener">使用文档</a>中给的cloudflare CDN地址里面的js文件渲染有问题，会导致标点不可见，使用<code>github.io</code>这个版本提供的文件就没有问题。另外，如果本地的<code>han.min.css</code>有问题，也可以切换成<code>github.io</code>版本。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://hanzi.pro/img/typefaces.svg&quot; alt=&quot;汉字标准格式&quot;&gt;&lt;figcaption&gt;汉字标准格式&lt;/figcaption&gt;
&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>C++中将结构体放置在std::vector容器内的操作风险</title>
    <link href="http://www.codewoody.com/posts/35148/"/>
    <id>http://www.codewoody.com/posts/35148/</id>
    <published>2019-06-28T08:39:21.000Z</published>
    <updated>2019-07-02T02:04:32.919Z</updated>
    
    <content type="html"><![CDATA[<p>有一组长度不固定的参数需要传输，且参数形式为结构体，那么一个比较简单的方法是将这些参数作为一个<code>std::vector</code>。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct ExampleStruct&gt; data)</span></span>;</span><br></pre></td></tr></table></figure><p>由于C++是采用值传递的方式，每次对<code>std::vector</code>进行元素的存取操作时，都会对涉及的结构体进行复制。如果结构体的数量比较多，或者结构体的体积比加大，那么这种方式对于计算和内存资源的浪费就比较大了。</p><a id="more"></a><p>那么，折中的办法是在<code>std::vector</code>中存放指针。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct ExampleStruct *&gt; data)</span></span>;</span><br></pre></td></tr></table></figure><p>不过，这就给指针的生命周期管理带来了很大的挑战，而且可能会引入非常多耦合性很强的代码。如果函数是state-less，即只对输入参数进行计算，而不更改其他的状态变量，问题倒不是很严重。反之，就会存在很多比较大的漏洞。</p><p>由于局部变量存在作用范围的限制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ExampleStruct</span> <span class="title">a</span>;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  data.push_back (&amp;a);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  f (data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当离开调用<code>f</code>的函数的作用域时，<code>a</code>就会被释放，后续在其他地方访问<code>data</code>时，对应的指针指向的内存区域已经被释放掉了，对其进行访问会导致错误。使用<code>new</code>来讲结构体创建在堆内存上可以解决这个问题，但是这意味着后续这一数据已经利用完之后，要确保此处申请的内存被恰当地释放掉。随着业务逻辑的复杂化，要准确做到这一点会非常困难，强行实现也会带来很多强耦合的代码，扩大引入bug的风险。</p><p>我们剩下的选择，就是使用智能指针<code>std::shared_ptr</code>自动管理堆内存的声明周期。就是形式有点复杂了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::share_ptr&lt;struct ExampleStruct&gt;&gt; data)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一组长度不固定的参数需要传输，且参数形式为结构体，那么一个比较简单的方法是将这些参数作为一个&lt;code&gt;std::vector&lt;/code&gt;。例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;struct ExampleStruct&amp;gt; data)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于C++是采用值传递的方式，每次对&lt;code&gt;std::vector&lt;/code&gt;进行元素的存取操作时，都会对涉及的结构体进行复制。如果结构体的数量比较多，或者结构体的体积比加大，那么这种方式对于计算和内存资源的浪费就比较大了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程研究" scheme="http://www.codewoody.com/categories/%E7%BC%96%E7%A8%8B%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
      <category term="C++" scheme="http://www.codewoody.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何自己搭建一个Time Machine服务器</title>
    <link href="http://www.codewoody.com/posts/14680/"/>
    <id>http://www.codewoody.com/posts/14680/</id>
    <published>2019-06-28T02:52:05.000Z</published>
    <updated>2019-06-28T03:00:55.912Z</updated>
    
    <content type="html"><![CDATA[<p>如何在Ubuntu上搭建一个简洁的Time Machine服务器呢？网上找到的教程说的都比较杂，这里整理一个刚刚经过实践检验的方法来供大家参考。目标系统是<code>Ubuntu 16.04 LTS</code>。 <a id="more"></a></p><h3 id="安装需要的工具">1. 安装需要的工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install netatalk avahi-daemon</span><br></pre></td></tr></table></figure><h3 id="创建一个用于专门用来运行time-machine进程的用户">2. 创建一个用于专门用来运行Time Machine进程的用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -c "Time machine" -m -s /bin/bash tm</span><br></pre></td></tr></table></figure><p>我这里命名为<code>tm</code>，你可以替换为任何你定的名字，但是最好不要使用<code>root</code>用户。 接下来给新用户设定密码 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd tm</span><br></pre></td></tr></table></figure></p><h3 id="准备文件夹">3. 准备文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -R /home/tm/TimeMachineFolder</span><br><span class="line">sudo chown -R tm /home/tm/TimeMachineFolder</span><br></pre></td></tr></table></figure><h3 id="设置netatalk">4. 设置<code>netatalk</code></h3><p>首先我们将原有的配置文件备份 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/netatalk/AppleVolumes.default /etc/netatalk/AppleVolumes.default.old</span><br></pre></td></tr></table></figure></p><p>然后创建一个新的配置文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/netatalk/AppleVolumes.default</span><br></pre></td></tr></table></figure></p><p>使用你偏好的编辑器（vim，nano之类）向这个配置文件中加入如下内容 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:DEFAULT: options:upriv,usedots</span><br><span class="line">/home/tm/TimeMachineFolder "My Time Machine" options:tm volsizelimit:500000 allow:tm</span><br></pre></td></tr></table></figure></p><p>注意将第二行的文件夹路径设定为你再第三步中创建的文件夹的路径。另外，第二行中的<code>volsizelimit</code>设定了Time Machine将会使用的最大硬盘空间，单位是MB。</p><h3 id="重启netatalk服务来应用更改">5. 重启<code>netatalk</code>服务来应用更改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service netatalk restart</span><br></pre></td></tr></table></figure><h3 id="在mac上连接到time-machine">6. 在Mac上连接到Time Machine</h3><p>首先直接尝试在Time Machine中选择这个服务器（会显示在可用磁盘下面，名字显示为第四步中你<code>netatalk</code>设置文件中指定的名字）。 如果你无法找到，那么打开Finder并按下⌘+K，在弹出来的窗口中，于服务器地址一栏输入<code>afp://IP.of.your.server/</code>，然后点连接。如果提示需要输入用户名和密码来登录，那就输入第二步中你设定的用户名密码即可。</p><figure><img src="https://imgs.codewoody.com/uploads/big/408d6956cd13b4c671b4519c1115d97c.png" alt="示意图"><figcaption>示意图</figcaption></figure><p>ref：<a href="http://dae.me/blog/1660/concisest-guide-to-setting-up-time-machine-server-on-ubuntu-server-12-04/" target="_blank" rel="noopener">Concisest guide to setting up Time Machine server on Ubuntu Server 12.04, 14.04 &amp; Debian | Dae’s blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在Ubuntu上搭建一个简洁的Time Machine服务器呢？网上找到的教程说的都比较杂，这里整理一个刚刚经过实践检验的方法来供大家参考。目标系统是&lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="macOS" scheme="http://www.codewoody.com/tags/macOS/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>键盘上的符号的英文读法</title>
    <link href="http://www.codewoody.com/posts/20487/"/>
    <id>http://www.codewoody.com/posts/20487/</id>
    <published>2019-06-28T02:49:04.000Z</published>
    <updated>2019-06-28T02:55:34.098Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">! 叹号 exclamation mark/bang </span><br><span class="line">? 问号 question mark </span><br><span class="line">, 逗号 comma </span><br><span class="line">. 点号 dot/period/point </span><br><span class="line">: 冒号 colon </span><br><span class="line">; 分号 semicolon </span><br><span class="line">” 双引号 quotation marks/double quote </span><br><span class="line">‘ 单引号/撇号 apostrophe/single quote </span><br><span class="line">` 重音号 backquote/grave accent </span><br><span class="line">* 星号 asterisk/star </span><br><span class="line">+ 加号 plus sign </span><br><span class="line">- 减号/横线 hyphen/dash/minus sign/ </span><br><span class="line">= 等号 equal sign </span><br><span class="line">/ 斜线 slash </span><br><span class="line">\ 反斜线 backslash/escape </span><br><span class="line">| 竖线 bar/pipe/vertical bar </span><br><span class="line">_ 下划线 underline/underscore </span><br><span class="line">$ 美元符号 dollar sign </span><br><span class="line">@ at at sign </span><br><span class="line"># 井号 crosshatch/sharp/hash </span><br><span class="line">% 百分号 percent sign/mod </span><br><span class="line">&amp; and/和/兼 and/ampersand </span><br><span class="line">^ 折音号 circumflex/caret </span><br><span class="line">~ 波浪号 tilde </span><br><span class="line">&#123;&#125; （左右）花括号/大括号 (left/right|open/close) braces </span><br><span class="line">[] （左右）方括号/中括号 (left/right|open/close) brackets </span><br><span class="line">() （左右）圆括号/小括号 (left/right|open/close) parentheses </span><br><span class="line">&lt;&gt; 尖括号 angle brackets </span><br><span class="line">&lt; 大于号 less than </span><br><span class="line">&gt; 小于号 greater than</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MAC: @rpath的坑</title>
    <link href="http://www.codewoody.com/posts/21028/"/>
    <id>http://www.codewoody.com/posts/21028/</id>
    <published>2019-06-28T02:47:47.000Z</published>
    <updated>2019-06-28T08:40:45.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem">Problem</h2><p>这篇文章的缘由是我在尝试使用<a href="https://www.nsnam.org" target="_blank" rel="noopener">ns3</a>带的NetAnim程序时，显示了下面这个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/QtGui.framework/Versions/4/QtGui</span><br><span class="line">  Referenced from: /path/to/ns-allinone-3.28/netanim-3.108/./NetAnim</span><br><span class="line">  Reason: image not found</span><br><span class="line">[1]    86663 abort      ./NetAnim</span><br></pre></td></tr></table></figure><a id="more"></a><p>这是一个动态链接的错误，所以没法通过编译的时候添加<code>LDFLAGS</code>来解决。不过错误里面的<code>@rpath</code>这个东西倒是挺有意思，显然并不是环境变量。我在网上查了很多，但是大多数是围绕xcode讨论的，不太适用于我面临的场景（命令行）。不过这些文章（如<a href="http://www.tanhao.me/pieces/1361.html/" target="_blank" rel="noopener">这篇</a>)能够大致阐明<code>@rpath</code>的用途。简而言之，<code>@rpath</code>是一个类似Shell中的<code>PATH</code>的变量，程序在执行时会从<code>@rpath</code>指定的路径中寻找动态链接库文件。那么剩下的问题就是我们如何操作这个变量了。</p><h2 id="solution">Solution</h2><p>通过<code>otool</code>我们可以查看一个程序的动态链接文件搜索地址，例如我要用的<code>NetAnim</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L ./NetAnim</span><br><span class="line">./NetAnim:</span><br><span class="line">@rpath/QtGui.framework/Versions/4/QtGui (compatibility version 4.8.0, current version 4.8.7)</span><br><span class="line">@rpath/QtCore.framework/Versions/4/QtCore (compatibility version 4.8.0, current version 4.8.7)</span><br><span class="line">/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.0)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4)</span><br></pre></td></tr></table></figure><p>而我们可以通过<code>install_name_tool</code>来对这些地址进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ install_name_tool -h</span><br><span class="line">Usage: /Library/Developer/CommandLineTools/usr/bin/install_name_tool [-change old new] ... [-rpath old new] ... [-add_rpath new] ... [-delete_rpath old] ... [-id name] input</span><br></pre></td></tr></table></figure><p>对我而言，我需要将Qt4的动态链接库添加到<code>NetAdmin</code>的搜索路径中去，可以使用如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -add_rpath /usr/<span class="built_in">local</span>/Cellar/qt@4/4.8.7_3/lib ./NetAnim</span><br></pre></td></tr></table></figure><p>大功告成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;这篇文章的缘由是我在尝试使用&lt;a href=&quot;https://www.nsnam.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ns3&lt;/a&gt;带的NetAnim程序时，显示了下面这个错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dyld: Library not loaded: @rpath/QtGui.framework/Versions/4/QtGui&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Referenced from: /path/to/ns-allinone-3.28/netanim-3.108/./NetAnim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Reason: image not found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1]    86663 abort      ./NetAnim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Debug" scheme="http://www.codewoody.com/categories/Debug/"/>
    
    
      <category term="macOS" scheme="http://www.codewoody.com/tags/macOS/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章置顶/置底方法研究</title>
    <link href="http://www.codewoody.com/posts/42846/"/>
    <id>http://www.codewoody.com/posts/42846/</id>
    <published>2019-06-26T14:51:15.000Z</published>
    <updated>2019-06-26T15:02:26.589Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讨论如何在Hexo中方便地实现文章置顶功能。</p><p>最初我采用了<a href="https://blog.minhow.com/2017/08/20/hexo/article-top/" target="_blank" rel="noopener">Hexo文章置顶的方法</a>。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的<code>top</code>值将文章放在末尾。因此我做了 一点修改。</p><a id="more"></a><h2 id="原始方法">原始方法</h2><p>原始方法的核心思想是在Front-Matter中添加一个自定义的<code>top</code>字段，然后在<code>hexo-generator-index</code>中使用这一字段来实现排序。具体操作为，修改文件<code>node_modules/hexo-generator-index/lib/generator.js</code>，添加 如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">        <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更改后的完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">var</span> path = config.index_generator.path || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的front-matter中添加top字段。top值越大，则文章越靠前。top值一样的文章则根据日期排序。front-matter设置的一个例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo文章置顶方法研究</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-06</span><span class="bullet">-26</span> <span class="number">22</span><span class="string">:51:15</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">教程</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">MinHow</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">博客</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">开源项目</span></span><br><span class="line"><span class="attr">cover_picture:</span> <span class="attr">https://cloud.minhow.com/images/miho/theme/github-second.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="解决置底的问题">解决“置底”的问题</h2><p>无法置底的原因很简单，即在上面的js代码修改中，没有设置top值的文章的top变量是未定义的，且规定未定义top的文章总是比定义了top值的文章要靠后。我们赋予未定义top值的文章一个默认的0值，即可解决这个问题的。具体的操作是将修改代码内容替换成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = first.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = second.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">      <span class="keyword">return</span> b - a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> second.date - first.date</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讨论如何在Hexo中方便地实现文章置顶功能。&lt;/p&gt;
&lt;p&gt;最初我采用了&lt;a href=&quot;https://blog.minhow.com/2017/08/20/hexo/article-top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo文章置顶的方法&lt;/a&gt;。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的&lt;code&gt;top&lt;/code&gt;值将文章放在末尾。因此我做了 一点修改。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 1</title>
    <link href="http://www.codewoody.com/posts/25582/"/>
    <id>http://www.codewoody.com/posts/25582/</id>
    <published>2019-06-26T06:05:17.000Z</published>
    <updated>2019-06-29T14:05:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="so-whats-this">So what's this</h2><p>每周我都会读阮一峰的每周分享，有时候也会在其他的博客平台上看见别的博主整理的这些每周资源分享文章，觉得比较有用，我也打算整理一下自己的List。</p><p>最近一年多以来，我尝试尽可能将自己的思考过程以文字的方式记录下来，这样过几天回头来看，便于我整理思路。更重要的是，这种累积会给自己带来沉甸甸的“积累感”，给自己一个强大正反馈。</p><p><em>这篇是这一系类的每周分享的第一篇，贵在坚持！</em></p><a id="more"></a><h2 id="新闻">新闻</h2><h3 id="树莓派4发布"><a href="https://www.ifanr.com/1228499" target="_blank" rel="noopener">树莓派4发布</a></h3><figure><img src="https://imgs.codewoody.com/uploads/big/8d9f81cf9870dc648b9486ff54025a1a.jpg" alt="树莓派4"><figcaption>树莓派4</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/8f4c25a7a87dd9c125bdf779b20c9861.png" alt="树莓派性能对比"><figcaption>树莓派性能对比</figcaption></figure><p>位于英国的教育慈善组织「Raspberry Pi 基金会」推出了它们的新一代产品：树莓派 4（Raspberry Pi 4），性能表现又上升了一个台阶，官方甚至称它「足以媲美一台入门级 x86 电脑」。树莓派的主要性能升级为：</p><ol type="1"><li>搭载了A72架构的BCM2711芯片，主频为1.5GHz</li><li>两个micro-HDMI</li><li>支持最高4GB LPDDR4内存</li><li>802.11ac 双频Wifi</li><li>千兆以太网</li><li>蓝牙5.0</li><li>5V/3A 的USB-C供电</li><li>USB2.0及USB3.0接口</li></ol><p>官方还承诺，会持续生产树莓派 4 至 2026 年 1 月.</p><h3 id="b站三体动画化">B站三体动画化</h3><p><a href="https://passport.weibo.com/visitor/visitor?entry=miniblog&amp;a=enter&amp;url=https%3A%2F%2Fweibo.com%2F1748075785%2FHAJ5ZiuBT&amp;domain=.weibo.com&amp;ua=php-sso_sdk_client-0.6.28&amp;_rand=1561603056.2875" target="_blank" rel="noopener">B站正式宣布《三体》动画化启动</a>: 作为重磅彩蛋，刘慈欣现身B站十周年活动现场。动画由B站出品、三体宇宙和制作方艺画开天联合出品。活动现场首播的概念版PV淋漓尽致地展现三体宇宙的宏大和黑暗森林法则的残酷。</p><blockquote><p>之前在B站上自己组团队做了三体动画（Minecraft版）的神游八方，也加入了动画化的主创团队。</p></blockquote><ul><li><a href="https://www.bilibili.com/3/" target="_blank" rel="noopener">专题页面</a></li></ul><h3 id="游戏适龄提示倡议"><a href="https://finance.sina.com.cn/roll/2019-06-27/doc-ihytcitk8046473.shtml" target="_blank" rel="noopener">《游戏适龄提示倡议》</a></h3><p>6月26日，人民网联合腾讯、网易、完美世界等10家头部游戏公司发起《游戏适龄提示倡议》，把游戏玩家分成4个年龄层级，并提出了相应的提示体系，包括游戏内容、类型和运营等方面的标准。年龄分层方面，此次倡议把游戏玩家分为18+、16+、12+、6+四级。例如6+多是休闲益智类，18+则有大量竞技、策略、棋牌类游戏。</p><figure><img src="https://imgs.codewoody.com/uploads/big/9ecb92ae01cbca2fc5d9909793357417.jpg" alt="分级标准"><figcaption>分级标准</figcaption></figure><blockquote><p>之前听老梁说的好，文化审查领域重要的是“自由裁量权”，而并不是挂在口头上的细枝末节的审查细节。没有分级制度，那么我想让你过你就能过，不让你过，你就不能过，随心所欲，岂不快哉？</p><p>&quot;在国民党统治时期，制定了一个新闻法，我们共产党人仔细研究它的字句，抓它的辫子，钻它的空子。现在我们当权，我看还是不要新闻法好，免得人家钻我们空子。没有法，我们主动，想怎样控制就怎样控制。&quot; -- 陈云 （孙旭培教授曾在《新闻立法之路》一文中引述）</p></blockquote><p>Further Reading：<a href="http://www.midphoto.com/chinese/whatsnew/2016/lawofnews.htm" target="_blank" rel="noopener">为什么中国没有新闻法</a>(<a href="/knowledge-base/backups/为什么中国没有新闻法.md">Backup Link</a>)</p><h3 id="联邦快递起诉美国政府"><a href="https://about.van.fedex.com/newsroom/fedex-statement-on-department-of-commerce-litigation/" target="_blank" rel="noopener">联邦快递起诉美国政府</a></h3><p>6月24日，联邦快递在官网发布声明称，已向哥伦比亚地区的美国地区法院提起诉讼，要求禁止美国商务部对联邦快递执行“出口管理条例”中的禁令。联邦快递认为，《出口管制条例》违反公共承运人在美国宪法第五修正案下的正当权利，因为他们不合理地要求承运人为可能违反《出口管制条例》的运品承担严格责任。</p><blockquote><p>魔幻现实主义</p></blockquote><h3 id="苹果首席设计官jonathan-ive将离职">苹果首席设计官Jonathan Ive将离职</h3><p>苹果首席设计官 Jonathan Ive 将于今年后期正式离开苹果，创立独立的设计公司 LoveFrom，其好友兼著名设计师 Marc Newson 将加入。届时，苹果将成为该设计公司其中一位主要客户。</p><p>Ive 在苹果的代表作包括 iMac、iPod、iPhone 等系列产品，参与设计了苹果的「飞船」总部 Apple Park。他在新闻稿中说：「在将近 30 年和无数项目后，让我最自豪的项目是我们持续投入精力创造了同行无法比拟的苹果设计团队，流程和文化。」</p><iframe width="560" height="315" src="https://www.youtube.com/embed/4xzLr7xSr-g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><blockquote><p>上面视频里的iOS 7即是Jonathan主导的，其革命性的变化在于用扁平化的设计取代拟物化的设计</p></blockquote><h3 id="全电动飞机-alice">全电动飞机 Alice</h3><p>在 6 月 17 日到 23 日举行的巴黎航空展上，以色列航空公司 Eviation 推出了自家首款全电动飞机 Alice。</p><p>这款用「爱丽丝」这个充满诗意的名字来命名的飞机，是全球首款全电动通勤飞机。</p><p>Eviation Alice 内部搭载了功率能达到 功率能够达到 900kW 的三台电机，以及一块可提供 900 千瓦时能量的锂电池。飞机充满一次电可以发行 1037 公里，巡航速度为每小时 407 公里。运载能力方面，Alice 飞机上有 9 个独立座位，同样也需要两名驾驶员才能驾驶。谈到 Alice 的机舱设计时，Eviation 官方表示飞机机舱做了一定的设计优化，自身能为乘客带来更好的降噪。售价方面，Alice 的定价为 400 万美元，折合约 2750 万人民币，每小时的飞行成本为 200 美元，折合约 1372 元。</p><figure><img src="https://imgs.codewoody.com/uploads/big/451b6c55f1bd4fc6d7259c70c17d8151.jpg" alt="巴黎航展 · Alice"><figcaption>巴黎航展 · Alice</figcaption></figure><h3 id="华为-p30-发货量破千万"><a href="http://www.sohu.com/a/323409776_223764?scm=1002.44003c.fe014a0151.PC_ARTICLE_REC&amp;spm=smpc.content.fd-d.32.15615936000232rn2g34" target="_blank" rel="noopener">华为 P30 发货量破千万</a></h3><p>6月27日，华为消费者业务手机产品线总裁何刚在MCW2019大会上公布了一系列数据，其中华为P30系列手机仅上市85天全球发货量就达到1000万台，比P20系列提前了62天。截止今年5月31日，华为手机整体出货量实现149天破亿。</p><figure><img src="https://imgs.codewoody.com/uploads/big/505dab1d529dfe5d3ef449446d007f59.png" alt="华为 P30 发货量破千万"><figcaption>华为 P30 发货量破千万</figcaption></figure><blockquote><p>果粉表示真香，想买。以及，辣鸡KOL</p></blockquote><h2 id="典故与梗">典故与梗</h2><p><strong>不作安安饿殍，效尤奋臂螳螂</strong></p><p>这句话，我一直理解反了意思。开始我以为是指不愿意做饿死鬼，即便是螳臂当车也要起来反抗的意思。结果，其原意是完全相反的。</p><p><a href="https://www.zhihu.com/question/68212300" target="_blank" rel="noopener">这句话出自顾诚的《明末农民战争史》的注释中</a>:</p><blockquote><p>【22】谈迁：《北游录》，《纪闻上》，《榜购一词》条。按：此条首云“总督杨文岳嗣昌出师，榜辑剧寇张献忠”，杨嗣昌字文弱，谈迁误为文岳，又称之为总督，遂与明保定总督杨文岳混为一人。杨复吉《梦阑琐笔》载此事时更写成“保督杨文岳出师榜缉张献忠”，均误。又杨氏所载词中“兴安、平利走四方”一句作“兴安、平利走东乡”。李馥荣：《滟滪囊》卷一所载杨嗣昌榜刊《西江月》词句为：“<strong>不作安安饿殍，效尤奋臂螳螂</strong>。往来楚蜀肆猖狂，弄兵潢池无状。云屯雨骤师集，蛇豕奔突奚藏？许尔军民绑来降，爵赏酬功上上。”或系杨嗣昌所刊另一榜文。</p></blockquote><p>这句话的意思是，尔等不安安静静地做一个饿死鬼，却效仿螳臂当车，自不量力（抵抗朝廷的剿灭大军）。当然，这句话可能并非杨总督本人所说，只是文人调侃他所做。不过，这句话透出的想法，杨总督脑子里大抵是有的，只不过要脸，不好说出来。对于这些统治者来捉，有这样的想法，其实不足为奇。但是，偏偏就有一些明明遇到乱世就会沦为“饿殍”的人，摆不正自己的位置。</p><p>历代造反的贫民，从陈胜吴广，到李自成，洪秀全，诚然造成了巨大的破坏，但若是不造反，又有什么活路呢？难道，做安安饿殍么？</p><h2 id="情绪">情绪</h2><p><strong>Youtube博主Etika自杀</strong></p><figure><img src="https://imgs.codewoody.com/uploads/big/b05fd2ee2db8d5adb14afe276509fe43.jpg" alt="Etika"><figcaption>Etika</figcaption></figure><p>2019年6月19日，Etika上传了一段疑似自杀宣言的视频，他背起书包，离开了家门。至此以后，没有人再看到Etika的任何踪迹。</p><p>6月22日，警方发现了Etika被遗弃的个人物品，在高达340英尺的大桥之上。</p><p>6月25日，纽约警方在布鲁克林大桥水域发现一具未明身份的男性遗体。今日，警方发布正式公告，遗体确为Etika本人，死因是自杀。</p><figure><img src="https://imgs.codewoody.com/uploads/big/d136781dd7e96199bc4f3697a7ccf46a.jpg" alt="网友在Etika自杀地的悼念"><figcaption>网友在Etika自杀地的悼念</figcaption></figure><blockquote><p>有很多极度抑郁的人以至于要自杀的人，有时候看起来会很开心的样子。永远不要以为自己有多么了解一个人，尤其是一个你没有那么熟悉，甚至是陌生的人。</p></blockquote><h2 id="文章与言论">文章与言论</h2><ol type="1"><li><p><a href="http://ohshitgit.com/" target="_blank" rel="noopener">Oh shit, git!</a>：作者针对一些在使用git过程中的痛点给出了解决方法</p></li><li><p><a href="https://jarv.is/notes/how-to-backup-linux-server/" target="_blank" rel="noopener">How To: Automatically Backup a Linux VPS to a Separate Cloud Storage Service</a>：如何将VPS备份到一个云存储平台</p></li><li><p>安卓碎片化严重到什么地步？安卓本身有12个版本，如果每个版本有12个厂商，每个厂商有12个手机型号，因此安卓生态至少包含1,728种&quot;版本- 品牌 - 设备&quot;的组合。</p></li><li><p><a href="https://www.prnewswire.com/news-releases/prose-proximity-services-for-lte--5g-networks-2017-2030---opportunities-challenges-strategies--forecasts-300396915.html" target="_blank" rel="noopener">ProSe (Proximity Services) for LTE &amp; 5G Networks: 2017-2030 - Opportunities, Challenges, Strategies &amp; Forecasts</a>: 5G是近年来的热词了，也是这次美国对华为发难的一个重要因素。不过舆论对于5G的认识，一般是一个加强版的4G蜂窝网。其实5G中引入的Promxity Service技术，将为传统蜂窝网引入D2D的能力，这可能带来深远的影响。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/6db29e24d20b926b20359a495e28fdcf.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Weekly" scheme="http://www.codewoody.com/categories/Weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="树莓派" scheme="http://www.codewoody.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Weekly" scheme="http://www.codewoody.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Python下的音频处理库librosa打开文件是显示NoBackendError的解决</title>
    <link href="http://www.codewoody.com/posts/40199/"/>
    <id>http://www.codewoody.com/posts/40199/</id>
    <published>2019-06-26T04:56:10.000Z</published>
    <updated>2019-06-28T08:40:42.899Z</updated>
    
    <content type="html"><![CDATA[<p>近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。 <a id="more"></a></p><p>由于我的程序中只采用了<code>librosa.load</code>这个命令，通过源代码可以发现librosa实际上是用<code>audioread</code>这个库的<code>audioread.audio_open</code>来读取音频文件的。这个函数的源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_open</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">"""Open an audio file using a library that is available on this</span></span><br><span class="line"><span class="string">    system.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Standard-library WAV and AIFF readers.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> rawread</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> rawread.RawAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Core Audio.</span></span><br><span class="line">    <span class="keyword">if</span> _ca_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> macca</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> macca.ExtAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GStreamer.</span></span><br><span class="line">    <span class="keyword">if</span> _gst_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> gstdec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> gstdec.GstAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MAD.</span></span><br><span class="line">    <span class="keyword">if</span> _mad_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> maddec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> maddec.MadAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FFmpeg.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> ffdec</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ffdec.FFmpegAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># All backends failed!</span></span><br><span class="line">    <span class="keyword">raise</span> NoBackendError()</span><br></pre></td></tr></table></figure><p>可见之前我们遇到的NoBackendError就是这里的最后一行抛出的了，由于我安装的FFmpeg，进一步进入ffdec.py这个文件中。不难发现实际打开文件的是下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">popen_multiple</span><span class="params">(commands, command_args, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Like `subprocess.Popen`, but can try multiple commands in case</span></span><br><span class="line"><span class="string">    some are not available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `commands` is an iterable of command names and `command_args` are</span></span><br><span class="line"><span class="string">    the rest of the arguments that, when appended to the command name,</span></span><br><span class="line"><span class="string">    make up the full first argument to `subprocess.Popen`. The</span></span><br><span class="line"><span class="string">    other positional and keyword arguments are passed through.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i, command <span class="keyword">in</span> enumerate(commands):</span><br><span class="line">        cmd = [command] + command_args</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> subprocess.Popen(cmd, *args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">if</span> i == len(commands) - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># No more commands to try.</span></span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>这里的<code>commands</code>是直接传入的第33行的<code>COMMANDS</code>变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>我这里倒腾了好几下，最终发现实际是错误的原因是没有找到ffmpeg这个命令。我们在这里将ffmpeg替换成ffmpeg的绝对路径。你可以通过下面这行命令找到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ffmpeg</span><br></pre></td></tr></table></figure><p>最终我改成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'/usr/bin/ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>Boom！一切就工作正常了。这么想起来应该是安装ffmpeg的时候的环境变量有问题，导致在command line方式下调用ffmpeg命令出错吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。
    
    </summary>
    
      <category term="Debug" scheme="http://www.codewoody.com/categories/Debug/"/>
    
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="python" scheme="http://www.codewoody.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Latex中各种各样的箭头</title>
    <link href="http://www.codewoody.com/posts/13297/"/>
    <id>http://www.codewoody.com/posts/13297/</id>
    <published>2019-06-24T01:52:42.000Z</published>
    <updated>2019-06-24T02:19:58.271Z</updated>
    
    <content type="html"><![CDATA[<p>Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。 <a id="more"></a></p><h2 id="默认箭头">默认箭头</h2><p>这里的默认指你不需要任何额外的<code>usepackage</code>就可以使用：</p><!-- ![默认箭头](https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png) --><img src="https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png" width="60%"><figcaption>默认箭头</figcaption><h2 id="amssymb提供的箭头">amssymb提供的箭头</h2><p>需要<code>\usepackage{amssymb}</code></p><!-- ![amssymb箭头](https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png) --><img src="https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png" width="60%"><figcaption>amssymb箭头</figcaption><h2 id="further-reading">Further Reading</h2><p><a href="http://www.sascha-frank.com/Arrow/latex-arrows.html" target="_blank" rel="noopener">LaTeX arrows</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="latex" scheme="http://www.codewoody.com/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>部署Pritunl来使用OpenVPN</title>
    <link href="http://www.codewoody.com/posts/23676/"/>
    <id>http://www.codewoody.com/posts/23676/</id>
    <published>2019-06-13T06:16:27.000Z</published>
    <updated>2019-06-13T07:04:39.437Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="why-vpn">Why VPN</h2><p>为什么要使用VPN？尤其是，为什么个人用户需要使用VPN呢？其实如果你只有一台电脑，其实一般用不上VPN（当然，用VPN来翻墙另说），如果你有多个电脑，甚至是服务器，这些服务器的网络情况还比较复杂，而你希望随时随地方便地访问这些机器，那么建立VPN虚拟网络将这些机器连接起来就能极大的方便访问过程。例如，如果一台服务器是在路由器后面，没有公网IP，与其在路由器上配置复杂的端口映射表，不如通过VPN网络自由地访问各个端口。又例如在一些特定的场景下，一些服务器的低位（1024以下）端口的访问会收到限制，这个也可以同VPN来解决。</p><p>当然，还有可能，你处于校园网中，而你通过种种途径有了一个无限流量服务器，通过VPN，可以让你在校园网场景下能够随时通过这台服务器上网，从而免去流量费用。另外，将这一宝贵资源分享给同学使用，用VPN也非常方便。</p><h2 id="why-pritunl">Why Pritunl</h2><p>我试过很多VPN方案，例如PPTP，OpenVPN，IPSec等等。其实使用VPN过程中的一个痛点在于用户管理要尽可能方便，虽然我也比较多的在用命令行工具，但是使用命令行工具去管理用户体验还是非常差。Pritunl提供了OpenVPN的网页GUI管理界面。这也是我为什么推荐使用Priunl的原因。而且，Pritunl中免费用户就可以使用无数量限制的账户和设备，这对于个人用户来说足够了。</p><p>另一方面，Pritunl的客户端支持也非常全面</p><h2 id="how-to-deploy">How to deploy</h2><h3 id="installation">Installation</h3><p>官方文档在这里: <a href="https://docs.pritunl.com/docs/installation" target="_blank" rel="noopener">Installation</a>。事实上按照官方文档的推荐，Pritunl最好部署在企业级的Linux OS上，如Red Hat, Oracle Linux, CentOS等。不过对于个人用户，对于性能，稳定性和安全性要求没有那么严格的情况下，用Debian系的系统也未尝不可。我的Pritunl服务器就是部署在Ubuntu上的，几个月使用下来，性能和稳定性都非常好。</p><p>对于不同版本的系统，安装脚本不同。例如，Ubuntu 16.04，安装脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list &lt;&lt; EOF</span><br><span class="line">deb https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.0 multiverse</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo tee /etc/apt/sources.list.d/pritunl.list &lt;&lt; EOF</span><br><span class="line">deb http://repo.pritunl.com/stable/apt xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 9DA31620334BD75D9DCB49F368818C72E52529D4</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 7568D9BB55FF9E5287D586017AE645C0CF8E292A</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get --assume-yes install pritunl mongodb-org</span><br><span class="line">sudo systemctl start pritunl mongod</span><br><span class="line">sudo systemctl enable pritunl mongod</span><br></pre></td></tr></table></figure><h3 id="configuration">Configuration</h3><p>在安装完Pritunl之后，访问服务器的443端口，即可以看到配置引导界面。</p><figure><img src="https://imgs.codewoody.com/uploads/big/04288b446ec0e7ad27b790dd4890d71b.png" alt="配置界面"><figcaption>配置界面</figcaption></figure><p>其中需要输入的主要是第一项Setup Key。数据库部分，如果你是使用上面的脚本安装的话，那么Pritunl服务本机上就已经安装运行了MongoDB，这里第二个配置MongoDB URI就不需要变动。要获取Setup Key，ssh进入部署服务器，运行<code>pritunl setup-key</code>即可.</p><p>完成这一步设置以后就来到管理员登录界面：</p><figure><img src="https://imgs.codewoody.com/uploads/big/5310344dc5cd485d83835f900fdf38df.png" alt="管理员登录界面"><figcaption>管理员登录界面</figcaption></figure><p>初始时用户名和密码都是<code>pritunl</code>，在完成第一次登录之后会被要求修改管理员的用户名和密码：</p><figure><img src="https://imgs.codewoody.com/uploads/big/88164d6b435cfb64cc84a35bd6188235.png" alt="修改密码"><figcaption>修改密码</figcaption></figure><h2 id="further-reading">Further Reading</h2><p>Pritunl的使用方法非常直观，文档可以参见<a href="https://docs.pritunl.com/docs/connecting" target="_blank" rel="noopener">Connecting</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/0f3a766a78effb06b6770d8a61ad2e55.png&quot; alt=&quot;Pritunl&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="vpn" scheme="http://www.codewoody.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Linux下OpenVPN客户端配置</title>
    <link href="http://www.codewoody.com/posts/38823/"/>
    <id>http://www.codewoody.com/posts/38823/</id>
    <published>2019-05-17T02:46:41.000Z</published>
    <updated>2019-05-17T03:21:20.760Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.codewoody.com/uploads/big/cb54becbed976afbcd2d21733fcf85c6.png" alt="OpenVPN"> <a id="more"></a></p><h2 id="环境配置">环境配置</h2><p>安装OpenVPN的方法很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn</span><br></pre></td></tr></table></figure><h2 id="使用方法">使用方法</h2><p>首先你需要从OpenVPN服务提供商那里得到<code>*.ovpn</code>配置文件，然后在服务器上运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openvpn --config your.ovpn</span><br></pre></td></tr></table></figure><p>不过这个命令会在前台运行，当我们退出SSH之后就会终止。为了让OpenVPN能够在后台运行，且能够自动开机启动，我们需要借助于Systemctl的帮助。首先我们将ovpn文件复制到<code>/etc/openvpn/client/</code>下，<strong>将后缀直接修改为<code>.conf</code></strong>。如果配置文件需要我们手动输入密码，我们需要将密码以配置文件的形式固定下来，不然自动启动会失败。在<code>/etc/openvpn/client/</code>新建一个<code>account.txt</code>文件，在其中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username</span><br><span class="line">password</span><br></pre></td></tr></table></figure><blockquote><p>有些OpenVPN服务端工具只会生成密码（例如Pritunl），在这里username可以随意输入一个，然后在下面一行添加密码。</p></blockquote><p>然后进入配置文件，找到<code>auth-user-pass</code>。默认情况下这个配置条目后面是空的，我们将其修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth-user-pass /etc/openvpn/client/account.txt</span><br></pre></td></tr></table></figure><p>假设前面我们复制过来的配置文件的名字为<code>default.conf</code>。输入下面的命令以启用这个vpn：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn-client@default</span><br></pre></td></tr></table></figure><p>要启动这个vpn，使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvpn-client@default</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/cb54becbed976afbcd2d21733fcf85c6.png&quot; alt=&quot;OpenVPN&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
      <category term="vpn" scheme="http://www.codewoody.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib in Virtualenv</title>
    <link href="http://www.codewoody.com/posts/30912/"/>
    <id>http://www.codewoody.com/posts/30912/</id>
    <published>2019-05-16T05:56:36.000Z</published>
    <updated>2019-06-28T08:40:38.956Z</updated>
    
    <content type="html"><![CDATA[<p>我使用的是macOS系统。当在虚拟环境中尝试使用matplotlib时，会出现如下的报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of &apos;python&apos; with &apos;pythonw&apos;. See &apos;Working with Matplotlib on OSX&apos; in the Matplotlib FAQ for more informatio</span><br></pre></td></tr></table></figure><a id="more"></a><p>根据错误信息，要么我们使用Python as Framework，要么我们更换使用的后端（backend）。Matplot专门就matplotlib的后端问题有一个网页：<a href="https://matplotlib.org/faq/virtualenv_faq.html" target="_blank" rel="noopener">Working with Matplotlib in Virtual environments</a>。文章中提到，<code>Tk</code>这个框架（即<code>TkAgg</code>后端）一般来说总是可用的，不需要额外的外部依赖。（不过在特定的Linux发行版本中可能需要安装<code>python-tk</code>）。要使用<code>Tk</code>需要做如下配置过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">"TkAgg"</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>每次这么配置比较麻烦，我们可以通过<code>~/.matplotlib/matplitlibrc</code>文件来固化配置（如果这个文件不存在可以手动创建），文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backend: TkAgg</span><br></pre></td></tr></table></figure><p>不过我在使用过程中发现使用<code>TkAgg</code>时会出现系统级的错误，抛出了<code>Terminating app due to uncaught exception</code>的错误。因此我尝试替换成其他后端。我主要选择包括：</p><figure><img src="https://imgs.codewoody.com/uploads/big/bdd0f72aede5a20bf5378bc373287e55.png" alt="Matplotlib可用后端类型"><figcaption>Matplotlib可用后端类型</figcaption></figure><p>而又因为<code>PySide</code>只支持比较早的python版本，因此我选择了Qt5作为后端。在这之前，我们需要安装下面的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install qt</span><br><span class="line">pip install PySide2</span><br></pre></td></tr></table></figure><p>安装完成后配置过程和<code>TkAgg</code>的类似，后端的名字为<code>QT5Agg</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我使用的是macOS系统。当在虚拟环境中尝试使用matplotlib时，会出现如下的报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ImportError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of &amp;apos;python&amp;apos; with &amp;apos;pythonw&amp;apos;. See &amp;apos;Working with Matplotlib on OSX&amp;apos; in the Matplotlib FAQ for more informatio&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="python" scheme="http://www.codewoody.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ns3 在模块中使用第三方库</title>
    <link href="http://www.codewoody.com/posts/53831/"/>
    <id>http://www.codewoody.com/posts/53831/</id>
    <published>2019-05-12T12:47:21.000Z</published>
    <updated>2019-05-12T13:31:18.615Z</updated>
    
    <content type="html"><![CDATA[<p>ns3使用了waf编译系统，因此在ns3中尝试引入第三方模块时，就没有make那么直接了。</p><a id="more"></a><p>其实思路的核心还是想办法最终为编译器提供<code>-L</code>和<code>-I</code>的设置。这个过程我们通过<code>wscript</code>中的<code>configure</code>函数来实现。这里我们假设模块使用的库的位置放在模块源码目录下的<code>libs</code>子目录。库的名字为<code>example-lib</code>。目录结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libs</span><br><span class="line">└── example-lib</span><br><span class="line">  ├── include</span><br><span class="line">  └── libexample-lib.a</span><br></pre></td></tr></table></figure><p>其中，<code>include</code>文件夹内为头文件，<code>libexample-lib.a</code>为静态库文件。</p><p>修改<code>wscript</code>文件中的configure函数，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(conf)</span>:</span></span><br><span class="line">    root_dir = conf.path.abspath()</span><br><span class="line">    example_lib_dir = os.path.join(root_dir, <span class="string">"libs/example-lib"</span>)</span><br><span class="line">    conf.env.append_value(<span class="string">"LINKFLAGS"</span>, </span><br><span class="line">        [<span class="string">"-L%s/"</span> % example_lib_dir])</span><br><span class="line">    conf.env.append_value(<span class="string">"LIB"</span>, [<span class="string">"example-lib"</span>])</span><br><span class="line">    conf.env.append_value(<span class="string">"CPPFLAGS"</span>, </span><br><span class="line">        [<span class="string">"-I%s/include"</span> % example_lib_dir, ])</span><br></pre></td></tr></table></figure><p>修改<code>configure</code>函数之后要重新运行<code>./waf configure</code>命令来让设置生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ns3使用了waf编译系统，因此在ns3中尝试引入第三方模块时，就没有make那么直接了。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>ns3 wscript: 自动寻找需编译的源文件</title>
    <link href="http://www.codewoody.com/posts/3426/"/>
    <id>http://www.codewoody.com/posts/3426/</id>
    <published>2019-05-11T08:19:17.000Z</published>
    <updated>2019-05-15T05:15:05.307Z</updated>
    
    <content type="html"><![CDATA[<p>在ns3的编译体系中，每个module会包含一个名为wscript的python脚本来提供编译信息。例如，一个通过<code>create-module.py</code>创建的module中的wscript为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def options(opt):</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def configure(conf):</span></span><br><span class="line"><span class="comment">#     conf.check_nonfatal(header_name='stdint.h', define_name='HAVE_STDINT_H')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(bld)</span>:</span></span><br><span class="line">    module = bld.create_ns3_module(<span class="string">'example-module'</span>, [<span class="string">'core'</span>])</span><br><span class="line">    module.source = [</span><br><span class="line">        <span class="string">'model/example-module.cc'</span>,</span><br><span class="line">        <span class="string">'helper/example-module-helper.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    module_test = bld.create_ns3_module_test_library(<span class="string">'example-module'</span>)</span><br><span class="line">    module_test.source = [</span><br><span class="line">        <span class="string">'test/example-module-test-suite.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    headers = bld(features=<span class="string">'ns3header'</span>)</span><br><span class="line">    headers.module = <span class="string">'example-module'</span></span><br><span class="line">    headers.source = [</span><br><span class="line">        <span class="string">'model/example-module.h'</span>,</span><br><span class="line">        <span class="string">'helper/example-module-helper.h'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bld.env.ENABLE_EXAMPLES:</span><br><span class="line">        bld.recurse(<span class="string">'examples'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bld.ns3_python_bindings()</span></span><br></pre></td></tr></table></figure><p>其中，<code>module.source</code>中包含需要编译的<code>.cc</code>源文件，而<code>headers.source</code>中包含对应的头文件。每次新建C++源代码文件时，都需要手动添加到这里的列表中。下面我给出一个自动从<code>module</code>的<code>model</code>, <code>helper</code>目录下搜索源文件的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def options(opt):</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def configure(conf):</span></span><br><span class="line"><span class="comment">#     conf.check_nonfatal(header_name='stdint.h', define_name='HAVE_STDINT_H')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_list_sources</span><span class="params">(bld, suffix)</span>:</span></span><br><span class="line">    root_dir = bld.path.abspath()</span><br><span class="line">    res = [</span><br><span class="line">        x <span class="keyword">for</span> x <span class="keyword">in</span> </span><br><span class="line">            [os.path.join(<span class="string">"model"</span>, y) <span class="keyword">for</span> y <span class="keyword">in</span> os.listdir(os.path.join(root_dir, <span class="string">"model"</span>))]</span><br><span class="line">        <span class="keyword">if</span> x.endswith(suffix)</span><br><span class="line">    ]</span><br><span class="line">    res += [</span><br><span class="line">        x <span class="keyword">for</span> x <span class="keyword">in</span> </span><br><span class="line">            [os.path.join(<span class="string">"helper"</span>, y) <span class="keyword">for</span> y <span class="keyword">in</span> os.listdir(os.path.join(root_dir, <span class="string">"helper"</span>))]</span><br><span class="line">        <span class="keyword">if</span> x.endswith(suffix)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(bld)</span>:</span></span><br><span class="line">    module = bld.create_ns3_module(<span class="string">'example-module'</span>, [<span class="string">"core"</span>])</span><br><span class="line">    module.source = _list_sources(bld, <span class="string">".cc"</span>)</span><br><span class="line"></span><br><span class="line">    module_test = bld.create_ns3_module_test_library(<span class="string">'example-module'</span>)</span><br><span class="line">    module_test.source = [</span><br><span class="line">        <span class="string">'test/mix-autonomy-test-suite.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    headers = bld(features=<span class="string">'ns3header'</span>)</span><br><span class="line">    headers.module = <span class="string">'example-module'</span></span><br><span class="line">    headers.source = _list_sources(bld, <span class="string">".h"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bld.env.ENABLE_EXAMPLES:</span><br><span class="line">        bld.recurse(<span class="string">'examples'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bld.ns3_python_bindings()</span></span><br></pre></td></tr></table></figure><blockquote><p>注意不要直接套用上面的范例文件，需要将&quot;example-module&quot;的名字改为你的module的名字</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在ns3的编译体系中，每个module会包含一个名为wscript的python脚本来提供编译信息。例如，一个通过&lt;code&gt;create-module.py&lt;/code&gt;创建的module中的wscript为&lt;/p&gt;
&lt;figure class=&quot;highlight py
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线原理</title>
    <link href="http://www.codewoody.com/posts/50553/"/>
    <id>http://www.codewoody.com/posts/50553/</id>
    <published>2019-05-10T02:38:26.000Z</published>
    <updated>2019-05-10T03:03:53.812Z</updated>
    
    <content type="html"><![CDATA[</p><p>这是一篇<a href="https://www.cnblogs.com/hnfxs/p/3148483.html" target="_blank" rel="noopener">转载文章</a>。Bézier curve(贝塞尔曲线)是应用于二维图形应用程序的数学曲线。 曲线定义：起始点、终止点（也称锚点）、控制点。通过调整控制点，贝塞尔曲线的形状会发生变化。 1962年，法国数学家Pierre Bézier第一个研究了这种矢量绘制曲线的方法，并给出了详细的计算公式，因此按照这样的公式绘制出来的曲线就用他的姓氏来命名，称为贝塞尔曲线。</p><h2 id="抛物线三切线定理">抛物线三切线定理</h2><p>设<span class="math inline">\(P_0\)</span>，<span class="math inline">\(P_0^2\)</span>，<span class="math inline">\(P_2\)</span>是一跳抛物线上顺序不同的三个点。过<span class="math inline">\(P_0\)</span>和<span class="math inline">\(P2\)</span>的切线交于<span class="math inline">\(P_1\)</span>。过<span class="math inline">\(P_0^2\)</span>的切线交<span class="math inline">\(P_0 P_1\)</span>和<span class="math inline">\(P_2 P_1\)</span>相交于<span class="math inline">\(P_0^1\)</span>和<span class="math inline">\(P_1^1\)</span>，则有如下比例成立：</p><p><span class="math display">\[\begin{equation}\frac{P_{0} P_{0}^{1}}{P_{0}^{1} P_{1}}=\frac{P_{1} P_{1}^{1}}{P_{1}^{1} P_{2}}=\frac{P_{0}^{1} P_{0}^{2}}{P_{0}^{2} P_{1}^{1}}\end{equation}\]</span></p><figure><img src="https://imgs.codewoody.com/uploads/big/c6362fee9c4a8ffabc786c7b8c37a826.gif" alt="抛物线三切线定理示意图"><figcaption>抛物线三切线定理示意图</figcaption></figure><p>此即为抛物线的三切线定理。</p><h2 id="二次贝塞尔曲线">二次贝塞尔曲线</h2><p>当<span class="math inline">\(P_0\)</span>，<span class="math inline">\(P_2\)</span>固定时，引入参数<span class="math inline">\(t\)</span>，令上述比例值为<span class="math inline">\(t:(1-t)\)</span>，即有：</p><p><span class="math display">\[\begin{equation}\begin{array}{l}{P_{0}^{1}=(1-t) P_{0}+t P_{1}} \\ {P_{1}^{1}=(1-t) P_{1}+t P_{2}} \\ {P_{0}^{2}=(1-t) P_{0}^{1}+t P_{1}^{1}}\end{array}\end{equation}\]</span></p><p>将第一，二个式子代入第三个有：</p><p><span class="math display">\[\begin{equation}P_{0}^{2}=(1-t)^{2} P_{0}+2 t(1-t) P_{1}+t^{2} P_{2}\end{equation}\]</span></p><p>当<span class="math inline">\(t\)</span>从0变到1时，<span class="math inline">\(P_0^2\)</span>点经过的轨迹即为上图中的抛物线，也即为由三顶点<span class="math inline">\(P_0\)</span>, <span class="math inline">\(P_1\)</span>, <span class="math inline">\(P_2\)</span>决定的一条二次贝塞尔曲线。也可以认为这条二次贝塞尔曲线是由两个前顶点<span class="math inline">\((P_0, P_1)\)</span>以及两个后顶点<span class="math inline">\((P_1, P_2)\)</span>决定的。</p><h2 id="更高阶的贝塞尔曲线">更高阶的贝塞尔曲线</h2><p>类似于二次贝塞尔曲线的推导过程，我们可以推广到更高阶的贝塞尔曲线。</p><p>由四个控制点定义的三次Bezier曲线<span class="math inline">\(P_0^3\)</span>可被定义为分别由<span class="math inline">\((P_0,P_1,P_2)\)</span>和<span class="math inline">\((P_1,P_2,P_3)\)</span>确定的二条二次Bezier曲线的线性组合，由<span class="math inline">\((n+1)\)</span>个控制点<span class="math inline">\(P_i(i=0,1,...,n)\)</span>定义的n次Bezier曲线<span class="math inline">\(P_0^n\)</span>可被定义为分别由前、后<span class="math inline">\(n\)</span>个控制点定义的两条<span class="math inline">\((n-1)\)</span>次Bezier曲线<span class="math inline">\(P_0^{n-1}\)</span>与<span class="math inline">\(P+0^{n-1}\)</span>的线性组合：</p><p><span class="math display">\[\begin{equation}P_{0}^{n}=(1-t) P_{0}^{n-1}+t P_{1}^{n-1} \quad t \in[0,1]\end{equation}\]</span></p><p>由此可以得到Bezier曲线的踢腿计算公式</p><p><span class="math display">\[\begin{equation}P_{i}^{k}=\left\{\begin{array}{c}{P_{i}} &amp; {k=0} \\ {(1-t) P_{i}^{k-1}+t P_{i+1}^{k-1}} &amp; {k=1,2, \cdots, n, i=0,1, \cdots, n-k}\end{array}\right.\end{equation}\]</span></p><p>这就是de Castelijau算法。</p><h2 id="贝塞尔曲线原理动图">贝塞尔曲线原理动图</h2><figure><img src="https://imgs.codewoody.com/uploads/big/bcaaa9ffd59424956ecaf9bf9997ad41.gif" alt="一阶贝塞尔曲线"><figcaption>一阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/5f61dfa0ca56be6f035a7800a5be35d2.gif" alt="二阶贝塞尔曲线"><figcaption>二阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/8fad9c6df6e51bc78f83b44ee9fb65d1.gif" alt="三阶贝塞尔曲线"><figcaption>三阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/318c16114eacc2f0899fdf6f19df996b.gif" alt="四阶贝塞尔曲线"><figcaption>四阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/16bd24901ea98b88916dcbb0ead66cd7.gif" alt="五阶贝塞尔曲线"><figcaption>五阶贝塞尔曲线</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/16bd24901ea98b88916dcbb0ead66cd7.gif&quot; alt=&quot;五阶贝塞尔曲线&quot;&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.codewoody.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="processing" scheme="http://www.codewoody.com/tags/processing/"/>
    
      <category term="数学" scheme="http://www.codewoody.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
