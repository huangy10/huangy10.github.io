<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>治部少辅</title>
  
  <subtitle>大一大万大吉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codewoody.com/"/>
  <updated>2019-02-26T03:15:02.858Z</updated>
  <id>http://www.codewoody.com/</id>
  
  <author>
    <name>Woody Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【转载】在小米电视和小米盒子上看YOUTUBE</title>
    <link href="http://www.codewoody.com/posts/5827/"/>
    <id>http://www.codewoody.com/posts/5827/</id>
    <published>2019-02-25T06:41:32.000Z</published>
    <updated>2019-02-26T03:15:02.858Z</updated>
    
    <content type="html"><![CDATA[</p><p>使用小米电视和小米盒子看YouTube上的视频，是很多中国电视用户很想做的事情，下面，我就介绍一种很简单的方法，不用ROOT小米电视或小米盒子，不用重装系统，几分钟的设置就可以在小米电视和小米盒子上看YouTube的方法。</p><p>首先需要下载两个APK应用，第一个是<a href="https://smartyoutubetv.github.io/" target="_blank" rel="noopener">SmartYouTubeTV</a>，点击这里下载最新版SmartYouTubeTV，将其复制到U盘。第二个是Shadowsocks，访问<a href="https://www.apkmirror.com/" target="_blank" rel="noopener">apkmirror</a>网站，搜索Shadowsocks，找到最新版后，下载universal的apk到U盘即可。</p><p>之后，打开小米电视或小米盒子，在“设置-账户与安全”里，选择“允许安装未知来源的应用”。插入U盘，将上述两个apk文件安装到电视上。</p><p>最后，在Shadowsocks上设置好服务器地址，打开SmartYouTubeTV，选择第一个，然后可以选择登陆Google账号，登陆的时候，会让用户在手机上访问 youtube.com/activate 来登陆激活，登陆好了后，电视即可和电脑浏览器的YouTube同步了。</p><p>Smart YouTube TV里登陆Google账号后，你会发现，YouTube里的订阅、上传、历史什么的功能全部可以正常使用了，完美支持小米遥控器控制，观看视频体验极佳，完全不亚于官方的应用。</p><p>当然，用户也可以选择安装官方的YouTube应用，但必须安装Google框架等一堆东西，使用体验可能还未必好。</p><p>文章链接 <a href="http://www.codewoody.com/posts/5827/">http://www.codewoody.com/posts/5827/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;![youtube]&lt;a href=&quot;https://imgs.codewoody.com/uploads/big/3a0199722bba55dfde8d97ff1aac0f5b.jpg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://imgs.codewoody.com/uploads/big/3a0199722bba55dfde8d97ff1aac0f5b.jpg&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="翻墙" scheme="http://www.codewoody.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>如何在普通网络环境下上北邮人</title>
    <link href="http://www.codewoody.com/posts/54288/"/>
    <id>http://www.codewoody.com/posts/54288/</id>
    <published>2019-02-25T05:26:40.000Z</published>
    <updated>2019-02-25T06:42:10.179Z</updated>
    
    <content type="html"><![CDATA[<p>在学校里看剧、电影，下载破解游戏基本都靠<a href="bt.byr.cn">北邮人</a>。一方面资源比较全，另一方面是走IPv6，不需要走计费的校园网IPv4流量。不过由于北邮人只支持IPv6，而国内IPv6基本只有校园网有。问题来了，怎么在校外的纯IPv4环境下使用IPv6 Only的北邮人呢？<br><img src="https://imgs.codewoody.com/uploads/big/1b99a38129580435479cfa72b086b3b5.jpg" alt="IPv6"><br><a id="more"></a></p><h2 id="从IPv4到IPv6"><a href="#从IPv4到IPv6" class="headerlink" title="从IPv4到IPv6"></a>从IPv4到IPv6</h2><p>这是最重要的一步。你首先需要一个支持IPv6的VPS。国内目前支持IPv6的好像只有阿里云？，即便支持，国内的IPv6 VPS又贵又难用（需要申请）。因此最好的方案是采用海外的VPS。听起来用海外的VPS会很慢？其实海外的VPS主要是延时高，其实速度还是挺快的，而且P2P传输业务受到延时的影响挺小的，实测利用我的VPS可以达到5MB/s的P2P下载速度（在服务器上看上下行都是5MB/s，基本跑满了100M的带宽）。我用的VPS是<a href="www.digitalocean.com">Digital Ocean</a>的旧金山节点。价格是$5一个月。平均下来每天一块钱吧。注意创建Droplet的时候要自己勾选IPv6（添加IPv6是免费的）。</p><p><img src="https://imgs.codewoody.com/uploads/big/c052a17e4f29aea937edaec279b366e9.png" alt="选择IPv6"></p><p>在服务器上我部署了Shadowsocks服务。SS服务器可以直接无痛支持IPv4到IPv6的转换。关于如何部署Shadowsocks，这方面的教程文章网上汗牛充栋，我这里就不提供了。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>首先需要将北邮人的网址bt.byr.cn添加到Shadowsocks客户端的代理列表。</p><p><img src="https://imgs.codewoody.com/uploads/big/e9cf5e6db36fbdccf7fc9c4f330ce8b0.png" alt="Shadowsocks选项"></p><p>点击Shadowsocks小飞机，选择“编辑PAC用户自定规则”。在弹出的框中输入<code>||bt.byr.cn</code>：</p><p><img src="https://imgs.codewoody.com/uploads/big/b2e5cef758cd665368a3ecb56e139a32.png" alt="编辑PAC用户自定规则"></p><p>然后你就能在IPv4网络环境下打开北邮人的网页啦。</p><p>接下来是设置下载客户端uTorrent的网络设置。打开uTorrent的设置(Preferences)，进入到Network。进行如下设置：</p><p><img src="https://imgs.codewoody.com/uploads/big/6281a4baa6ef2e535ce877dbf455ac6a.png" alt="uTorrent设置"></p><blockquote><p>注意：上面的Socks5设置中，端口会与你的Shadowsocks设置有关。如果你没有动过相关设置的话，应该就是1086端口。<br>查看你的Shadowsocks客户端Sock5代理端口设置的方式是单击Shadowsocks小飞机，选择偏好设置，在弹出的窗口中点击“高级”，其中“本地Socks5监听端口”即为应该填写到uTorrent设置中的代理端口。</p></blockquote><p>大功告成！_(:з」∠)_</p><p>文章链接 <a href="http://www.codewoody.com/posts/54288/">http://www.codewoody.com/posts/54288/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学校里看剧、电影，下载破解游戏基本都靠&lt;a href=&quot;bt.byr.cn&quot;&gt;北邮人&lt;/a&gt;。一方面资源比较全，另一方面是走IPv6，不需要走计费的校园网IPv4流量。不过由于北邮人只支持IPv6，而国内IPv6基本只有校园网有。问题来了，怎么在校外的纯IPv4环境下使用IPv6 Only的北邮人呢？&lt;br&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/1b99a38129580435479cfa72b086b3b5.jpg&quot; alt=&quot;IPv6&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SimpleOpenNI在Processing导出应用中的库引用问题</title>
    <link href="http://www.codewoody.com/posts/65501/"/>
    <id>http://www.codewoody.com/posts/65501/</id>
    <published>2019-02-22T08:15:14.000Z</published>
    <updated>2019-02-25T05:27:39.116Z</updated>
    
    <content type="html"><![CDATA[<p>在Processing中使用SimpleOpenNI时，如果尝试将本来能够正常运行的pde文件导出成应用，那么在运行时会出现<code>java.lang.UnsatisfiedLinkError</code>这个错误。详细信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Can&apos;t load SimpleOpenNI library (libSimpleOpenNI.jnilib) : java.lang.UnsatisfiedLinkError: Can&apos;t load library: /SimpleOpenNI/library/libSimpleOpenNI.jnilib</span><br><span class="line">Verify if you installed SimpleOpenNI correctly.</span><br><span class="line">http://code.google.com/p/simple-openni/wiki/Installation</span><br><span class="line"></span><br><span class="line">java.lang.UnsatisfiedLinkError: SimpleOpenNI.SimpleOpenNIJNI.swig_module_init()V</span><br><span class="line">at SimpleOpenNI.SimpleOpenNIJNI.swig_module_init(Native Method)</span><br><span class="line">at SimpleOpenNI.SimpleOpenNIJNI.&lt;clinit&gt;(SimpleOpenNIJNI.java:290)</span><br><span class="line">at SimpleOpenNI.ContextWrapper.&lt;init&gt;(ContextWrapper.java:54)</span><br><span class="line">at SimpleOpenNI.SimpleOpenNI.&lt;init&gt;(SimpleOpenNI.java:253)</span><br><span class="line">at Sketch.settings(Sketch.java:28)</span><br><span class="line">at processing.core.PApplet.handleSettings(PApplet.java:954)</span><br><span class="line">at processing.core.PApplet.runSketch(PApplet.java:10786)</span><br><span class="line">at processing.core.PApplet.main(PApplet.java:10511)</span><br><span class="line">at Main.main(Main.java:7)</span><br></pre></td></tr></table></figure><p>根据错误信息，是在读取<code>libSimpleOpenNI.jnilib</code>这个库文件时失败导致的。奇怪的是，程序尝试读取的路径是：<code>/SimpleOpenNI/library/libSimpleOpenNI.jnilib</code>。这是一个很奇怪的绝对路径。也<a href="https://forum.processing.org/two/discussion/1253/has-anyone-successfully-exported-a-processing-app-using-simple-openni-on-mac-os-x" target="_blank" rel="noopener">有人</a>尝试直接将库文件复制到这个全局路径的位置，可以让程序运行起来。可是这种方法也太不优雅了。</p><h2 id="为什么会出现这种现象？"><a href="#为什么会出现这种现象？" class="headerlink" title="为什么会出现这种现象？"></a>为什么会出现这种现象？</h2><p>通过IntelliJ可以打开<code>SimpleOpenNI.jar</code>查看代码细节。可以看到<code>SimpleOpenNI.class</code>中确定载入库文件路径的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        String var0 = System.getProperty(<span class="string">"os.name"</span>).toLowerCase();</span><br><span class="line">        String var1 = <span class="string">"SimpleOpenNI"</span>;</span><br><span class="line">        String var2 = System.getProperty(<span class="string">"os.arch"</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (var0.indexOf(<span class="string">"win"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0.indexOf(<span class="string">"nix"</span>) &lt; <span class="number">0</span> &amp;&amp; var0.indexOf(<span class="string">"linux"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var0.indexOf(<span class="string">"mac"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                var1 = <span class="string">"lib"</span> + var1 + <span class="string">".jnilib"</span>;</span><br><span class="line">                nativLibPath = getLibraryPathLinux() + <span class="string">"/SimpleOpenNI/library/"</span>;</span><br><span class="line">                nativDepLibPath = nativLibPath + <span class="string">"osx/"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nativLibPath = <span class="string">"/SimpleOpenNI/library/linux"</span>;</span><br><span class="line">            <span class="keyword">if</span> (var2.indexOf(<span class="string">"86"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                var1 = var1 + <span class="string">"32"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2.indexOf(<span class="string">"64"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                var1 = <span class="string">"lib"</span> + var1 + <span class="string">"64.so"</span>;</span><br><span class="line">                nativLibPath = getLibraryPathLinux() + <span class="string">"/SimpleOpenNI/library/"</span>;</span><br><span class="line">                nativDepLibPath = nativLibPath + <span class="string">"linux64/"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.load(nativLibPath + var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsatisfiedLinkError var5) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Can't load SimpleOpenNI library ("</span> + var1 + <span class="string">") : "</span> + var5);</span><br><span class="line">            System.out.println(<span class="string">"Verify if you installed SimpleOpenNI correctly.\nhttp://code.google.com/p/simple-openni/wiki/Installation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _initFlag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意到在生成库文件路径时，<code>/SimpleOpenNI/library/libSimpleOpenNI.jnilib</code>，前面应该会添加<code>getLibraryPathLinux()</code>的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLibraryPathLinux</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        URL var0 = SimpleOpenNI.class.getResource(<span class="string">"SimpleOpenNI.class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String var1 = var0.toString().replace(<span class="string">"%20"</span>, <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> var2 = var1.indexOf(<span class="number">47</span>);</span><br><span class="line">            <span class="keyword">boolean</span> var3 = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> var4 = var1.indexOf(<span class="string">"/SimpleOpenNI/library"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> &lt; var2 &amp;&amp; -<span class="number">1</span> &lt; var4 ? var1.substring(var2, var4) : <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我尝试了在不同环境下,<code>SimpleOpenNI.class.getResource(&quot;SimpleOpenNI.class&quot;)</code>下运行的结果。发现：</p><ol><li>在pde运行时，获取到的是独立的<code>SimpleOpenNI.jar</code>下的路径，例如：<code>/Users/lena/Documents/Processing/libraries/SimpleOpenNI/library/SimpleOpenNI.jar!/SimpleOpenNI/SimpleOpenNI.class</code></li><li>在导出应用中运行时，获取到的是打包后应用内的，例如<code>.../MySketch/application.macosx/MySketch.app/Contents/Java/SimpleOpenNI.jar!/SimpleOpenNI/SimpleOpenNI.class</code></li></ol><p>在函数<code>getLibraryPathLinux</code>中，程序会定位<code>/SimpleOpenNI/library</code>这个字符串，然后取出这个子字符串前的内容构成的路径。上述第二种情形内，SimpleOpenNI.jar被打包到应用内后，不在处于<code>/SimpleOpenNI/library</code>这个前缀目录下，所以导致定位失败。</p><h2 id="如何解决这个问题。"><a href="#如何解决这个问题。" class="headerlink" title="如何解决这个问题。"></a>如何解决这个问题。</h2><p>在无法直接修改SimpleOpenNI的源代码的情况下，要修复这个问题，就要想办法把<code>SimpleOpenNI.jar</code>放到<code>SimpleOpenNI/library</code>目录下。我使用的macOS系统，下面的方法都是在Mac下测试。不过基本思路可以迁移到Windows上。</p><p>在生成的App上右键选择显示包内容。可以查看其内部结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Info.plist</span><br><span class="line">├── Java</span><br><span class="line">│   ├── Sketch.jar</span><br><span class="line">│   ├── NiTE2</span><br><span class="line">│   ├── SimpleOpenNI.jar</span><br><span class="line">│   ├── SimpleOpenNI32.dll</span><br><span class="line">│   ├── SimpleOpenNI64.dll</span><br><span class="line">│   ├── core.jar</span><br><span class="line">│   ├── data</span><br><span class="line">│   ├── gluegen-rt-natives-macosx-universal.jar</span><br><span class="line">│   ├── gluegen-rt.jar</span><br><span class="line">│   ├── javamp3-1.0.3.jar</span><br><span class="line">│   ├── jogl-all-natives-macosx-universal.jar</span><br><span class="line">│   ├── jogl-all.jar</span><br><span class="line">│   ├── jsyn-20171016.jar</span><br><span class="line">│   ├── libSimpleOpenNI.jnilib</span><br><span class="line">│   ├── libSimpleOpenNI64.so</span><br><span class="line">│   ├── osx</span><br><span class="line">│   ├── sound.jar</span><br><span class="line">│   ├── win32</span><br><span class="line">│   └── win64</span><br><span class="line">├── MacOS</span><br><span class="line">│   └── Sketch</span><br><span class="line">├── PkgInfo</span><br><span class="line">├── PlugIns</span><br><span class="line">│   └── jdk1.8.0_181.jdk</span><br><span class="line">└── Resources</span><br><span class="line">    ├── en.lproj</span><br><span class="line">    └── sketch.icns</span><br></pre></td></tr></table></figure><p>可以看到<code>SimpleOpenNI.jar</code>位于<code>Java</code>目录下。我尝试过直接在此处创建目录<code>SimpleOpenNI/library</code>并把<code>SimpleOpenNI.jar</code>放进去。但是运行提示无法找到<code>SimpleOpenNI.jar</code>。这需要在APP运行时进一步指定<code>CLASSPATH</code>。有一种方法是直接在Info.plist文件里面添加<code>-Djava.class.path</code>运行属性，或者添加<code>ClASSPATH</code>环境变量，但是这种方法会要求你手动填写所有需要使用的jar依赖，甚至是包括processing的jar文件。这对于后续维护和修改很不利。所以这里我采取了另一种取巧的办法。</p><p>进入<code>Contents/MacOS</code>目录，删除原来的<code>Sketch</code>文件(你看到的应该是和你的Processing程序同名的文件，我这里用Sketch来代替)。新建一个同名的空白的文本文件，然后在文件中添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(dirname $&#123;BASH_SOURCE&#125;)</span>"</span></span><br><span class="line"><span class="built_in">cd</span> ../..</span><br><span class="line">APP_ROOT=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">cd</span> Contents/Java</span><br><span class="line"></span><br><span class="line">JAR_LIBS=$(ls *.jar | tr <span class="string">"\n"</span> <span class="string">":"</span>)</span><br><span class="line"><span class="comment"># 添加SimpleOpenNI.jar</span></span><br><span class="line">JAR_LIBS=<span class="variable">$&#123;JAR_LIBS&#125;</span>./SimpleOpenNI/library/SimpleOpenNI.jar</span><br><span class="line"></span><br><span class="line">APP_NAME=$(basename <span class="string">"<span class="variable">$&#123;BASH_SOURCE&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：如果你内嵌的jdk的版本不同，要把jdk1.8.0_181.jdk替换成对应的版本</span></span><br><span class="line"><span class="comment"># 如果你没有在app内部内嵌jdk，这里修改成JAVA_BIN=java，使用系统全局的java即可</span></span><br><span class="line">JAVA_BIN=<span class="variable">$&#123;APP_ROOT&#125;</span>/Contents/PlugIns/jdk1.8.0_181.jdk/Contents/Home/jre/bin/java</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;JAVA_BIN&#125;</span> \</span><br><span class="line">-Djna.nosys=<span class="literal">true</span> \</span><br><span class="line">-Djava.ext.dirs=<span class="variable">$APP_ROOT</span>/Contents/PlugIns/jdk1.8.0_181.jdk/Contents/Home/jre/lib/ext \</span><br><span class="line">-Xdock:icon=<span class="variable">$APP_ROOT</span>/Contents/Resources/sketch.icns \</span><br><span class="line">-Djava.library.path=<span class="variable">$APP_ROOT</span>/Contents/Java \</span><br><span class="line">-Dapple.laf.useScreenMenuBar=<span class="literal">true</span> \</span><br><span class="line">-Dcom.apple.macos.use-file-dialog-packages=<span class="literal">true</span> \</span><br><span class="line">-Dcom.apple.macos.useScreenMenuBar=<span class="literal">true</span> \</span><br><span class="line">-Dcom.apple.mrj.application.apple.menu.about.name=<span class="variable">$&#123;APP_NAME&#125;</span> \</span><br><span class="line">-classpath <span class="variable">$&#123;JAR_LIBS&#125;</span> <span class="variable">$&#123;APP_NAME&#125;</span></span><br></pre></td></tr></table></figure><p>为这个文件添加可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./Sketch</span><br></pre></td></tr></table></figure><p>将<code>~/Documents/Processing/libraries/SimpleOpenNI</code>整个文件夹拷贝进导出APP的<code>Contents/Java目录下</code>。然后就可以运行了。</p><p>文章链接 <a href="http://www.codewoody.com/posts/65501/">http://www.codewoody.com/posts/65501/</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Processing中使用SimpleOpenNI时，如果尝试将本来能够正常运行的pde文件导出成应用，那么在运行时会出现&lt;code&gt;java.lang.UnsatisfiedLinkError&lt;/code&gt;这个错误。详细信息如下：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="processing" scheme="http://www.codewoody.com/categories/processing/"/>
    
    
      <category term="processing" scheme="http://www.codewoody.com/tags/processing/"/>
    
      <category term="debug" scheme="http://www.codewoody.com/tags/debug/"/>
    
      <category term="java" scheme="http://www.codewoody.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks中继:从IPv4到IPv6</title>
    <link href="http://www.codewoody.com/posts/6289/"/>
    <id>http://www.codewoody.com/posts/6289/</id>
    <published>2019-02-21T09:00:17.000Z</published>
    <updated>2019-02-21T09:33:01.634Z</updated>
    
    <content type="html"><![CDATA[<p>最近墙又双叒叕加高了。在春节前就发现自己的VPS无法连接，后来发现还好只是端口被封禁，换成其他的端口就能使用了。不过这才撑了半个月新的端口访问又不太稳定了。如果再换端口，或许也可以。但是不是长久之计。不过我的VPS是支持IPv6的，一般来说，墙对于IPv6流量的拦截比较弱。或许可以想办法先把自己的流量转换成IPv6然后再出去。<br><img src="https://imgs.codewoody.com/uploads/big/7a59f2881bd41ba1fabc7e1cbce460a4.png" alt="Hello GFW, Goodbye GFW"><br><a id="more"></a></p><blockquote><p>我也设想过要不要给代理添加混淆的功能，处于以下几方面的考虑，还是选择了流量转换的方案：</p><ol><li>手机端部分ss应用不支持混淆；</li><li>未来混淆还是可能被针对性的拦截。但是IPv6则不会。GFW拦截还是拦截大鱼不拦截小鱼的。国内目前IPv6的使用范围仍然非常小，而且基本只限于教育网。因此IPv6在未来的很长一段时间内不会成为GFW的针对目标</li></ol></blockquote><p>我们这里使用HAProxiy来完成这一功能。</p><h2 id="安装HAProxy"><a href="#安装HAProxy" class="headerlink" title="安装HAProxy"></a>安装HAProxy</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.haproxy.org/download/1.7/src/haproxy-1.7.2.tar.gz</span><br><span class="line">tar -xzf haproxy-1.7.2.tar.gz</span><br><span class="line">make TARGET=linux2826 USE_GETADDRINFO=1</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>注意，在倒数第二行的make命令中，TARGET需要根据你的内核版本来选择。<code>USE_GETADDRINFO</code>的作用是使得HAProxy可以对域名采用DNS查询来获取IP。使用包管理器安装的HAProxy是不带这个功能的。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">        ulimit-n  51200</span><br><span class="line">        daemon  # run as daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">        log    global</span><br><span class="line">        mode    tcp</span><br><span class="line">        option    dontlognull</span><br><span class="line">        timeout connect 1000</span><br><span class="line">        timeout client 150000</span><br><span class="line">        timeout server 150000</span><br><span class="line"></span><br><span class="line">frontend ss-in</span><br><span class="line">        bind *:port # 跳板机监听端口</span><br><span class="line">        default_backend ss-out</span><br><span class="line"></span><br><span class="line">backend ss-out</span><br><span class="line">        server server1 vps_host:vps_ss_port maxconn 20480</span><br></pre></td></tr></table></figure><p>设置文件位于<code>/etc/haproxy/haproxy.cfg</code>。在完成设置后，使用<code>sudo haproxy -f /etc/haproxy/haproxy.cfg</code>来运行。</p><p>文章链接 <a href="http://www.codewoody.com/posts/6289/">http://www.codewoody.com/posts/6289/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近墙又双叒叕加高了。在春节前就发现自己的VPS无法连接，后来发现还好只是端口被封禁，换成其他的端口就能使用了。不过这才撑了半个月新的端口访问又不太稳定了。如果再换端口，或许也可以。但是不是长久之计。不过我的VPS是支持IPv6的，一般来说，墙对于IPv6流量的拦截比较弱。或许可以想办法先把自己的流量转换成IPv6然后再出去。&lt;br&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/7a59f2881bd41ba1fabc7e1cbce460a4.png&quot; alt=&quot;Hello GFW, Goodbye GFW&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Shadowsocks" scheme="http://www.codewoody.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>【转载】无人机击落客机只是时间问题</title>
    <link href="http://www.codewoody.com/posts/48586/"/>
    <id>http://www.codewoody.com/posts/48586/</id>
    <published>2019-02-17T09:29:29.000Z</published>
    <updated>2019-02-17T09:33:48.189Z</updated>
    
    <content type="html"><![CDATA[<p>我是一个无人机集群技术的研究者，从最近开始我打算集中整理发布一些无人机，尤其是无人机集群技术的新进展以及评论文章。<a id="more"></a></p><p>原文链接：<a href="https://www.technologyreview.com/s/612656/its-only-a-matter-of-time-before-a-drone-takes-down-a-passenger-plane/" target="_blank" rel="noopener">It’s only a matter of time before a drone takes down a passenger plane</a></p><p><img src="https://imgs.codewoody.com/uploads/big/0166e9fa673aa5ee62aa118a58836f7f.jpg" alt="Cover"></p><p>2018年12月，英国第二大机场盖特威克机场，发现有一架无人机飞过机场，不得不关闭一天，几十万旅客受到影响。目前还不知道这架无人机是谁操作，为什么要飞入机场。</p><p>这个事件表明，无人机对商业航空已经构成威胁。更严重的是，”反无人机”技术起不了多大作用。无人机已经变得太便宜，太强大，客机将不可避免地受到影响。无论是开枪、无线电干扰、或者其他措施，都无法可靠地保护客机。这可能听起来危言耸听，但我们对无人机真的缺乏办法。</p><p>现在，消费者可以买到的最便宜无人机，只需要25美元。这些产品接受遥控器的无线信号，相对容易防范，只要干扰它们的无线电信号，就可以了。稍微昂贵的无人机有 GPS 芯片，这种无人机可以编程设置一个”地理围栏”，防止它们飞入指定的地理坐标范围内。</p><p>但是，上面的这些措施，只能防住普通消费者从正规渠道买到的无人机。对于具有中等技术水平的人来说，制造一架无人机很容易，自制无人机也不需要 GPS 芯片。它们也不一定需要与操作员通信，才能保持飞行，这使得无线电干扰无效。而且，强度太大的干扰信号，反而可能会影响到本来要保护的客机。</p><p>可以肯定的是，一架无人机攻击一架客机，成功机会不大。这是因为在起飞和着陆时（最容易遭遇无人机的阶段），客机的移动速度非常快，通常在每小时150到200英里之间，很少有无人机能够以50~70英里/小时的速度飞行，所以客机应该可以避开无人机。此外，飞机的设计可以承受鸟撞，如果一架无人机意外撞到客机，客机可能只会受到轻微损坏，很可能还是能够安全降落。</p><p>但是，如果无人机成群飞行，事情就会发生变化。虽然单个无人机很难攻击飞机，但是在客机的飞行路径上放置30架无人机，就可能会发生变化。考虑到无人机的价格，多架无人机群体攻击是很容易的。如果通过编程，找出客机的引擎（通过红外传感或通过图像），然后无人机携带少量爆炸物，撞击可能会致命。</p><p>总之，对于那些蓄意攻击客机的半自动或全自动无人机集群，根本就没有好的技术对策。</p><p>文章链接 <a href="http://www.codewoody.com/posts/48586/">http://www.codewoody.com/posts/48586/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是一个无人机集群技术的研究者，从最近开始我打算集中整理发布一些无人机，尤其是无人机集群技术的新进展以及评论文章。
    
    </summary>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/categories/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
    
      <category term="无人机" scheme="http://www.codewoody.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>Netlink:用户空间与内核空间交互</title>
    <link href="http://www.codewoody.com/posts/2348/"/>
    <id>http://www.codewoody.com/posts/2348/</id>
    <published>2019-01-22T08:29:18.000Z</published>
    <updated>2019-01-22T08:59:24.910Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/20975566/what-is-the-best-way-to-communicate-a-kernel-module-with-a-user-space-program" target="_blank" rel="noopener">Reference</a></p><h1 id="1-什么是Netlink"><a href="#1-什么是Netlink" class="headerlink" title="1 什么是Netlink"></a>1 什么是Netlink</h1><p>Netlink is a socket family that supplies a messaging facility based on the <strong>++BSD socket interface++</strong> to send and retrieve kernel-space information from user-space.  Netlink is portable, highly extensible and it supports <strong>++event-based notifications++</strong>.</p><blockquote><p>从这段描述来看Netlink可以提供类似socket接口，这意味着我们能够传输比较大量的，结构化的数据。另外，Netlink还提供了基于时间通知的功能，也适合我们时刻监控系统动态。</p></blockquote><p>Netlink是一种面向数据表(datagram-oriented)的连通用户空间和内核空间的<strong>++消息系统++</strong>。同时，Netlink也可以用于进程间通信(InterProcess Communication, IPC)。我们这里只关注前者。Netlink构筑与通用的BSD scoket基础设施之上，因此支持使用<code>socket()</code>, <code>bind()</code>, <code>sendmsg()</code>, <code>recvmsg()</code>和其他通常的socket polling操作。</p><blockquote><p>一般的BSD socket使用的是固定格式的数据结构(如AF_INET或者AF_RAW)。Netlink则提供更加可扩展的数据格式。</p></blockquote><h1 id="2-Netlink的典型应用场景"><a href="#2-Netlink的典型应用场景" class="headerlink" title="2 Netlink的典型应用场景"></a>2 Netlink的典型应用场景</h1><p>当前Netlink主要应用场景是网络相关应用，包括：</p><ul><li>advanced routing</li><li>IPsec key management tools</li><li>firewall state synchronization</li><li>uesr-space packet enqueuing</li><li>border gateway routing protocols</li><li>wireless mesh routing protocols</li></ul><blockquote><p>这个应用场景与我们的需要时契合的</p></blockquote><h1 id="3-Netlink总线"><a href="#3-Netlink总线" class="headerlink" title="3 Netlink总线"></a>3 Netlink总线</h1><p>Netlink允许最多32条内核空间总线。一般来说每个总线都关联到一个内核子系统中（多个子系统也可以共享一个总线）。总线共享的例子包括：</p><ol><li><code>nfnetlink</code>：所有防火墙相关子系统共享</li><li><code>rtnetlink</code>：网络设备管理，路由和队列管理</li></ol><blockquote><p>关于Netlink总线，我发现了一个内核的<a href="https://lwn.net/Articles/746776/" target="_blank" rel="noopener">patch</a>，其中提到，”This patchset aims to improve this situation by add ing a new NETLINK_DESC bus with two commands…”</p></blockquote><h1 id="4-Netlink通信类型"><a href="#4-Netlink通信类型" class="headerlink" title="4 Netlink通信类型"></a>4 Netlink通信类型</h1><p>Netlink支持两种通信类型：</p><ol><li>Unicast：一对一通信，即一个内核子系统对应一个用户空间程序。这种通信模式一般用来发送命令，或者获取命令执行的结果。</li><li>Multicast：一对多通信。通常的场景是一个内核态模块向多个用户态监听者发送消息。这种监听者被划分为多个不同的组。一条Netlink总线可以提供多个组，用户空间可以订阅到一个或者多个组来获取对应的信息。最多可以创建<div id="nv60rt" data-type="math" data-display="inline" data-align="left" data-src="https://cdn.nlark.com/__latex/f19901f1c817ad846a411e6712e8db66.svg" data-text="2%5E%7B32%7D" data-width="22" data-height="24"><img src="https://cdn.nlark.com/__latex/f19901f1c817ad846a411e6712e8db66.svg" width="22"></div>个组。</li></ol><p><img src="https://imgs.codewoody.com/uploads/big/fd04efbb980d5c7939ee72218283967a.png" alt="Example scenario of unicast and multicast Netlink sockets"></p><p>上图给出了Unicast和Multicast的图示。注意这里unicast是同步的，multicast是异步的。</p><h1 id="5-Netlink消息格式"><a href="#5-Netlink消息格式" class="headerlink" title="5 Netlink消息格式"></a>5 Netlink消息格式</h1><p>一般来说，Netlink消息对齐到32bit，其内部数据是<a href="https://www.quora.com/What-are-network-byte-order-and-host-byte-order-in-computer-networking" target="_blank" rel="noopener">host-byte order</a>. 一个Netlink消息总由一段16bytes的header组成，header的格式为<code>struct nlmsghdr</code>（定义在<code>&lt;include/linux/netlink.h&gt;</code>中）</p><p><img src="https://imgs.codewoody.com/uploads/big/a852f3eedef7daa85d67253ce736fc4d.png" alt="Layout of a Netlink message header"></p><p>header包含如下字段：</p><ul><li>消息长度（32bits,  包含header的长度）</li><li>消息类型（16bits）。消息类型的划分有两大类别：数据消息和控制消息。其中数据消息的类型取决于内核模块所允许的取值。控制消息类型则对所有Netlink子系统是一致的。控制消息的类型目前一共有四种。<ul><li><code>NLMSG_NOOP</code>: 不对对应任何实质操作，只用来检测Netlink总线是否可用</li><li><code>NLMSG_ERROR</code>：该消息包含了错误信息</li><li><code>NLMSG_DONE</code>：this is the trailing message that is part of a multi-part message. A  multi-part message is composed of a set of messages all with the <code>NLM_F_MULTI</code> flag set.</li><li><code>NLMSG_OVERRUN</code>：没有使用</li></ul></li><li>消息标识(16bits)。一些例子如下：<ul><li><code>NLM_F_REQUEST</code>: 如果这个标识被设置了，表明这个消息代表了一个请求。从用户空间发往内核空间的请求必须要设置这个标识，否则内核子系统必须要回复一个<code>invalid argument(EINVAL)</code>的错误信息。</li><li><code>NLM_F_CREATE</code>: 用户空间想要发布一个命令，或者创建一个新的配置。</li><li><code>NLM_F_EXCL</code>: 通常和NLM_F_CREATE一起使用，用来出发配置已经存在的错误信息。</li><li><code>NLM_F_REPLACE</code>: 用户空间想要替换现有配置。</li><li><code>NLM_F_APPEND</code>: 想现有配置添加配置。这种操作一般针对的是有序的数据，如路由表。</li><li><code>NLM_F_DUMP</code>: 用户应用想要和内核应用进行全面重新同步。这中消息的结果是一系列的multipart message。</li><li><code>NLM_F_MULTI</code>: this is a multi-part message. A Netlink subsystem replies with a multi-part message if it has previously received a request from user-space with the NLM F DUMP flag set.</li><li><code>NLM_F_ACK</code>: 设置了这个标识后，内核会返回一个确认信息表明一个请求已经执行。如果这个flag没有返回，那么错误信息会作为sendmsg()函数的返回值同步返回。</li><li><code>NLM_F_ECHO</code>:  if this flag is set, the user-space application wants to get a report back via unicast of the request that it has send. 注意通过这种方式获取信息后，这个程序不会再通过事件通知系统获取同样的信息。</li></ul></li><li>Sequence Number (32bits):  The sequence number is used as a tracking cookie since the kernel does not change the sequence number value at all<ul><li>可以和NLM_F_ACK一起使用，用户空间用来确认一个请求被正确地发出了。</li><li>Netlink uses the same sequence number in the messages that are sent as reply to a given request</li><li>For event-based notifications from kernel-space, this is always zero.</li></ul></li><li>Port-ID (32bits): 包含了Netlink分配的一个数字ID。Netlink使用不同的port ID来确定同一个用户态进程打开的不同socket通道。第一个socket的默认port ID是这个进程的PID(Process ID)。在下面这些场景下，port ID为0：<ul><li>消息来自内核空间</li><li>消息发送自用户空间，我们希望Netlink能够自动根据socket通道的port ID自动设置消息的port ID</li></ul></li></ul><p>以上是通用Netlink header格式。一些内核子系统会进一步定义自己的header格式，这样不同的子系统可以共享同一个Netlink socket总线。这种情形成为GetNetlink。</p><h1 id="6-Netlink负载"><a href="#6-Netlink负载" class="headerlink" title="6 Netlink负载"></a>6 Netlink负载</h1><h2 id="6-1-Type-Length-Value-TLV-格式"><a href="#6-1-Type-Length-Value-TLV-格式" class="headerlink" title="6.1 Type-Length-Value(TLV)格式"></a>6.1 Type-Length-Value(TLV)格式</h2><p><img src="https://imgs.codewoody.com/uploads/big/a852f3eedef7daa85d67253ce736fc4d.png" alt="An example of a hypothetical Netlink payload in TLV format"></p><p>Netlink的消息格式由TLV格式的属性组成。TLV属性分为Length,  Type和Payload三部分。这种格式具有很强的可扩展性。在内核中，TLV属性的header定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &lt;------- NLA_HDRLEN ------&gt; &lt;-- NLA_ALIGN(payload)--&gt;</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> * |        Header       | Pad |     Payload       | Pad |</span></span><br><span class="line"><span class="comment"> * |   (struct nlattr)   | ing |                   | ing |</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> *  &lt;-------------- nlattr-&gt;nla_len --------------&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">    __u16           nla_len;</span><br><span class="line">    __u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>nla_type</code>：属性的取值很大程度上取决于内核空间子系统定义。不过Netlink预先定了两个重要的比特位：<ul><li>NLA_F_NETSTED: 是否是嵌套属性。即在payload部分，以TLV的格式存储了更多的属性。</li><li>NLA_F_NET_BYTEORDER: payload内容的字节顺序（是否是network byte order(1))</li></ul></li><li><code>nla_len</code>: 注意，尽管payload部分会按照32bit进行对齐，这里的长度内容是不包含对齐补全的bit的。另外，这里的长度值包含了header。</li></ul><h1 id="7-Netlink错误消息"><a href="#7-Netlink错误消息" class="headerlink" title="7 Netlink错误消息"></a>7 Netlink错误消息</h1><p><img src="https://imgs.codewoody.com/uploads/big/a852f3eedef7daa85d67253ce736fc4d.png" alt="Layout of a Netlink error message"></p><p>Netlink提供了一种包含了Netlink error header的消息类型，其格式如上图所示。这个header定义为<code>struct nlmsgerr</code> (<code>&lt;include/linux/netlink.h&gt;</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsgerr</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>error;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * followed by the message contents unless NETLINK_CAP_ACK was set</span></span><br><span class="line"><span class="comment"> * or the ACK indicates success (error == 0)</span></span><br><span class="line"><span class="comment"> * message length is aligned with NLMSG_ALIGN()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * followed by TLVs defined in enum nlmsgerr_attrs</span></span><br><span class="line"><span class="comment"> * if NETLINK_EXT_ACK was set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>error</code>: 错误类型。定义在<code>error.h</code>中，可以用<code>perror()</code>解析。</li><li>Netlink消息，为触发此错误的消息内容。<blockquote><p>With regards to message integrity, the kernel subsystems that support Netlink usually report invalid argument (EINVAL) via recvmsg() if user-space sends a malformed message</p></blockquote></li></ul><h1 id="8-GeNetlink"><a href="#8-GeNetlink" class="headerlink" title="8 GeNetlink"></a>8 GeNetlink</h1><p>前文我们提到过GetNetlink了。这一技术是为了缓解Netlink总线数量过少的问题。GeNetlink allows to register up to 65520 families that share a single Netlink bus. Each family is intended to be equivalent to a virtual bus。其中，每个family通过一个唯一的string name and ID number来注册。其中string name作为主键，而ID number在不同的系统中可能不同。</p><h1 id="9-Netlink开发"><a href="#9-Netlink开发" class="headerlink" title="9 Netlink开发"></a>9 Netlink开发</h1><p>Netlink开发涉及到内核空间和用户空间双边的开发。Linux提供了很多帮助函数来见过Netlink开发中重复性的解析，验证，消息构建的操作。</p><h2 id="9-1-用户空间开发"><a href="#9-1-用户空间开发" class="headerlink" title="9.1 用户空间开发"></a>9.1 用户空间开发</h2><p>从用户空间这一侧来看，Netlink sockets实现在通用的BSD socket接口之上。因此，在用户空间开发Netlink和开发TCP/IP socket应用是很类似的。不过，同其他典型的BSD socket应用相比，Netlink存在以下的不同之处：</p><ol><li>Netlink sockets do not hide protocol details to user-space as other protocols to. 即，Netlink会直接处理原始数据本身，用户空间的开发也要直接处理原始数据格式的负载。</li><li>Errors that  comes from Netlink and kernel subsystems are not returned by recvmsg() as an integer. Instead, errors are encapsulated in the Netlink error message. 唯一的例外是No buffer space error (<code>ENOBUFS</code>)，这个错误是表明无法将Netlink消息放入队列。标准的通用socket错误，同样也是从<code>recvmsg()</code>中以integer形式返回。</li></ol><blockquote><p>涉及用户空间的Netlink开发的有两个库：<a href="https://www.infradead.org/~tgr/libnl/" target="_blank" rel="noopener">libnl</a>和<a href="https://netfilter.org/projects/libmnl/" target="_blank" rel="noopener">libmnl</a>。这些库都是用C开发，用来简化Netlink开发。Netlink用户空间的进一步开发可以参考这两个库的例子和教程。</p><p>原始API的文档：<a href="https://www.systutorials.com/docs/linux/man/7-netlink/" target="_blank" rel="noopener">https://www.systutorials.com/docs/linux/man/7-netlink/</a></p></blockquote><h3 id="9-1-1-打开socket"><a href="#9-1-1-打开socket" class="headerlink" title="9.1.1 打开socket"></a>9.1.1 打开socket</h3><p>下面来阐述一下用户空间的Netlink开发的重要事项。前面提到Netlink使用了BSD socket的接口。一般而言，创建socket的接口长这样子（<a href="http://web.mit.edu/macdev/Development/MITSupportLib/SocketsLib/Documentation/sockets.html" target="_blank" rel="noopener">socket接口</a>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数<code>family</code>是socket的大类。在开发TCP/IP应用的时候，这里总是<code>AF_INET</code>。而在Netlink中，这里总是设置为<code>AF_NETLINK</code>。</li><li><code>type</code>可以选择<code>SOCK_RAW</code>或者<code>SOCK_DGRAM</code>。不过Netlink并不会区分这两者。</li><li>protocol为Netlink场景下定义的具体协议类型，现有的主要协议包括：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ROUTE0<span class="comment">/* Routing/device hook*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_UNUSED1<span class="comment">/* Unused number*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_USERSOCK2<span class="comment">/* Reserved for user mode socket protocols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_FIREWALL3<span class="comment">/* Unused number, formerly ip_queue*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_SOCK_DIAG4<span class="comment">/* socket monitoring*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_NFLOG5<span class="comment">/* netfilter/iptables ULOG */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_XFRM6<span class="comment">/* ipsec */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_SELINUX7<span class="comment">/* SELinux event notifications */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ISCSI8<span class="comment">/* Open-iSCSI */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_AUDIT9<span class="comment">/* auditing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_FIB_LOOKUP10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_CONNECTOR11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_NETFILTER12<span class="comment">/* netfilter subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_IP6_FW13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_DNRTMSG14<span class="comment">/* DECnet routing messages */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_KOBJECT_UEVENT15<span class="comment">/* Kernel messages to userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_GENERIC16</span></span><br><span class="line"><span class="comment">/* leave room for NETLINK_DM (DM Events) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_SCSITRANSPORT18<span class="comment">/* SCSI Transports */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ECRYPTFS19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_RDMA20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_CRYPTO21<span class="comment">/* Crypto layer */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_INET_DIAGNETLINK_SOCK_DIAG</span></span><br></pre></td></tr></table></figure><blockquote><p>我们可以直接使用NETLINK_USERSOCK供自己使用，或者自己定义一个新的量。</p></blockquote><blockquote><p>这里的protocol应当对应的是1.1.3中提到的总线。推理过程如下：</p><ol><li><a href="https://lwn.net/Articles/746776/" target="_blank" rel="noopener">https://lwn.net/Articles/746776/</a> 这个链接中提叫的patch描述中称：This patch set aims to improve this situation by adding a new NETLINK_DESC bus with two commands</li><li>在<a href="#8642ah">参考文献</a>中谈论Netlink总线时，聚到了rtnetlink这个例子。根据rtnetlink的<a href="http://man7.org/linux/man-pages/man7/rtnetlink.7.html" target="_blank" rel="noopener">man page</a>，<br><code style="background-color: rgb(255, 255,255)"><br>#include &lt;asm/types.h&gt;<br>#include &lt;linux/netlink.h&gt;<br>#include &lt;linux/rtnetlink.h&gt;<br>#include &lt;sys/socket.h&gt;<br><br><br>rtnetlink_socket = socket(AF_NETLINK, int socket_type, NETLINK_ROUTE);<br></code></li></ol></blockquote><h3 id="9-1-2-绑定socket地址"><a href="#9-1-2-绑定socket地址" class="headerlink" title="9.1.2 绑定socket地址"></a>9.1.2 绑定socket地址</h3><p>在打开了一个socket之后，我们需要为socket绑定一个本地地址。Netlink的地址格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span>    nl_family;  <span class="comment">/* AF_NETLINK   */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> nl_pad;     <span class="comment">/* zero         */</span></span><br><span class="line">  __u32          nl_pid;     <span class="comment">/* process pid */</span></span><br><span class="line">  __u32          ;  <span class="comment">/* mcast groups mask */</span></span><br><span class="line">&#125; nladdr;</span><br></pre></td></tr></table></figure><blockquote><p>这里的nl_pid可以通过getpid()这个函数来获取当前进程的pid来进行赋值</p></blockquote><p>如果要在一个进程的多个线程中打开多个socket，可以用如下公式生成<code>nl_pid</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_self() &lt;&lt; <span class="number">16</span> | getpid();</span><br></pre></td></tr></table></figure><p><code>struct socketadd_nl</code>中的<code>nl_groups</code>为bit mask，代表了广播分组。当设置为0时代表单播消息。</p><p>确定地址后可以将其绑定到socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd为socket()返回的句柄</span></span><br><span class="line">bind(fd, (struct sockaddr*)&amp;nladdr, <span class="keyword">sizeof</span>(nladdr));</span><br></pre></td></tr></table></figure><h3 id="9-1-3-发送Netlink消息"><a href="#9-1-3-发送Netlink消息" class="headerlink" title="9.1.3 发送Netlink消息"></a>9.1.3 发送Netlink消息</h3><p>为了发送Netlink消息，我们还需要创建一个<code>struct socketaddr_nl</code>作为发送的目的地址。如果消息是发送给内核的，那么<code>nl_pid</code>和<code>nl_groups</code>都要设置为0。如果这个消息是一个多播消息，那么需要设置<code>nl_groups</code>的对应比特。设置好目的地址之后，我们可以开始组装<code>sentmsg()</code>API需要的消息格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">msg.msg_name = (<span class="keyword">void</span> *)&amp;(nladdr);</span><br><span class="line">msg.msg_namelen = <span class="keyword">sizeof</span>(nladdr);</span><br></pre></td></tr></table></figure><p>上面是socket的通用header，我们还需要设置Netlink自己的Message  header这里<code>struct nlmsghdr</code>定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __u32 nlmsg_len;   <span class="comment">/* Length of message */</span></span><br><span class="line">  __u16 nlmsg_type;  <span class="comment">/* Message type*/</span></span><br><span class="line">  __u16 nlmsg_flags; <span class="comment">/* Additional flags */</span></span><br><span class="line">  __u32 nlmsg_seq;   <span class="comment">/* Sequence number */</span></span><br><span class="line">  __u32 nlmsg_pid;   <span class="comment">/* Sending process PID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在1.5中我们队各个字段的含义有了详细的介绍。按照对应的含义进行设置。<br>Netlink的消息由Netlink header和payload组成。因此我们需要一次性创建包含header和payload的内存块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> = (<span class="title">struct</span> <span class="title">nlmsghdr</span> *)<span class="title">malloc</span>(<span class="title">NLMSG_SPACE</span>(<span class="title">MAX_PAYLOAD</span>));</span> </span><br><span class="line"><span class="built_in">memset</span>(nlh, <span class="number">0</span>, NLMSG_SPACE(MAX_PAYLOAD));</span><br><span class="line">nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);</span><br><span class="line">nlh-&gt;nlmsg_pid = getpid();</span><br><span class="line">nlh-&gt;nlmsg_flags = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>此处使用的<code>NLMSG_SPACE</code>宏定义是Netlink提供的工具，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))</span></span><br></pre></td></tr></table></figure><p>这个宏做了两件事：</p><ol><li>在长度上加上header的长度</li><li>将Payload进行32bit对齐</li></ol><p>设置好负载内容后（负载数据段可以通过<span data-type="color" style="color:rgb(206, 103, 0)"><code>NLMSG_DATA</code></span><span data-type="color" style="color:rgb(197, 200, 198)"><code>(nlh)</code></span>来获取），就可以发送了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line"></span><br><span class="line">iov.iov_base = (<span class="keyword">void</span> *)nlh;</span><br><span class="line">iov.iov_len = nlh-&gt;nlmsg_len;</span><br><span class="line"></span><br><span class="line">msg.msg_iov = &amp;iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sendmsg(fd, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="9-1-3-接收Netlink消息"><a href="#9-1-3-接收Netlink消息" class="headerlink" title="9.1.3 接收Netlink消息"></a>9.1.3 接收Netlink消息</h3><p>接收过程是类似的。接收程序需要提前分配一个足够的buffer来接收Netlink消息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line"></span><br><span class="line">iov.iov_base = (<span class="keyword">void</span> *)nlh;</span><br><span class="line">iov.iov_len = MAX_NL_MSG_LEN;</span><br><span class="line">msg.msg_name = (<span class="keyword">void</span> *)&amp;(nladdr);</span><br><span class="line">msg.msg_namelen = <span class="keyword">sizeof</span>(nladdr);</span><br><span class="line"></span><br><span class="line">msg.msg_iov = &amp;iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">recvmsg(fd, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="9-2-内核空间开发"><a href="#9-2-内核空间开发" class="headerlink" title="9.2 内核空间开发"></a>9.2 内核空间开发</h2><h3 id="9-2-1-创建新的Netlink协议类型"><a href="#9-2-1-创建新的Netlink协议类型" class="headerlink" title="9.2.1 创建新的Netlink协议类型"></a>9.2.1 创建新的Netlink协议类型</h3><p>除非要复用内核既有Netlink协议类型，不然最好定义一个自己用的总线类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_TEST 31</span></span><br></pre></td></tr></table></figure><p>这个定义可以加在<code>netlink.h</code>中，或者放在模块的头文件里。</p><h3 id="9-2-2-创建socket"><a href="#9-2-2-创建socket" class="headerlink" title="9.2.2 创建socket"></a>9.2.2 创建socket</h3><p>在用户态，我们通过<code>socket()</code>接口来创建socket，而在内核中，我们使用如下的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *</span></span><br><span class="line"><span class="class"><span class="title">netlink_kernel_create</span>(<span class="title">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">int</span> <span class="title">unit</span>, <span class="title">struct</span> <span class="title">netlink_kernel_cfg</span> *<span class="title">cfg</span>);</span></span><br></pre></td></tr></table></figure><ul><li><code>net</code>一般固定为全局变量<code>init_net</code></li><li><code>unit</code>即为协议类型，我们在这里填上<code>NETLINK_TEST</code></li><li><code>cfg</code>为Netlink的内核设置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>groups;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>flags;</span><br><span class="line"><span class="keyword">void</span>(*input)(struct sk_buff *skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>*<span class="title">cb_mutex</span>;</span></span><br><span class="line"><span class="keyword">int</span>(*bind)(struct net *net, <span class="keyword">int</span> group);</span><br><span class="line"><span class="keyword">void</span>(*unbind)(struct net *net, <span class="keyword">int</span> group);</span><br><span class="line"><span class="keyword">bool</span>(*compare)(struct net *net, struct sock *sk);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>input</code>是必须要设置的，是socket在接收到一个消息后的回调函数。回调函数的一个例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_nl_recv_msg</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb_out</span>;</span></span><br><span class="line">    <span class="keyword">int</span> msg_size;</span><br><span class="line">    <span class="keyword">char</span> *msg = <span class="string">"Hello from kernel"</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">"Entering: %s\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    msg_size = <span class="built_in">strlen</span>(msg);</span><br><span class="line"></span><br><span class="line">    nlh = (struct nlmsghdr *)skb-&gt;data;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Netlink received msg payload:%s\n"</span>, (<span class="keyword">char</span> *)nlmsg_data(nlh));</span><br><span class="line">    pid = nlh-&gt;nlmsg_pid; <span class="comment">/*pid of sending process */</span></span><br><span class="line"></span><br><span class="line">    skb_out = nlmsg_new(msg_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!skb_out)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        printk(KERN_ERR <span class="string">"Failed to allocate new skb\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nlh = nlmsg_put(skb_out, <span class="number">0</span>, <span class="number">0</span>, NLMSG_DONE, msg_size, <span class="number">0</span>);</span><br><span class="line">    NETLINK_CB(skb_out).dst_group = <span class="number">0</span>; <span class="comment">/* not in mcast group */</span></span><br><span class="line">    <span class="built_in">strncpy</span>(nlmsg_data(nlh), msg, msg_size);</span><br><span class="line"></span><br><span class="line">    res = nlmsg_unicast(nl_sk, skb_out, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        printk(KERN_INFO <span class="string">"Error while sending bak to user\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-3-从内核向用户态程序发送消息"><a href="#9-2-3-从内核向用户态程序发送消息" class="headerlink" title="9.2.3 从内核向用户态程序发送消息"></a>9.2.3 从内核向用户态程序发送消息</h3><p>正如在用户空间的发送流程那样，发送消息需要先设置一个socket接收地址。设置接收地址需要通过<code>NETLIN_CB</code>宏访问skb从control buffer中存储的netlink参数（<code>struct netlink_skb_parms</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_skb_parms</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scm_creds</span><span class="title">creds</span>;</span><span class="comment">/* Skb credentials*/</span></span><br><span class="line">__u32portid;</span><br><span class="line">__u32dst_group;</span><br><span class="line">__u32flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>*<span class="title">sk</span>;</span></span><br><span class="line"><span class="keyword">bool</span>nsid_is_set;</span><br><span class="line"><span class="keyword">int</span>nsid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中重要的参数时<code>dst_group</code>和<code>flags</code>。<br>如果要发送的数据包是单播数据包，发送方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETLINK_CB(skb_out).dst_group = <span class="number">0</span>; <span class="comment">/* not in mcast group */</span></span><br><span class="line">res = nlmsg_unicast(nl_sk, skb_out, pid);</span><br></pre></td></tr></table></figure><blockquote><p>这里的目标pid可以通过接收到的消息<code>nlh-&gt;nlmsg_pid</code>获取</p></blockquote><p>如果要发送的数据包是多播：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = nlmsg_multicast(nl_sk, skbout, own_pid, group, flags);</span><br></pre></td></tr></table></figure><blockquote><ol><li>此处的own_pid是传输自己的pid来纺织消息传递给自己。因此内核态在这里填写0</li><li>NETLNK_CB(skb_out).dst_group会在发送函数内设置。</li></ol></blockquote><h1 id="10-Further-Reading"><a href="#10-Further-Reading" class="headerlink" title="10 Further Reading"></a>10 Further Reading</h1><ul><li><a href="https://www.linuxjournal.com/article/7356" target="_blank" rel="noopener">Kernel Korner - Why and How to Use Netlink Socket</a></li><li><a href="https://gist.github.com/arunk-s/c897bb9d75a6c98733d6" target="_blank" rel="noopener">https://gist.github.com/arunk-s/c897bb9d75a6c98733d6</a></li></ul><p>文章链接 <a href="http://www.codewoody.com/posts/2348/">http://www.codewoody.com/posts/2348/</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/20975566/what-is-the-best-way-to-communicate-a-kernel-module-with-a-user-space-program&quot; targ
      
    
    </summary>
    
      <category term="kernel" scheme="http://www.codewoody.com/categories/kernel/"/>
    
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
      <category term="kernel" scheme="http://www.codewoody.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>使用iptables和route来建立起Linux的网关设置</title>
    <link href="http://www.codewoody.com/posts/32824/"/>
    <id>http://www.codewoody.com/posts/32824/</id>
    <published>2019-01-22T08:00:49.000Z</published>
    <updated>2019-01-22T08:06:21.104Z</updated>
    
    <content type="html"><![CDATA[<br>本文翻译自：<a href="https://www.systutorials.com/1372/setting-up-gateway-using-iptables-and-route-on-linux/" target="_blank" rel="noopener">Setting Up Gateway Using iptables and route on Linux</a>。<br>网络资源的分享是非常重要的，而建立起一个网关来进行网络分享是一个比较好的解决方案。在Linux系统中创建和设置网关非常简单，成本低廉，而且性能可靠。</p><h1 id="1-Linux网络设置"><a href="#1-Linux网络设置" class="headerlink" title="1 Linux网络设置"></a>1 Linux网络设置</h1><p>假定我们要处理的Linux有如下的配置：</p><ul><li>NIC1: eth0, ip: 192.168.0.1，连接到局域网(LAN)</li><li>NIC2: eth1, ip: 1.2.3.4, 连接到公网</li></ul><p><img src="https://imgs.codewoody.com/uploads/big/6f341c57eb221eab557015034a7c4c0e.png" alt="网络拓扑图"></p><p>现在我们希望将分享这台机器的网络连接给LAN网络上的其他电脑(ip: 192.168.0.0/16)</p><h1 id="2-设置网关"><a href="#2-设置网关" class="headerlink" title="2 设置网关"></a>2 设置网关</h1><p>下面提到的所有操作都需要root权限来执行。</p><h2 id="2-1-操作IP路由表"><a href="#2-1-操作IP路由表" class="headerlink" title="2.1 操作IP路由表"></a>2.1 操作IP路由表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip route add 192.168.0.0/16 dev eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="comment"># route add -net 192.168.0.0/16 dev eth0</span></span><br></pre></td></tr></table></figure><h2 id="2-2-启用Linux-IP-转发-IP-Forwarding"><a href="#2-2-启用Linux-IP-转发-IP-Forwarding" class="headerlink" title="2.2 启用Linux IP 转发(IP Forwarding)"></a>2.2 启用Linux IP 转发(IP Forwarding)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip.forward=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br></pre></td></tr></table></figure><p>你也可以直接编辑<code>/etc/sysctl.conf</code>来持久化这一设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><h2 id="2-3-通过iptables设置源地址映射-SNAT"><a href="#2-3-通过iptables设置源地址映射-SNAT" class="headerlink" title="2.3 通过iptables设置源地址映射(SNAT)"></a>2.3 通过iptables设置源地址映射(SNAT)</h2><p>将（其他电脑发送的）包的源地址修改为网关的源地址。iptables会自动将响应包的目的地址替换成正确的IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING ! -d 192.168.0.0/16 -o eth1 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure><p>除了使用SNAT，也可以使用MASQUERADE:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING ! -d 192.168.0.0/16 -o eth1 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>注意，对于静态IP而言，SNAT的方式要更好一些。根据iptables man page:</p><blockquote><p>This target is only valid in the nat table, in the POSTROUTING chain. It should only be used with dynamically assigned IP (dialup) connections: if you have a static IP address, you should use the SNAT target. Masquerading is equivalent to specifying a mapping to the IP address of the interface the packet is going out, but also has the effect that connections are forgotten when the interface goes down. This is the correct behavior when the next dialup is unlikely to have the same interface address (and hence any established connections are lost anyway).</p></blockquote><p>你还需要确保其他iptables不会阻拦对应的连接。如果你有这方面的问题，可以尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -t nat -A POSTROUTING ! -d 192.168.0.0/16 -o eth1 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure><p>上面的代码可以允许所有的接入连接。不过这会存在一些安全性问题。</p><h1 id="3-客户端配置"><a href="#3-客户端配置" class="headerlink" title="3 客户端配置"></a>3 客户端配置</h1><p>客户端配置主要是把网关设置成192.168.0.1。例如如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip route add default via 192.168.0.1 dev eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="comment"># route add default gw 192.168.0.1 eth0</span></span><br></pre></td></tr></table></figure><p>文章链接 <a href="http://www.codewoody.com/posts/32824/">http://www.codewoody.com/posts/32824/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络资源的分享是非常重要的，而建立起一个网关来进行网络分享是一个比较好的解决方案。在Linux系统中创建和设置网关非常简单，成本低廉，而且性能可靠。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/6f341c57eb221eab557015034a7c4c0e.png&quot; alt=&quot;网络拓扑图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
      <category term="iptables" scheme="http://www.codewoody.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>树莓派上搭建视频流服务的方法尝试</title>
    <link href="http://www.codewoody.com/posts/28769/"/>
    <id>http://www.codewoody.com/posts/28769/</id>
    <published>2018-12-26T13:43:19.000Z</published>
    <updated>2018-12-27T02:42:39.095Z</updated>
    
    <content type="html"><![CDATA[<p>最近实验需要在树莓派上搭建一个简单的视频服务，而且，希望画质一定的情况下，消耗的带宽越少越好。关于带宽的问题，其实开始并没有考虑太多，但是在尝试用<code>uv4l</code>工具创建mpeg流的时候发现，尽管分辨率很低（720p）不到，需要的数据率却达到了大约5MB/s。我们待测试的通信层不具备这样高的传输传输能力。因此需要想办法把数据率降下来。综上，我们需要产生一个编码后的视频流，如H264。<br><a id="more"></a></p><p>幸运的是我发现了<a href="https://github.com/131/h264-live-player" target="_blank" rel="noopener">h264-live-player</a>这个项目。这个项目是基于Node.js的工程，利用Websocket传输H264编码数据，在客户端用<code>Broadway</code>解码，而服务端的H264流通过<code>raspivid</code>产生。</p><p>在接下来的部分，我先简要介绍一下Raspivid的使用，然后介绍一下<code>h264-live-player</code>的情况。如果只是想上手使用，可以直接拉到最后。</p><h1 id="Raspivid"><a href="#Raspivid" class="headerlink" title="Raspivid"></a><a href="https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspivid.md" target="_blank" rel="noopener">Raspivid</a></h1><p><code>raspivid</code>是一个在树莓派上用于捕捉视频数据的命令行工具。在<code>h264-live-player</code>中，<code>lib/raspivid.js</code>文件调用了这个命令来产生H264的视频流。在这个文件中使用的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raspivid -t 0 -o - -w WIDTH -h HEIGHT -fps FPS</span><br></pre></td></tr></table></figure><p>其中，<code>-t 0</code>表示捕捉的时间不限。<code>-o -</code>表示将H264流输出到<code>stdout</code>。后面的<code>-w</code>, <code>-h</code>, <code>-fps</code>则分别是制定画面的宽高还有帧率。在<code>raspivid</code>命令产生H264流后，<code>h264-live-player</code>会通过一系列的回调函数通过Websocket将H264数据发送给前端。</p><h1 id="h264-live-player-关键代码解析。"><a href="#h264-live-player-关键代码解析。" class="headerlink" title="h264-live-player 关键代码解析。"></a><a href="tps://github.com/huangy10/h264-live-player" target="_blank" rel="noopener">h264-live-player</a> 关键代码解析。</h1><blockquote><p>注意，原作者的工程里面存在一些问题，其中重点是客户端刷新后视频流解析会出现异常。我在我的fork中修复了这些问题，还做了一些其他的改进。因此这里的介绍都以我的fork中的代码为准。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>首先还是要看<code>lib/raspivid.js</code>这个文件。<code>RpiServer</code>这个类继承于<code>Server</code>，<code>Server</code>中预留了<code>get_feed</code>给子类实现，器作用是产生视频流。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">get_feed() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.streamer !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.streamer.kill();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> msk = <span class="string">"raspivid -t 0 -o - -w %d -h %d -fps %d"</span>;</span><br><span class="line">    <span class="keyword">var</span> cmd = util.format(msk, <span class="keyword">this</span>.options.width, <span class="keyword">this</span>.options.height, <span class="keyword">this</span>.options.fps);</span><br><span class="line">    <span class="built_in">console</span>.log(cmd);</span><br><span class="line">    <span class="keyword">var</span> streamer = spawn(<span class="string">'raspivid'</span>, [<span class="string">'-t'</span>, <span class="string">'0'</span>, <span class="string">'-o'</span>, <span class="string">'-'</span>, <span class="string">'-w'</span>, <span class="keyword">this</span>.options.width, <span class="string">'-h'</span>, <span class="keyword">this</span>.options.height, <span class="string">'-fps'</span>, <span class="keyword">this</span>.options.fps, <span class="string">'-pf'</span>, <span class="string">'baseline'</span>]);</span><br><span class="line">    streamer.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (code) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Failure"</span>, code);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.streamer = streamer;</span><br><span class="line">    <span class="keyword">return</span> streamer.stdout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回的是<code>raspivid</code>子进程的<code>stdout</code>流，也即H264流。</p><p>然后我们来看<code>lib/_server.js</code>文件中<code>_Server</code>的定义。注意<code>start_feed</code>这个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start_feed() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.readStream) &#123;</span><br><span class="line">      <span class="keyword">this</span>.readStream.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> readStream = <span class="keyword">this</span>.get_feed();</span><br><span class="line">    <span class="keyword">this</span>.readStream = readStream;</span><br><span class="line"></span><br><span class="line">    readStream = readStream.pipe(<span class="keyword">new</span> Splitter(NALseparator));</span><br><span class="line">    readStream.on(<span class="string">"data"</span>, <span class="keyword">this</span>.broadcast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在客户端发起播放流的请求后调用。这里<code>Server</code>调用子类实现的<code>get_feed</code>函数获取视频流，然后视频流上注册<code>data</code>事件的回调函数。</p><blockquote><p>这里需要解释一下<code>readStream = readStream.pipe(new Splitter(NALseparator));</code>这行代码。这里我们为视频流增加了一个<code>Splitter</code>，生成<code>Splitter</code>的参数为一个<code>Buffer</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NALseparator    = <span class="keyword">new</span> Buffer([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]);<span class="comment">//NAL break</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在H264规范中，帧中间的会插入<code>00 00 00 01</code>作为帧间隔标识。这里插入的<code>Splitter</code>的作用是，在每次遇到<code>NALseperator</code>形式的字符流时，将之前收到的数据作为一个<code>chunk</code>，调用<code>data</code>事件的回调函数。</p></blockquote><p>再来看看<code>broadcast</code>函数。在视频流收到一定的函数时会调用这个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">broadcast(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wss.clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (socket.readyState !== WebSocket.OPEN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(socket.buzy)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      socket.buzy = <span class="literal">true</span>;</span><br><span class="line">      socket.buzy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      socket.send(Buffer.concat([NALseparator, data]), &#123; <span class="attr">binary</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span> <span class="title">ack</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        socket.buzy = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码非常简单，核心就是通过<code>socket.send</code>将数据发送给客户端。注意这里的数据的内容是<code>Buffer.concat([NALseperator, data])</code>。这是因为<code>Splitter</code>会截断分隔符。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端的代码集中在<code>vendor/wsavc/index.js</code>中。重点是下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> framesList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ws.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> evt.data == <span class="string">"string"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cmd(<span class="built_in">JSON</span>.parse(evt.data));</span><br><span class="line">    <span class="keyword">this</span>.pktnum++;</span><br><span class="line">    <span class="keyword">var</span> frame = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(evt.data);</span><br><span class="line">    <span class="comment">//log("[Pkt " + this.pktnum + " (" + evt.data.byteLength + " bytes)]");</span></span><br><span class="line">    <span class="comment">//this.decode(frame);</span></span><br><span class="line">    framesList.push(frame);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shiftFrame = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!running)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(framesList.length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    log(<span class="string">"Dropping frames"</span>, framesList.length);</span><br><span class="line">    framesList = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> frame = framesList.shift();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(frame) &#123;</span><br><span class="line">    <span class="keyword">this</span>.decode(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(shiftFrame);</span><br><span class="line">&#125;.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shiftFrame();</span><br></pre></td></tr></table></figure><p>在接收到服务器发送的数据时，数据会被转换成<code>Uint8Array</code>，然后压入到一个队列中。而在<code>shiftFrame</code>这个函数会周期性的调用，从队列中取出数据进行解码。解码后会触发<code>Broadway</code>解码器的<code>onPictureDecoded</code>回调，在这个回调中<code>canvas</code>中的图像会被更新。</p><h1 id="h264-live-player的部署和使用"><a href="#h264-live-player的部署和使用" class="headerlink" title="h264-live-player的部署和使用"></a>h264-live-player的部署和使用</h1><h2 id="安装Node-js到树莓派"><a href="#安装Node-js到树莓派" class="headerlink" title="安装Node.js到树莓派"></a>安装Node.js到树莓派</h2><p>SSH登录到树莓派，然后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get dist-upgrade</span><br><span class="line"></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>使用下面的命令来验证安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line">v8.14.1</span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v    <span class="comment"># npm是Node.js的包管理器</span></span></span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure><h2 id="安装h264-live-player"><a href="#安装h264-live-player" class="headerlink" title="安装h264-live-player"></a>安装h264-live-player</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载仓库</span></span><br><span class="line">git clone git@gitlab.vlionthu.com:tdma-uav/raspberry-pi-video-stream.git player</span><br><span class="line"></span><br><span class="line">cd player</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd player</span><br><span class="line">node server_rpi.js</span><br></pre></td></tr></table></figure><p>上面的运行方法会在terminal中启动服务脚本。如果要这个程序常驻后台，可以尝试使用<a href="http://pm2.keymetrics.io/" target="_blank" rel="noopener">pm2</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g pm2    # 安装pm2，这里的-g表示安装到全局环境下</span><br><span class="line"></span><br><span class="line">cd player    # cd to player folder</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">pm2 start ./server-rpi.js \</span><br><span class="line">    -i 1 \</span><br><span class="line">    --name "video-stream" \</span><br><span class="line">    -o "/home/pi/player/stdout.log" \</span><br><span class="line">    -e "/home/pi/player/stderr.log"</span><br></pre></td></tr></table></figure><h2 id="在网页端访问摄像头"><a href="#在网页端访问摄像头" class="headerlink" title="在网页端访问摄像头"></a>在网页端访问摄像头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://rasp_ip:8080</span><br></pre></td></tr></table></figure><p>可以通过添加<code>/?r</code>的query参数来上下翻转画面。</p><p>文章链接 <a href="http://www.codewoody.com/posts/28769/">http://www.codewoody.com/posts/28769/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近实验需要在树莓派上搭建一个简单的视频服务，而且，希望画质一定的情况下，消耗的带宽越少越好。关于带宽的问题，其实开始并没有考虑太多，但是在尝试用&lt;code&gt;uv4l&lt;/code&gt;工具创建mpeg流的时候发现，尽管分辨率很低（720p）不到，需要的数据率却达到了大约5MB/s。我们待测试的通信层不具备这样高的传输传输能力。因此需要想办法把数据率降下来。综上，我们需要产生一个编码后的视频流，如H264。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="折腾" scheme="http://www.codewoody.com/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="树莓派" scheme="http://www.codewoody.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>Dependency Injection in Node.js | 2016</title>
    <link href="http://www.codewoody.com/posts/30333/"/>
    <id>http://www.codewoody.com/posts/30333/</id>
    <published>2018-12-15T09:41:10.000Z</published>
    <updated>2018-12-18T02:19:03.635Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/posts/61013/">上一篇文章</a>中我们初步讨论的Dependency Injection的一些理念。在这篇文章中，我翻译了awilix模块的作者Jeff Hansen的文章：<a href="https://medium.com/@Jeffijoe/dependency-injection-in-node-js-2016-edition-f2a88efdd427" target="_blank" rel="noopener">Dependency Injection in Node.js - 2016 edition</a>。原文包含三个部分，我在这里直接整理成为一篇完整的文章。</p><a id="more"></a><blockquote><p>在翻译中我以传到核心思想为主，故不会太拘泥于一些细节问题。对于一些插科打诨的话，如果不是特别有意思的话，也许不会翻译。</p></blockquote><p><img src="https://imgs.codewoody.com/uploads/big/a3409d0fa20c30e7116c01c4d7ac4f1e.jpeg" alt="作者Jeff Hansen"></p><hr><h1 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h1><p>在2015年，RisingStack写了<a href="https://blog.risingstack.com/dependency-injection-in-node-js/" target="_blank" rel="noopener">一篇关于Dependency Injection(缩写为DI)的文章</a>，解释了什么是DI，以及如何手动实现。如果你还没有阅读这篇文章，我强烈建议你先阅读以下那篇文章。这样你对于本文的一些概念会有更加清晰的理解。</p><blockquote><p>这里提到的RisingStack的文章的中文版可以在我的博客里找到: <a href="/posts/61013/">Node.js | Dependency Injection</a>。</p></blockquote><p>在这一系列文章中，我会扩展一下手动实现的DI，为什么这种做法是糟糕的，以及我们如何最终能够让DI的现实变得优雅 – 甚至比require/imports方式要更好。我将要证明Node中使用DI可以不像之前的做法那样沉闷。这都要归功于在ES6中引入的新特性：Proxies（直译就是代理）。</p><p>我100%肯定作为一个Node的开发者，你会见过某种形式的DI。借鉴一下RisingStack文章中的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    store: <span class="built_in">require</span>(<span class="string">'connect-session-knex'</span>)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>session needs a store! - 这种存储的具体实现方式是多样的 ：redis，MySQL。Express本身并不关心背后的实现。我们来看下面的这个例子 – 非DI实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../mydatabase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    getToDos: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> db.query(<span class="string">'select * from todos'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中我们直接导入了db模块，因此这个文件就依赖于db模块在磁盘上的具体存储位置，以及依赖于特定的是方式。在大多数场景下这并不算一个大问题。不过这种方式让测试变得更加困难 – 不至于无法进行测试，但是无论如何都变得更加地困难了。另外，这个模块还假定db模块已经准备好了（例如：数据库连接已经建立起来了）。</p><p>如果我们进一步将上面的代码转化成为对于测试友好的DI实现方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">makeTodosService</span> (<span class="params">&#123; db &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getTodos: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> db.query(<span class="string">'select * from todos'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上面两个例子有什么区别呢？在下面的DI实现的例子中我们不是export出一个对象，而是export出一个生成这种对象的函数。这个函数同时阐明了为了创建此种对象所需要的依赖。</p><p>如果你熟悉在其他语言中的DI实现，如Java, C#，还有PHP。下面这个使用ES6的类实现的例子可能更受你喜欢一些：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TodosService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(&#123; db &#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.db = db</span><br><span class="line">    &#125;</span><br><span class="line">    getTodos() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.db.query(<span class="string">'select * from todos'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过从个人角度我还是更喜欢函数的方法：不用担心this的上下文的问题。</p><p>测试上面这个基于DI的例子非常简单 – 你不再需要担心对require进行修修补补来替代数据库模块从而连接到测试数据库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'Todo Service'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforeEach(() &#123;</span><br><span class="line">        subject = makeTodosService(&#123;</span><br><span class="line">            db: testDatabaseSomehow</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'work'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> todos = <span class="keyword">await</span> subject.getTodos(</span><br><span class="line">            expect(todos.length).to.equal(<span class="number">3</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><p>在这个部分我们来构思一个Todo APP。</p><p>在我们开始折腾API框架和其他乱七八糟的部分之前，我们来大致搭建一下项目的骨架 – the service and data access。为了可读性的考虑我在这里使用了ES7的async-await机制。</p><p>然我们来开始我们的Todos Service - 这个模块来负责处理所有的业务逻辑。</p><p>我会在下面的代码片段那种使用不同的风格（函数式或者是面向对象的）来证明，这些具体的代码风格并不本质，你可以使用任何你喜欢的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todosService.js</span></span><br><span class="line"><span class="keyword">import</span> assert <span class="keyword">from</span> <span class="string">'assert'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Using object destructring to make it look good</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">makeTodosService</span> (<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> <span class="string">"repository"</span> is a fancy term to describe an object</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> that is used to retrieve data from a datasource - the actual</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> data source does not matter. Could be a database, a REST API,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> or some IoT things like sensors or what ever</span></span></span><br><span class="line"><span class="function"><span class="params">    todosRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> We also want info about the user that is using the service,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> so we can restrict access to only their own todos.</span></span></span><br><span class="line"><span class="function"><span class="params">    currentUser</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    assert(todosRepositry, <span class="string">'opts.todosRepository is required.'</span>)</span><br><span class="line">    assert(currentUser, <span class="string">'opts.currentUser is required.'</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// Gets todos for the current user</span></span><br><span class="line">        getTodos: <span class="keyword">async</span>(query) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> todos = <span class="keyword">await</span> todosRepository.find(&#123;</span><br><span class="line">                <span class="comment">// can be ALL, INCOMPLETED, COMPLETED</span></span><br><span class="line">                filter: query.filter,</span><br><span class="line">                userId: currentUser.id</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> todos</span><br><span class="line">        &#125;,</span><br><span class="line">        createTodo: <span class="keyword">async</span> (data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> newTodo = <span class="keyword">await</span> todosRepository.create(&#123;</span><br><span class="line">                text: data.text,</span><br><span class="line">                userId: currentUser.id,</span><br><span class="line">                completed: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> newTodo</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        updateTodo: <span class="keyword">async</span> (todoId, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> todo = <span class="keyword">await</span> todosRepository.get(todoId)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// verify that we are allowed to modify this todo</span></span><br><span class="line">            <span class="keyword">if</span> (todo.userId !== currentUser.id) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Forbidden'</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> updatedTodo = <span class="keyword">await</span> todosRepository.update(todoId, &#123;</span><br><span class="line">                text: data.text,</span><br><span class="line">                completed: data.completed</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> updatedTodo</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        deleteTodo: <span class="keyword">async</span> (todoId) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> todo = <span class="keyword">await</span> (todoId)</span><br><span class="line">            <span class="keyword">const</span> todo = <span class="keyword">await</span> todosRepository.get(todoId);</span><br><span class="line">            <span class="keyword">if</span> (todo.userId !== currentUser.id) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Forbidden'</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> todoRepository.delete(todoId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有点长，但是并没有什么太fancy的东西。我们并没有依赖于外部库（除了自带的assert模块用于输入检验）。不过，我们导出的函数其实有两个依赖：</p><ul><li><code>todosRepository</code> – 给予todos数据库访问的对象（我们并不关心具体的实现细节）。</li><li><code>currentUser</code> – 正在使用这个服务的用户。注意我们并不知道这个对象从何处生成，也不关心这些细节。</li></ul><p>我们继续往下走，给出todos repository的一个不错的实现方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todosRepository.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Let's do an in-memory implementation for now.</span></span><br><span class="line"><span class="keyword">const</span> _todos = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TodosRepository</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Making all methods async makes them return promises!</span></span><br><span class="line">    <span class="keyword">async</span> find(query) &#123;</span><br><span class="line">        <span class="keyword">const</span> filtered = _todos.filter(<span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Check the user id</span></span><br><span class="line">            <span class="keyword">if</span> (todo.userId !== query.userId) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check the filter</span></span><br><span class="line">            <span class="keyword">if</span> (query.filter === <span class="string">"COMPLETED"</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> todo.completed === <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (query.filter === <span class="string">"INCOMPLETED"</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> todo.completed === <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filtered</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> get(id) &#123;</span><br><span class="line">        <span class="keyword">const</span> todo = _todos.find(<span class="function"><span class="params">x</span> =&gt;</span> x.id === id)</span><br><span class="line">        <span class="keyword">return</span> todo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> create(data) &#123;</span><br><span class="line">        <span class="keyword">const</span> newTodo = &#123;</span><br><span class="line">            id: <span class="built_in">Date</span>.now(),</span><br><span class="line">            text: data.text,</span><br><span class="line">            userId: data.userId,</span><br><span class="line">            completed: data.completed</span><br><span class="line">        &#125;</span><br><span class="line">        _todos.push(newTodo)</span><br><span class="line">        <span class="keyword">return</span> newTodo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> update(id, data) &#123;</span><br><span class="line">        <span class="keyword">const</span> todo = <span class="keyword">await</span> <span class="keyword">this</span>.get(id)</span><br><span class="line">        <span class="built_in">Object</span>.assign(todo, data)</span><br><span class="line">        <span class="keyword">return</span> todo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">delete</span>(id) &#123;</span><br><span class="line">        <span class="keyword">const</span> todo = <span class="keyword">await</span> <span class="keyword">this</span>.get(id)</span><br><span class="line">        _todos.splice(todo, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只是todos repository的一个in-memory实现。任何时候我们准备好的时候，可以替换成MySQL，Rethink，MongoDB等存储后端，只要具有同形式的API就可以了。Typescript和Flow在这里可以发挥很大的作用。</p><h2 id="把系统粘合起来"><a href="#把系统粘合起来" class="headerlink" title="把系统粘合起来"></a>把系统粘合起来</h2><p>在我们进入到RESTful API之前，让我们先把上门两个模块在测试中整合起来。下面的方法被称为“穷人式的DI”，不过别担心，在后面我们会展示更加fancy的做法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> makeTodosService <span class="keyword">from</span> <span class="string">'./todosService'</span></span><br><span class="line"><span class="keyword">import</span> TodosRepository <span class="keyword">from</span> <span class="string">'./todosRepository'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Todos System'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'works'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// This is how DI is done manually</span></span><br><span class="line">        <span class="keyword">const</span> todosService = makeTodosService(&#123;</span><br><span class="line">            todosRepository: <span class="keyword">new</span> TodosRepository(),</span><br><span class="line">            <span class="comment">// Let's fake it til we make it!</span></span><br><span class="line">            currentUser: &#123;</span><br><span class="line">                id: <span class="number">123</span>,</span><br><span class="line">                name: <span class="string">'Jeff'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Todos Service already knows who's creating it!</span></span><br><span class="line">        <span class="keyword">const</span> created = <span class="keyword">await</span> todosService.create(&#123;</span><br><span class="line">            text: <span class="string">'Write Medium article'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        expect(created.userId).to.equal(<span class="number">123</span>, <span class="string">'user id should match currentUser'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> todos = <span class="keyword">await</span> todosService.getTodos(&#123;</span><br><span class="line">            filter: <span class="string">'ALL'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        expect(todos.length).to.equal(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> todosService.update(todo.id, &#123;</span><br><span class="line">            completed: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> incompleteTodos = <span class="keyword">await</span> todosService.getTodos(&#123;</span><br><span class="line">            filter: <span class="string">'INCOMPETED'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        expect(incompleteTodos.length).to.equal(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> completedTodos = <span class="keyword">await</span> todosService.getTodos&#123;</span><br><span class="line">            filter: <span class="string">'COMPLETED'</span></span><br><span class="line">        &#125;</span><br><span class="line">        expect(completedTodos.length).to.equal(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看到上面的代码你可能会想：“这里的代码不是已经知道了两个模块了么？”。没错，在一个真实的APP中（下文中我们会提及），还是需要有一个知道所有使用的模块的单一置信源（source of truth）。在我们倒腾DI黑科技的时候，我们把这个部分的代码称为：组合根（The Composition Root，译者按：这个名字放在中文下太绕口了）。这是在应用中将所有的模块胶合在一起的地方。Composition Root可能长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cosnt currentUser = &#123;</span><br><span class="line">    id: <span class="number">123</span>,</span><br><span class="line">    name: <span class="string">'Jeff'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoRepository = <span class="keyword">new</span> TodosRepository()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todosService = makeTodosService(&#123;</span><br><span class="line">    todosRepository,</span><br><span class="line">    currentUser</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    todosService,</span><br><span class="line">    todosRepository</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个代码，我知道你一定在想：“我现在还不知道这个currentUser具体是指哪个用户呢！我要构建的是一个Web应用，这种方法根本没用！”。你说的对。有两种方法来手动解决这个问题：</p><ul><li>为所有需要currentUser的方法手动传递这个参数 – 这也太坑了。</li><li>将实例化过程推迟到你拥有了所有的数据之后（译者按：即在已知了currentUser之后再调用工厂函数初始化todosService）– 这种方法也不好，你需要在很多的地方重复地进行实例化。</li></ul><p>为了进一步解释以下第二点，下面给出一个例子。例子中使用到了Koa Router</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/todos"</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> todosService = makeTodosService(&#123;</span><br><span class="line">        todosRepository: <span class="keyword">new</span> TodosRepository(),</span><br><span class="line">        currentUser: ctx.state.user</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ctx.body = <span class="keyword">await</span> todosService.getTodos(ctdx.request.query)</span><br><span class="line">    ctx.status = <span class="number">200</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">"/todos"</span>. async (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> todosService = makeTodosService(&#123;</span><br><span class="line">        todosRepository: <span class="keyword">new</span> TodosRepository(),</span><br><span class="line">        currentUser: ctx.state.user</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// and so on</span></span><br></pre></td></tr></table></figure><p>这还只是涉及到两个模块。想象一下要是需要处理10个模块（这还只是对于小型的应用）。没错，第二种方法也是很糟糕的。</p><h1 id="Part-III"><a href="#Part-III" class="headerlink" title="Part III"></a>Part III</h1><p>Angular曾经是在JavaScript世界中第一个引入了DI的大型框架。他们的做法是使用函数的字符串表达来提取使用的模块名称。在当时这是唯一的做法。</p><p>有一些人尝试将DI功能从Angular中独立出来做成一个独立模块。但是问题是，大多数DI模块要求你的所有代码都要围绕着特定的DI系统来开发，这位违背了DI设计理念的初衷。</p><blockquote><p>DI的作用是减少程序模块之间的耦合程度，提高代码的可维护性。在这种目标下，DI系统的设计应当尽可能减少对于其它业务代码的影响。如果为了使用DI要对业务代码结构进行大范围的改动的话就得不偿失了。</p></blockquote><p>我们希望能够在不改动我们的service和repository模块的情况下使用DI机制。</p><h2 id="关于Awilix-The-DI-container-you-deservce"><a href="#关于Awilix-The-DI-container-you-deservce" class="headerlink" title="关于Awilix - The DI container you deservce"></a>关于Awilix - The DI container you deservce</h2><p>如果你不知道DI容器是什么，下面是一个简短的解释。DI容器的功能是将系统中的模块整合起来，从而让开发者不再需要太关注这些DI的实现细节问题。在前面两个Part中我们给出的示例代码：实例化services和repositories，确保service获取repository对象。这些工作都将由DI容器来完成。</p><p>Awilix就是这样的一个容器，其实现是基于ES6 Proxies，这一意味着不再需要对函数的参数进行字符串解析。</p><p>现在让我们回到开头的todo应用。让我们使用Awilix来将各个模块整合起来。我们将会使用Koa 2来实现Web API。先让我们来安装这些依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S koa@next koa-router@next awilix awilix-koa</span><br></pre></td></tr></table></figure><p>这里的awilix-koa模块让Awlix和Koa的搭配更加易用。现在让我们从composition root开始</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configureContainer.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContainer, asClass, asFunction &#125; <span class="keyword">from</span> <span class="string">'awilix'</span></span><br><span class="line"><span class="keyword">import</span> makeTodosService <span class="keyword">from</span> <span class="string">'./todosService'</span></span><br><span class="line"><span class="keyword">import</span> TodosRepository <span class="keyword">from</span> <span class="string">'./todosRepository'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureContainer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> container = createContainer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ordering does not matter</span></span><br><span class="line">    container.register(&#123;</span><br><span class="line">        <span class="comment">// Notice the scoped() at the end - this signals</span></span><br><span class="line">        <span class="comment">// Awilix that we gonna want a new instance per "scope"</span></span><br><span class="line">        todosService: asFunction(makeTodosService).scoped(),</span><br><span class="line">        <span class="comment">// We only want a single instance of this for the apps</span></span><br><span class="line">        <span class="comment">// lifetime (it does not deal with user context)</span></span><br><span class="line">        <span class="comment">// so we can reuse it!</span></span><br><span class="line">        todosRepository: asClass(TodosRepository).singliton()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> container</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来已经非常不错了。不过如果你有超过100个服务需要注册，Awilix提供了<a href="https://github.com/jeffijoe/awilix#auto-loading-modules" target="_blank" rel="noopener">自动化的工具</a>。</p><p>现在让我们来配置Koa应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">import</span> Koa <span class="keyword">from</span> <span class="string">'koa'</span></span><br><span class="line"><span class="keyword">import</span> KoaRouter <span class="keyword">from</span> <span class="string">'koa-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; asValue &#125; <span class="keyword">from</span> <span class="string">'awilix'</span></span><br><span class="line"><span class="keyword">import</span> &#123; scopePerRequest, makeInvoker &#125; <span class="keyword">from</span> <span class="string">'awilix-koa'</span></span><br><span class="line"><span class="keyword">import</span> configureContainer <span class="keyword">from</span> <span class="string">'./configureContainer'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter()</span><br><span class="line"><span class="keyword">const</span> container = configureContainer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// This installs a scoped container into our</span></span><br><span class="line"><span class="comment">// context - we will use this to register our current user</span></span><br><span class="line">app.use(scopePerRequest(container))</span><br><span class="line"><span class="comment">// Let's do that now!</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.state.container.register(Value)(&#123;</span><br><span class="line">        <span class="comment">// Imagine some auth middleware somewhere...</span></span><br><span class="line">        <span class="comment">// This makes currentUser available to all services</span></span><br><span class="line">        currentUser: ctx.state.user</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now our handlers will be able to resolve a todos service</span></span><br><span class="line"><span class="comment">// using DI!</span></span><br><span class="line"><span class="comment">// P.S: be a good dev and use multiple files. ;)</span></span><br><span class="line"><span class="keyword">const</span> todosAPI = (&#123; todosService &#125; =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getTodos: <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> todos = <span class="keyword">await</span> todosService.getTodos(ctx.request.query)</span><br><span class="line">            ctx.body = todos</span><br><span class="line">            ctx.status = <span class="number">200</span></span><br><span class="line">        &#125;,</span><br><span class="line">        createTodos: <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> todo = <span class="keyword">await</span> todosService.createTodo(ctx.request.body)</span><br><span class="line">            ctx.body = todo</span><br><span class="line">            ctx.status = <span class="number">201</span></span><br><span class="line">        &#125;,</span><br><span class="line">        updateTodo: <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> updated = <span class="keyword">await</span> todosService.updateTodo(</span><br><span class="line">                ctx.params.id,</span><br><span class="line">                ctx.request.body</span><br><span class="line">            )</span><br><span class="line">            ctx.body = updated,</span><br><span class="line">            ctx.status = <span class="number">200</span></span><br><span class="line">        &#125;,</span><br><span class="line">        deleteTodo: <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">            <span class="keyword">await</span> todosService.deleteTodo(</span><br><span class="line">                ctx.params.id,</span><br><span class="line">                ctx.request.body</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Awilix magic will run the above function</span></span><br><span class="line"><span class="comment">// every time a request comes in, so we have</span></span><br><span class="line"><span class="comment">// a set of scoped services per request</span></span><br><span class="line"><span class="keyword">const</span> api = makeInvoker(todosAPI)</span><br><span class="line">router.get(<span class="string">'/todos'</span>, api(<span class="string">'getTodos'</span>))</span><br><span class="line">router.post(<span class="string">'/todos'</span>, api(<span class="string">'createTodos'</span>))</span><br><span class="line">router.patch(<span class="string">'/todos/:id'</span>, api(<span class="string">'updateTodo'</span>))</span><br><span class="line">router.patch(<span class="string">'/todos/:id'</span>, api(<span class="string">'deleteTodo'</span>))</span><br><span class="line"></span><br><span class="line">app.use(router.routes())</span><br><span class="line">app.listen(<span class="number">1337</span>)</span><br></pre></td></tr></table></figure><p>上面的代码还只是一个简单的雏形，不过你现在已经有了构建大规模项目的基础。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>DI是一个很有用的东西，不过手动去实现DI是一件糟心的事情。这也是Awilix这种DI容器扮演作用的地方。</p><p>文章链接 <a href="http://www.codewoody.com/posts/30333/">http://www.codewoody.com/posts/30333/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/posts/61013/&quot;&gt;上一篇文章&lt;/a&gt;中我们初步讨论的Dependency Injection的一些理念。在这篇文章中，我翻译了awilix模块的作者Jeff Hansen的文章：&lt;a href=&quot;https://medium.com/@Jeffijoe/dependency-injection-in-node-js-2016-edition-f2a88efdd427&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dependency Injection in Node.js - 2016 edition&lt;/a&gt;。原文包含三个部分，我在这里直接整理成为一篇完整的文章。&lt;/p&gt;
    
    </summary>
    
      <category term="形而上" scheme="http://www.codewoody.com/categories/%E5%BD%A2%E8%80%8C%E4%B8%8A/"/>
    
    
      <category term="翻译" scheme="http://www.codewoody.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="nodejs" scheme="http://www.codewoody.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Node.js | Dependency Injection</title>
    <link href="http://www.codewoody.com/posts/61013/"/>
    <id>http://www.codewoody.com/posts/61013/</id>
    <published>2018-12-12T15:40:11.000Z</published>
    <updated>2018-12-12T16:30:22.959Z</updated>
    
    <content type="html"><![CDATA[<p>Dependency Injection这个概念是我之前在实习的时候做Java开发的时候接触的。Dependency Injection可以大大降低模块之间的耦合度，提高系统的可扩展性和鲁棒性，不过这个概念对于新人来说理解起来还是存在比较大的障碍。由于当时实习的时间比较短，对于这个概念我并没有吃透。这次学习Node.js的时候，又在awilix这个库里面遇到了这个概念。以此为契机就来好好学习一些Dependency Injection和其后的设计逻辑与方法。</p><p>下面的内容翻译自：<a href="https://blog.risingstack.com/dependency-injection-in-node-js/" target="_blank" rel="noopener">Dependency Injection in Node.js</a>。这篇文章浅显地介绍了Dependency Injection的基本理念。选择这篇文章是因为我在阅读awilix模块作者关于Dependency Injection的系列文章中时，作者在开篇提议阅读此文。</p><p>不过这篇文章毕竟是2015年的文章，在js的一些语法和模块细节上和今时今日的有些不同，但是并不妨碍我们对于其核心理念的理解。<a id="more"></a></p><h1 id="使用Dependency-Injection的理由"><a href="#使用Dependency-Injection的理由" class="headerlink" title="使用Dependency Injection的理由"></a>使用Dependency Injection的理由</h1><h2 id="解耦-Decoupling"><a href="#解耦-Decoupling" class="headerlink" title="解耦 (Decoupling)"></a>解耦 (Decoupling)</h2><p>Dependency Injection使你的模块耦合度降低，从而提升代码的可维护性。</p><h2 id="更简单的单元测试"><a href="#更简单的单元测试" class="headerlink" title="更简单的单元测试"></a>更简单的单元测试</h2><p>比起需要硬编码的依赖关系，你可以将依赖关系传输进入你要用的模块。在大多数场合下使用这种范式你不必要使用proxyquire这样的模块。</p><blockquote><p>这一段作者写的比较含糊。其实意思是在使用Dependency Injection场景下，我们在独立测试一些单元功能的时候，对于其他模块可以通过注入Mock对象，从而将待测试的模块独立出来进行测试。</p></blockquote><h2 id="更快速的开发"><a href="#更快速的开发" class="headerlink" title="更快速的开发"></a>更快速的开发</h2><p>在使用了Dependency Injection的场景下，在接口定义好了以后，开发会更加容易，Merge conflict会更少。</p><h1 id="如何在Node-js中使用Dependency-Injection"><a href="#如何在Node-js中使用Dependency-Injection" class="headerlink" title="如何在Node.js中使用Dependency Injection"></a>如何在Node.js中使用Dependency Injection</h1><p>下面我们来看看如何在不适用Dependency Injection的前提下开发应用，然后看看如何进行转化。</p><h2 id="不使用Dependency-Injection的例子"><a href="#不使用Dependency-Injection的例子" class="headerlink" title="不使用Dependency Injection的例子"></a>不使用Dependency Injection的例子</h2><p>下面是一段简单的没有使用Dependency Injection的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// team.js</span></span><br><span class="line"><span class="keyword">var</span> User = <span class="built_in">require</span>(<span class="string">'./user'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTeam</span>(<span class="params">teamId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> User.find(&#123;<span class="attr">teamId</span>: teamId&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.getTeam = getTeam;</span><br></pre></td></tr></table></figure><p>对应的测试可能是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// team.spec.js</span></span><br><span class="line"><span class="keyword">var</span> Team = <span class="built_in">require</span>(<span class="string">'./team'</span>);</span><br><span class="line"><span class="keyword">var</span> User = <span class="built_in">require</span>(<span class="string">'/user'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Team'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'#getTeam'</span>, <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> users = [&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">id</span>: <span class="number">2</span>&#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sandbox.stub(User, find, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(users);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> team = <span class="keyword">yield</span> team.getTeam();</span><br><span class="line"></span><br><span class="line">        expect(team).to.eql(users);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上面的代码中我们做的是创建了一个名为<code>team.js</code>的模块，该模块可以返回属于一个team的用户列表。为了实现这一功能，我们导入<code>User</code>模块，然后我们再调用其<code>find</code>方法返回用户列表。</p><p>看起来不错，是吗？但是当我们需要进行测试时，我们必须要使用<a href="https://sinonjs.org/" target="_blank" rel="noopener">sinon</a>的test stubs.</p><p>在测试文件中，我们需要引入User模块，为其stub一个<code>find</code>方法。注意，我们在这里要使用sandbox功能，这样我们不需在测试完成后回复<code>find</code>的原函数。</p><blockquote><p>注意：如果原始对象使用了<code>Object.freeze</code>，那么stubs将不会起作用。</p></blockquote><h2 id="使用Dependency-Injection的例子"><a href="#使用Dependency-Injection的例子" class="headerlink" title="使用Dependency Injection的例子"></a>使用Dependency Injection的例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// team.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Team</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Team.prototype.getTeam = <span class="function"><span class="keyword">function</span>(<span class="params">teamId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.options.User.find(&#123;<span class="attr">teamId</span>: teamId&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Team(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用下面的这个文件来进行测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// team.spec.js</span></span><br><span class="line"><span class="keyword">var</span> Team =- <span class="built_in">require</span>(<span class="string">'./team'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Team'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'#getTeam'</span>, <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> users = [&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">id</span>: <span class="number">2</span>&#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fakeUser = &#123;</span><br><span class="line">            find: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(users);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> team = Team.create(&#123;</span><br><span class="line">            User: fakeUser</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> team = <span class="keyword">yield</span> team.getTeam();</span><br><span class="line"></span><br><span class="line">        expect(team).to.eql(users);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么，使用了Dependency Injection的版本同之前的版本有什么区别呢？首先你可能注意到的是这里使用了<a href="https://blog.risingstack.com/fundamental-node-js-design-patterns/" target="_blank" rel="noopener">工厂模式</a>：我们使用这种设计模式来将options/dependencies inject到新创建的对象中 - 这里是我们注入<code>User</code>模块的方法。</p><p>在测试文件中我们还需要创建一个fake model来代表<code>User</code>模块，然后将这个伪造的模块传递给工厂函数。很简单，不是吗？</p><h1 id="Dependency-Injection-in-Real-Projects"><a href="#Dependency-Injection-in-Real-Projects" class="headerlink" title="Dependency Injection in Real Projects"></a>Dependency Injection in Real Projects</h1><p>你可以在非常多的开源项目中发现Dependency Injection的例子。例如，你在日常工作中常常用到的Express/Koa的大部分中间件都使用了这种技术。</p><h2 id="Express-Middlewares"><a href="#Express-Middlewares" class="headerlink" title="Express Middlewares"></a>Express Middlewares</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    store: <span class="built_in">require</span>(<span class="string">'connect-session-knex'</span>);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>上面的代码片段使用了基于工厂模式的Dependency Injection：对应session中间件我们传递了一个<code>connect-session-knex</code>模块。这个模块需要实现<code>session</code>模块调用需要的借口。</p><p>在这个例子中，<code>connect-session-knex</code>模块需要实现下面的方法：</p><ul><li><code>store.destroy(sid, callback)</code></li><li><code>store.get(sid, callback)</code></li><li><code>store.set(sid, session, callback)</code></li></ul><h2 id="Hapi-plugins"><a href="#Hapi-plugins" class="headerlink" title="Hapi plugins"></a>Hapi plugins</h2><p>Dependency Injection的概念还可以在Hapi中找到。下面的例子中，<code>handlebars</code>模块被作为view engine注入给Hapi使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.views(&#123;</span><br><span class="line">    engines: &#123;</span><br><span class="line">        html: <span class="built_in">require</span>(<span class="string">'handlebars`)</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    relativeTo: __dirname,</span></span><br><span class="line"><span class="string">    path: '</span>templates<span class="string">'</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>文章链接 <a href="http://www.codewoody.com/posts/61013/">http://www.codewoody.com/posts/61013/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dependency Injection这个概念是我之前在实习的时候做Java开发的时候接触的。Dependency Injection可以大大降低模块之间的耦合度，提高系统的可扩展性和鲁棒性，不过这个概念对于新人来说理解起来还是存在比较大的障碍。由于当时实习的时间比较短，对于这个概念我并没有吃透。这次学习Node.js的时候，又在awilix这个库里面遇到了这个概念。以此为契机就来好好学习一些Dependency Injection和其后的设计逻辑与方法。&lt;/p&gt;
&lt;p&gt;下面的内容翻译自：&lt;a href=&quot;https://blog.risingstack.com/dependency-injection-in-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dependency Injection in Node.js&lt;/a&gt;。这篇文章浅显地介绍了Dependency Injection的基本理念。选择这篇文章是因为我在阅读awilix模块作者关于Dependency Injection的系列文章中时，作者在开篇提议阅读此文。&lt;/p&gt;
&lt;p&gt;不过这篇文章毕竟是2015年的文章，在js的一些语法和模块细节上和今时今日的有些不同，但是并不妨碍我们对于其核心理念的理解。
    
    </summary>
    
      <category term="形而上" scheme="http://www.codewoody.com/categories/%E5%BD%A2%E8%80%8C%E4%B8%8A/"/>
    
    
      <category term="翻译" scheme="http://www.codewoody.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="nodejs" scheme="http://www.codewoody.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab|安装-迁移-删除</title>
    <link href="http://www.codewoody.com/posts/25664/"/>
    <id>http://www.codewoody.com/posts/25664/</id>
    <published>2018-12-10T08:02:11.000Z</published>
    <updated>2018-12-11T07:08:25.574Z</updated>
    
    <content type="html"><![CDATA[</p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h1><h2 id="1-1-Omnibus-package-installation"><a href="#1-1-Omnibus-package-installation" class="headerlink" title="1.1 Omnibus package installation"></a>1.1 Omnibus package installation</h2><p>这是Gitlab官网推荐的安装方式。官网文档链接位于<a href="https://gitlab.com/gitlab-org/gitlab-recipes/blob/master/web-server/nginx/gitlab-omnibus-nginx.conf" target="_blank" rel="noopener">Gitlab Installation</a>。不过，现在直接去官网默认给出的是企业版，即gitlab-ee的安装方式（付费的），而个人版其实用gitlab-ce就够了。gitlab-ce安装方式如下</p><h3 id="1-1-1-安装并配置依赖"><a href="#1-1-1-安装并配置依赖" class="headerlink" title="1.1.1 安装并配置依赖"></a>1.1.1 安装并配置依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br></pre></td></tr></table></figure><p>然后安装Postfix来启动邮件提醒功能。（如果你使用了第三方的邮件服务，可以跳过这一步并且参照<a href="https://docs.gitlab.com/omnibus/settings/smtp.html" target="_blank" rel="noopener">配置外部SMTP服务器</a>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y postfix</span><br></pre></td></tr></table></figure><p>在接下来的配置过程中，选择’Internet Site’选项。使用你的服务器的域名来作为’mail name’。如果还有后续的选项，输入Enter直至安装完成。</p><h3 id="1-1-2-安装Gitlab-EE"><a href="#1-1-2-安装Gitlab-EE" class="headerlink" title="1.1.2 安装Gitlab-EE"></a>1.1.2 安装Gitlab-EE</h3><p>添加Gitlab Package仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure><blockquote><p>注意这里安装的是CE版本，故是gitlab-ce，企业版对应的是gitlab-ee</p></blockquote><p>接下来安装Gitlab：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo EXTERNAL_URL=<span class="string">"http://gitlab.example.com"</span> apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><p>这里的EXTERNAL_URL是你的Gitlab服务要使用的域名。如果你只使用http，或者后续要使用已有的Nginx，可以在这里使用http。如果使用https，gitlab会调用<a href="https://letsencrypt.org" target="_blank" rel="noopener">Let’s encrtpy</a>的服务为你的网站添加ssl证书。</p><h3 id="1-1-3-登录Gtilab"><a href="#1-1-3-登录Gtilab" class="headerlink" title="1.1.3 登录Gtilab"></a>1.1.3 登录Gtilab</h3><p>进入你在安装阶段的域名，你会被重定向到密码重置界面。在这个页面你要设置管理员账户的密码，然后回到登录界面。在这个登录界面，使用<code>root</code>用户名和上一步设置的密码登录。</p><h2 id="1-2-使用已有的Nginx"><a href="#1-2-使用已有的Nginx" class="headerlink" title="1.2 使用已有的Nginx"></a>1.2 使用已有的Nginx</h2><p>这个章节我们参考<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#using-a-non-bundled-web-server" target="_blank" rel="noopener">官方文档</a>给出使用已有的Nginx的方法。</p><h3 id="1-2-1-禁用Gitlab自带的Nginx"><a href="#1-2-1-禁用Gitlab自带的Nginx" class="headerlink" title="1.2.1 禁用Gitlab自带的Nginx"></a>1.2.1 禁用Gitlab自带的Nginx</h3><p>编辑<code>/etc/gitlab/gitlab.rb</code>文件，设置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx[<span class="string">'enable'</span>] = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-设置外部服务器的用户"><a href="#1-2-2-设置外部服务器的用户" class="headerlink" title="1.2.2 设置外部服务器的用户"></a>1.2.2 设置外部服务器的用户</h3><p>这一步是为了保证外部服务器用户能够访问gitlab。使用Nginx时，可以通过<code>/etc/nginx/nginx.conf</code>文件查看到nginx用户。一般情况下这个用户名是<code>www-data</code>。修改<code>/etc/gitlab/gitlab.rb</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web_server[<span class="string">'external_users'</span>] = [<span class="string">'www-data'</span>]</span><br></pre></td></tr></table></figure><p>然后使用<code>sudo gitlab-ctl reconfigure</code>来使得更改生效。</p><h3 id="1-2-3-Trusted-proxies"><a href="#1-2-3-Trusted-proxies" class="headerlink" title="1.2.3 Trusted proxies"></a>1.2.3 Trusted proxies</h3><p>如果你的反向代理服务器和gitlab不是在同一台机器上，那么你还需要设置Trusted proxies。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[<span class="string">'trusted_proxies'</span>] = [<span class="string">'192.168.1.0/24'</span>, <span class="string">'192.168.2.1'</span>, <span class="string">'2001:0db8::/32'</span>]</span><br></pre></td></tr></table></figure><h3 id="1-2-4-Nginx示例配置文件"><a href="#1-2-4-Nginx示例配置文件" class="headerlink" title="1.2.4 Nginx示例配置文件"></a>1.2.4 Nginx示例配置文件</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab socket 文件地址</span></span><br><span class="line"><span class="attribute">upstream</span> gitlab &#123;</span><br><span class="line">  <span class="comment"># 7.x 版本在此位置</span></span><br><span class="line">  <span class="comment"># server unix:/var/opt/gitlab/gitlab-rails/tmp/sockets/gitlab.socket;</span></span><br><span class="line">  <span class="comment"># 8.0 位置</span></span><br><span class="line">  <span class="attribute">server</span> unix:/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> *:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">server_name</span> gitlab.example.com;   <span class="comment"># 请修改为你的域名</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">server_tokens</span> <span class="literal">off</span>;     <span class="comment"># don't show the version number, a security best practice</span></span><br><span class="line">  <span class="attribute">root</span> /opt/gitlab/embedded/service/gitlab-rails/public;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Increase this if you want to upload large attachments</span></span><br><span class="line">  <span class="comment"># Or if you want to accept large git objects over http</span></span><br><span class="line">  <span class="attribute">client_max_body_size</span> <span class="number">250m</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># individual nginx logs for this gitlab vhost</span></span><br><span class="line">  <span class="attribute">access_log</span>  /var/log/gitlab/nginx/gitlab_access.log;</span><br><span class="line">  <span class="attribute">error_log</span>   /var/log/gitlab/nginx/gitlab_error.log;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="comment"># serve static files from defined root folder;.</span></span><br><span class="line">    <span class="comment"># @gitlab is a named location for the upstream fallback, see below</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html <span class="variable">$uri</span>.html <span class="variable">@gitlab</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># if a file, which is not found in the root folder is requested,</span></span><br><span class="line">  <span class="comment"># then the proxy pass the request to the upsteam (gitlab unicorn)</span></span><br><span class="line">  <span class="attribute">location</span> <span class="variable">@gitlab</span> &#123;</span><br><span class="line">    <span class="comment"># If you use https make sure you disable gzip compression</span></span><br><span class="line">    <span class="comment"># to be safe against BREACH attack</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">300</span>; <span class="comment"># Some requests take more than 30 seconds.</span></span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">300</span>; <span class="comment"># Some requests take more than 30 seconds.</span></span><br><span class="line">    <span class="attribute">proxy_redirect</span>     <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-Proto https;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host              <span class="variable">$http_host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP         <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For   <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Frame-Options   SAMEORIGIN;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://gitlab;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable gzip compression as per rails guide: http://guides.rubyonrails.org/asset_pipeline.html#gzip-compression</span></span><br><span class="line">  <span class="comment"># WARNING: If you are using relative urls do remove the block below</span></span><br><span class="line">  <span class="comment"># See config/application.rb under "Relative url support" for the list of</span></span><br><span class="line">  <span class="comment"># other files that need to be changed for relative url support</span></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ ^/(assets)/</span>  &#123;</span><br><span class="line">    <span class="attribute">root</span> /opt/gitlab/embedded/service/gitlab-rails/public;</span><br><span class="line">    <span class="comment"># gzip_static on; # to serve pre-gzipped version</span></span><br><span class="line">    <span class="attribute">expires</span> max;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control public;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># error_page 502 /502.html;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-迁移"><a href="#2-迁移" class="headerlink" title="2 迁移"></a>2 迁移</h1><h2 id="2-1-备份"><a href="#2-1-备份" class="headerlink" title="2.1 备份"></a>2.1 备份</h2><p>迁移首先要做的是备份。在<a href="https://blog.csdn.net/ouyang_peng/article/details/77070977" target="_blank" rel="noopener">git学习——&gt; Gitlab如何进行备份恢复与迁移？</a>这篇文章中详细讲述了备份的问题。我们这里介绍的是最为直接和简单的步骤。如果要更加详细的信息请阅读这篇参考。</p><p>备份使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure><p>备份会生成在<code>/var/opt/gitlab/backups</code>目录下。名称类似于<code>1502357536_2017_08_10_9.4.3_gitlab_backup.tar</code>。下面这些配置信息，没有包含在backup文件里面。需要手动迁移。</p><ul><li><code>/etc/gitlab/gitlab.rb</code> 配置文件须备份</li><li><code>/var/opt/gitlab/nginx/conf</code> nginx配置文件</li><li><code>/etc/postfix/main.cfpostfix</code> 邮件配置备份</li></ul><p><img src="https://imgs.codewoody.com/uploads/big/109e8d518cabd20d26bb2bdc01feaaa0.png" alt="备份命令的执行"></p><h2 id="2-2-在目标机器上安装gitlab"><a href="#2-2-在目标机器上安装gitlab" class="headerlink" title="2.2 在目标机器上安装gitlab"></a>2.2 在目标机器上安装gitlab</h2><p>迁移过程中要求源机器和目标机器上安装的gitlab版本是相同的。如果不同，其实最好的做法是先将源机器上的gitlab升级到最新的版本。然后再生成备份。</p><p><img src="https://imgs.codewoody.com/uploads/big/fc818b279eb9b922aa4b4adbb8c8ff57.png" alt="如何查看Gitlab版本"></p><h2 id="2-3-上传备份"><a href="#2-3-上传备份" class="headerlink" title="2.3 上传备份"></a>2.3 上传备份</h2><p>使用<code>scp</code>命令将备份文件上传到目标机器的<code>/var/opt/gitlab/backups</code>。</p><blockquote><p>如果scp上传目标文件文件夹的权限不够，可以先上传到自己的home目录下，然后ssh登录到服务器使用sudo进行移动。</p></blockquote><h2 id="2-4-应用备份文件"><a href="#2-4-应用备份文件" class="headerlink" title="2.4 应用备份文件"></a>2.4 应用备份文件</h2><p>首先为了避免潜在的权限问题，将备份文件的权限设置为777</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 1502357536_2017_08_10_9.4.3_gitlab_backup.tar</span><br></pre></td></tr></table></figure><p>然后停止gitlab的相关数据连接服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br></pre></td></tr></table></figure><p>然后用下面的命令读取备份：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:restore BACKUP=1502357536_2017_08_10_9.4.3</span><br></pre></td></tr></table></figure><p>在后续出现的所有询问中输入yes，等待执行完毕，即完成了迁移过程，接下来再次启动gitlab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure><h1 id="3-删除"><a href="#3-删除" class="headerlink" title="3 删除"></a>3 删除</h1><p>下面的删除过程在Ubuntu 16上得到验证：</p><h2 id="3-1-移除gitlab服务"><a href="#3-1-移除gitlab服务" class="headerlink" title="3.1 移除gitlab服务"></a>3.1 移除gitlab服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl uninstall</span><br></pre></td></tr></table></figure><h2 id="3-2-清楚Gitlab产生的数据"><a href="#3-2-清楚Gitlab产生的数据" class="headerlink" title="3.2 清楚Gitlab产生的数据"></a>3.2 清楚Gitlab产生的数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl cleanse</span><br></pre></td></tr></table></figure><h2 id="3-3-删除Gitlab生成的系统账户"><a href="#3-3-删除Gitlab生成的系统账户" class="headerlink" title="3.3 删除Gitlab生成的系统账户"></a>3.3 删除Gitlab生成的系统账户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl remove-accounts</span><br></pre></td></tr></table></figure><h2 id="3-4-删除gitlab"><a href="#3-4-删除gitlab" class="headerlink" title="3.4 删除gitlab"></a>3.4 删除gitlab</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -P gitlab-ce</span><br></pre></td></tr></table></figure><h2 id="3-5-其他文件的删除"><a href="#3-5-其他文件的删除" class="headerlink" title="3.5 其他文件的删除"></a>3.5 其他文件的删除</h2><p>除了上述操作，Gitlab使用的其他文件夹还需要手动删除，包括：</p><ul><li><code>/opt/gitlab</code>: 包含了Gitlab的应用代码和依赖</li><li><code>/var/opt/gitlab</code>: 包含了应用的数据和配置信息(gitlab-ctl reconfigure的写入内容)</li><li><code>/etc/gitlab</code>: omnibus gitlab的配置信息。这里的文件是唯一允许你手动编辑的部分</li><li><code>/var/log/gitlab</code>: 日志文件</li></ul><p>在你完成了开始的四个步骤后，这里的四个文件夹可以安全地手动删除。</p><p>文章链接 <a href="http://www.codewoody.com/posts/25664/">http://www.codewoody.com/posts/25664/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitLab 由乌克兰程序员 Dmitriy Zaporozhets 和 Valery Sizov 开发，它由 Ruby 写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。 GitLab 被 IBM，Sony，Jülich Research Center，NASA，Alibaba，Invincea，O’Reilly Media，Leibniz-Rechenzentrum (LRZ)，CERN，SpaceX 等组织使用。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="gitlab" scheme="http://www.codewoody.com/tags/gitlab/"/>
    
      <category term="git" scheme="http://www.codewoody.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>TCP:拥堵控制</title>
    <link href="http://www.codewoody.com/posts/60823/"/>
    <id>http://www.codewoody.com/posts/60823/</id>
    <published>2018-12-05T08:01:45.000Z</published>
    <updated>2018-12-06T04:08:40.318Z</updated>
    
    <content type="html"><![CDATA[<p>网络数据包如果一次发送太多，就会造成网络拥堵；如果发送太少，就浪费了带宽，延长了通信时间。TCP 协议有一个拥堵窗口机制，负责动态调整每次发送数据包的数量。本文通俗地解释了这种算法的细节。</p><p>本文翻译自<a href="http://squidarth.com/rc/programming/networking/2018/07/18/intro-congestion.html" target="_blank" rel="noopener">Intro to Congestion Control</a><br><a id="more"></a></p><p>这个夏天，我一直在思考更好地解决网络拥塞问题的方法。在这篇文章中，我将会讨论为什么网络拥塞问题会出现，以及一些传统的解决办法。如果你有更深厚的兴趣，这个<a href="http://squidarth.com/demonstrating-congestion-control.html" target="_blank" rel="noopener">Juptier notebook</a>包含了我用来获取相应结果的代码，以及对这些结果的分析。</p><h2 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h2><p>在我们开始正文讨论之前，我来先简要介绍一些信息在网络上流通的细节。</p><p><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">TCP</a>协议被用来将信息从一台电脑经过英特网传输给另一台电脑。这个协议也是这篇文章所关注的协议。把TCP协议同其他协议（如UDP）区分开来的特征是，TCP确保了100%的传输成功率。也就是说如果你从一台电脑上发送了100kb的数据，那么你会在接收端准确地收到这100kb的数据。</p><p>TCP的这个特性非常强大，而这一特性也是很多网络应用采用TCP协议的原因。现有的Web应用和Email都是构筑于TCP协议之上。</p><p>TCP实现所有数据的可靠传输的核心原理是，对于从A端发送到B端的数据，B端会发送回一个ACK(Acknowlegement)信息给A端来告知自己收到了对应的信息。</p><p><img src="https://imgs.codewoody.com/uploads/big/425ffff00e7427abb333fbfe203f54fe.png" alt="TCP传输"></p><p>另外还值得注意的是，TCP工作在IP协议之上，IP协议最多允许在一个包中包含1500个字节的数据，因此要发送100kb的数据，需要拆分成多个分段。根据TCP协议，每个分段都会收到对应的ACK。</p><p>如果发送者没有收到一个数据分段的ACK，其会重新发送这个分段。</p><h2 id="什么时候会还产生拥塞"><a href="#什么时候会还产生拥塞" class="headerlink" title="什么时候会还产生拥塞"></a>什么时候会还产生拥塞</h2><p>拥塞（Congestion）问题是由于网络传输延时导致的。信息传输速率会收到物理信道，如以太网线，蜂窝网络等，的制约。在因特网中，大部分独立设备都连接到这些信道上。</p><p>下图是一个典型场景：</p><p><img src="https://imgs.codewoody.com/uploads/big/41a5dc5f5cc16669201e09c56522c2e6.png" alt="拥塞产生的场景"></p><p>在上面的示意图中，两个发送者要各自要传输1GB的数据。然而这两个发送者最终接入到了一个1GB的链接中。第二个链接的传输能力无法匹配上前两个链接的输入，故而不得不丢弃一部分数据包。如果发送者不主动调整自己的发送速度，那么会产生非常坏的情况。在TCP协议中，如果发送者发现一个数据分段没有送达，会重新发送这个数据包。那么拥塞情况会持续，两个发送者会无法完成发送过程。</p><p>为了让两个发送者能够成功传输各自的数据，他们需要共同减少发送数据的速率。如果只有一个发送者减少了发送的数据，而另一个仍然维持1GB的发送量，那么仍然会产生拥塞。在因特网的架构中，不会有一个中央控制系统来协调两者的发送速率。</p><h2 id="迂回：什么是链接-link-？"><a href="#迂回：什么是链接-link-？" class="headerlink" title="迂回：什么是链接(link)？"></a>迂回：什么是链接(link)？</h2><p>在我们深入到这个问题的解决方案前，我还想进一步讨论链接（link）的属性。关于网络链接，有下面三个重要的细节问题你需要知道：</p><ul><li>延时（毫秒）：一个包从链接的一端发送到另一端需要的时间</li><li>带宽（mb/s）：链接每秒能够通过的比特数</li><li>队列：在链接正在工作时，等候发送包的队列的长度，以及在队列满时管理队列的策略</li></ul><p>如果把链接比喻成水管，那么延时可以理解为管道的长度，带宽就是水管的周长。</p><p><img src="https://imgs.codewoody.com/uploads/big/3f08678913f4a2d53eebcbc0d9f483b2.png" alt="链接模型"></p><p>关于链接还有一个重要的统计参数时带宽延时积（bandwidth-delay product, BDP）。这个参数表现了体现了停留在链接中的数据量，可以理解为管道本身的容量。当链接中传输的数据量达到了BDP时，就可以说链接被充分利用了。如果发送端尝试发送比BDP更多的数据，那么链接的队列将会填满，并最终开始丢包。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在给出方法之前，我们要思考一个问题：发送者如何知道产生了拥塞呢？如同我们之前提到的，因特网是一个分布式的系统，故而并没有一个位于中央的协调者来在下游链接产生拥塞的时候提醒发送者要减慢发送速度。</p><p>主要有两个指标：<strong>丢包率</strong>和<strong>传输往返时间</strong>。在拥塞发生时，链接的队列逐渐填满，开始发生丢包。如果一个发送者注意到了丢包现象，这就很可能意味着发生了丢包。另一个队列满负荷的现象是数据包在队列中等待的时间增加了，这会导致传输往返时间，即发送包到收到ACK的时间增加。</p><p>今天的一些拥塞控制机制考虑了上面两个指标，不过在一些比较早期的设计中，只使用到了丢包率这一个指标。</p><p>还需要注意的是，发送者可能并不提前知道传输链接的特性参数。例如，如果你访问”<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>“，那么你发送的数据包可能要经过很多不同性质的链接才能到达Google的服务器，而你的传输速率是收到其中最慢的链接的制约的。</p><p>因此，出了规避网络拥塞的能力，拥塞控制机制还需要能够探索可用带宽的具体大小。</p><h2 id="拥塞窗口（Congestion-Window）"><a href="#拥塞窗口（Congestion-Window）" class="headerlink" title="拥塞窗口（Congestion Window）"></a>拥塞窗口（Congestion Window）</h2><p>理解任何拥塞控制机制的关键在于理解拥塞窗口的概念。拥塞窗口指的是在收到一个ACK前发送者能发送的包的数量。如果一个发送者的拥塞窗口被设置为2，这意味着在发送了两个包之后，它必须等到接收端回复的ACK之后才能继续发送。</p><p>拥塞窗口越大，发送者就能在相通的时间间隔内向接收端发送更多的数据包。为了更加直观的理解，假设网络传输的延时是88ms，拥塞窗口设置为10，那么在一轮往返传输（88 * 2 = 176ms）时间内可以发送10个数据包。而如果拥塞窗口设置为20，则相同的时间间隔内可以发送20个数据包。</p><p>不过当然，提升拥塞窗口的大小，也会提高发生拥塞的概率。拥塞控制算法的目标，就是计算出合适的拥塞窗口大小。</p><p>从理论角度来看，拥塞窗口的大小应当就是链接的BDP。</p><h2 id="TCP-Tahoe"><a href="#TCP-Tahoe" class="headerlink" title="TCP Tahoe"></a>TCP Tahoe</h2><p>TCP Tahoe是在80年代设计出来的拥塞控制算法。那是拥塞问题才刚刚在因特网上出现。算法本身非常简单。增加拥塞窗口分为两个阶段：</p><p><strong>第一阶段： Slow Start</strong>：算法的开始状态是Slow Start。在这个阶段拥塞窗口在每收到一个ACK就增加1。这种机制有效地在每轮往返传输成功后，将拥塞窗口的大小翻倍。如果拥塞窗口的大小是4，那么在同时会有4个包在传输路途中。当每个包的ACK返回时，拥塞窗口加一，即当这四个包的ACK都收到后，拥塞窗口会翻倍成为8。这个过程会一直持续到拥塞窗口达到阈值，<code>ssthresh</code>。</p><p><strong>第二阶段：Congestion Avoidance</strong>：当拥塞窗口达到阈值<code>ssthresh</code>时，进入Congestion Avoidance阶段。在这一阶段，每轮往返传输后拥塞窗口加一。也就是说，在上面的例子中，当所有4个包的ACK收到后，拥塞窗口只会加1. 在这个阶段拥塞窗口的大小会大大减小。</p><p>当Tahoe检测到丢包后，会把<code>ssthresh</code>设置为当前拥塞窗口的一半，然后将拥塞窗口设置为1，算法重新回到Slow Start阶段。</p><h3 id="丢包检测与快速重传"><a href="#丢包检测与快速重传" class="headerlink" title="丢包检测与快速重传"></a>丢包检测与快速重传</h3><p>TCP发送端有两种方法来检测丢包现象：</p><ol><li>发送端超时。发送端会给每个发送出去的数据包设置一个超时。如果在超时时限达到时尚未收到该包的ACK，则认为发生丢包，并重传改数据包，将拥塞窗口设置为1.</li><li>接受者发送回重复的ACK。在TCP中，接收端只会接收按照顺序发送的包。如果收到了不合顺序的包，接收端会返回他收到的最后一个符合顺序的包的ACK。例如，接收端收到了1，2，3，其后又收到了包5，那么接收端会再次回复3的ACK。在Tahoe中，如果发送端检测到重复的ACK，就意味着发生了丢包。这种机制被称为快速重传(Fast Retransmit)，因为这种机制不一定要等待到传输超时。</li></ol><h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>在开头提到的<a href="http://squidarth.com/demonstrating-congestion-control.html" target="_blank" rel="noopener">Jupitor Notebook</a>中，我实现了Tahoe，下图是拥塞窗口随着时间变化的曲线：</p><p><img src="https://imgs.codewoody.com/uploads/big/5e69012dbb6b7ebb8e7d137e0d70bf61.png" alt="Tahoe的拥塞窗口曲线"></p><p>注意到上图的中变化曲线存在锯齿形的行为。开始的突增为Slow-Start阶段，后面的平缓部分为Congestion Avoidance阶段。急遽掉落到1则是由于丢包导致的。</p><h3 id="为什么Tahoe要如此工作？"><a href="#为什么Tahoe要如此工作？" class="headerlink" title="为什么Tahoe要如此工作？"></a>为什么Tahoe要如此工作？</h3><p>Tahoe在工作过程中不断增加拥塞门限的原因是因为网络条件会随着时间不断变化。例如如果另一个发送者开始在同一个信道上发送数据，这会导致可用带宽的降低，其他的发送者需要按照实际情况调整。相反，如果有一个发送者停止发送数据了，可用带宽会增加，这也需要其他发送者根据实际情况来调整。</p><p>这种方法其实还是存在很多问题，这也是Tahoe目前已经基本没人使用了。特别的，Tahoe需要很长的时间，尤其是在高带宽网络上，才能全面有效地利用可用带宽。这是因为在拥塞窗口增长到Slow Start门限以后，其增长就变得非常缓慢了。</p><p>另外一个问题是，发生丢包并不一定意味着网络发生了拥塞，例如Wifi信道下，本身信道就是可能发送丢失的。对于丢包产生剧烈的将拥塞窗口砍到1并不总是合适的做法。</p><p>最后一个问题是，Tahoe使用丢包这个因子来作为判断是否发生丢包的依据。然而由于拥塞发生了丢包，此时调整拥塞窗口已经太晚了。</p><h2 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h2><p>80年代以后，涌现了不少新的算法来解决上面这些问题。我会在将来的文章中详细讨论这些方法：</p><ol><li><p>CUBIC：这个算法在2005年实现，目前是Linux系统的默认拥塞控制算法。如同Tahoe，这个CUBIC也是用丢包作为判断拥塞是否发生的依据。不同的是，CUBIC在高带宽网络下的性能要远高于Tahoe。不同于Tahoe在每一轮往返传输后将拥塞窗口增加1的做法，CUBIC如同其名，使用一个立方函数来确定窗口大小，从而实现拥塞窗口的快速增长。</p></li><li><p>BBR(Bufferbloat)：这是最近才被Google提出的新的算法。不同于CUBIC和Tahoe，这个算法使用延时来作为判断拥塞是否发生的标识。这背后的思路是延时是拥塞在导致丢包前就能起作用的判断因子。在实际丢包发生前就开始减少发送速率能够带来更高的吞吐率。</p></li></ol><h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><p>在研究拥塞控制算法时，一个有意思的问题是考虑不同的算法对于同一网络链接上的各个发送者是否公平。如果一个算法在发生拥塞时，没有缩减发送规模，而是按照之前相同的速率继续发送，那么这个算法就是不公平的。在<a href="http://squidarth.com/demonstrating-congestion-control.html#Low-Bandwidth,-1-Fixed-Window,-1-Tahoe" target="_blank" rel="noopener">这个结果</a>中，如果同一个链接上 有一个发送者没有采用拥塞窗口控制，而另一个发送者使用Tahoe。从结果可以看到，在一分钟的时间内，Tahoe发送者几乎没法发送任何数据，因为它没有机会增加它的拥塞窗口。而固定窗口的发送者全占了发送信道。</p><p>尽管固定窗口发送者是一个不好的情形，这种算法可能具有对其他的算法的不公平地位，从而占据更多带宽。由于缺乏中央控制这，可能有贪婪的发送者蓄意采用固定窗口来谋取更大的带宽。这就是需要从博弈论的角度来研究拥塞控制算法了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>拥塞控制算法是互联网的基础，同时也是在有限信息条件下进行分布式决策的一种迷人的实践。</p><p>文章链接 <a href="http://www.codewoody.com/posts/60823/">http://www.codewoody.com/posts/60823/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络数据包如果一次发送太多，就会造成网络拥堵；如果发送太少，就浪费了带宽，延长了通信时间。TCP 协议有一个拥堵窗口机制，负责动态调整每次发送数据包的数量。本文通俗地解释了这种算法的细节。&lt;/p&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;http://squidarth.com/rc/programming/networking/2018/07/18/intro-congestion.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Intro to Congestion Control&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="形而上" scheme="http://www.codewoody.com/categories/%E5%BD%A2%E8%80%8C%E4%B8%8A/"/>
    
    
      <category term="翻译" scheme="http://www.codewoody.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="网络" scheme="http://www.codewoody.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="http://www.codewoody.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Make|自动生成依赖关系</title>
    <link href="http://www.codewoody.com/posts/56042/"/>
    <id>http://www.codewoody.com/posts/56042/</id>
    <published>2018-12-03T08:44:33.000Z</published>
    <updated>2018-12-03T14:24:39.030Z</updated>
    
    <content type="html"><![CDATA[<p>Make一般是在Unix环境下使用的自动化编译工具。他本身不是编译器，而是将众多C/C++源文件组织起来，确定其编译方式和编译顺序的工具。一旦我们写好的Makefile配置文件，那么无论多么复杂的工程我们都可以用一条make命令来解决。事实上，尽管通常和C/C++搭配起来使用，make也能应用到其他的编程语言之中。</p><p>在使用make过程中的第一个核心问题是处理文件依赖的问题。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c defs.h       # foo模块</span><br><span class="line">cc -c -g foo.c</span><br></pre></td></tr></table></figure><p>这里<code>foo.o</code>依赖于<code>foo.c</code>和<code>defs.h</code>。当后面两个文件发生变化时，make会自动运行<code>cc -c -g foo.c</code>命令更新<code>foo.o</code>文件。但是，随着项目扩大。这种文件之间的依赖关系会变得非常复杂，一个小的改动可能会涉及到众多依赖关系的修改。因此有必要在项目的开始就引入自动构建依赖关系的工具链。<a id="more"></a></p><p>在<a href="http://wiki.ubuntu.org.cn/跟我一起写Makefile:书写规则" target="_blank" rel="noopener">跟我一起写Makefile:书写规则</a>这篇教程中，提到了编译器的一个特性：大多数的C/C++编译器都支持一个”-M”的选项，即自动寻找源文件中包含的头文件，并生成一个依赖关系。例如如果我们执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure><p>其输出是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c defs.h</span><br></pre></td></tr></table></figure><blockquote><p>注意如果你用的是GNU的C/C++编译器，你得用”-MM”参数，不然，”-M”参数会把一些标准库头文件也引入进来。</p></blockquote><p>这篇教程里面详细阐述了如果在Makefile中使用这一特性的方法，综合而来就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 对于每个.c源文件，建立一个描述其依赖关系的.d依赖文件</span><br><span class="line">%.d: %.c</span><br><span class="line">@set -e; rm -f $@; \</span><br><span class="line">         $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \</span><br><span class="line">         sed &apos;s,\($*\)\.o[ :]*,\1.o $@ : ,g&apos; &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">         rm -f $@.$$$$</span><br></pre></td></tr></table></figure><blockquote><p>上述命令中<code>sed</code>命令的作用是在依赖关系对中，在左侧加上.d文件本身。即<br>将<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; main.o: main.c defs.h</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>转换成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; main.o main.d : main.c defs.h</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>然后将生成的依赖关系文件<code>include</code>进来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line">include $(sources:.c=.d)</span><br></pre></td></tr></table></figure><p>在教程中还提到，这个<code>include</code>要放在默认目标之后，避免include载入的文件的目标替换了默认目标。</p><p>走完上面的流程，会得到一个类似的如下内容的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%.d: %.c</span><br><span class="line">@set -e; rm -f $@; \</span><br><span class="line">         $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \</span><br><span class="line">         sed &apos;s,\($*\)\.o[ :]*,\1.o $@ : ,g&apos; &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">         rm -f $@.$$$$</span><br><span class="line"></span><br><span class="line">sources = main.c foo.c bar.c</span><br><span class="line">objs = $(sources:.c=.o)</span><br><span class="line">include $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line">main: $(objs)</span><br><span class="line">    $(CC) -o main $(objs)</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean:</span><br><span class="line">    @rm -f *.d *.o</span><br><span class="line">    @rm -f ./main</span><br></pre></td></tr></table></figure><p>不过按照这个<code>Makefile</code>第一次执行的时候会产生一个问题：第一次执行时，.d文件尚未生成，这里的<code>include</code>导入的文件不存在，会产生如下的错误信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Makefile:8: main.d: No such file or director</span><br><span class="line">make: *** No rule to make target 'main.d'.  Stop.</span><br></pre></td></tr></table></figure><p>最后是通过面向google的debug找到了<a href="http://scottmcpeak.com/autodepend/autodepend.html" target="_blank" rel="noopener">Autodependencies with GNU make</a>这篇2001年的文章，细致地阐述了这个问题。解决的关键在于在include前面添加一个dash（-），其作用是：如果include的对象不存在，make继续执行，后续make会自动生成.d文件，然后执行include。这篇新的教程提供的完整Makefile示例如下（和前面的形式有不同，但是思路是一致的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJS := foo.o bar.o</span><br><span class="line"></span><br><span class="line"># link</span><br><span class="line">proggie: $(OBJS)</span><br><span class="line">gcc $(OBJS) -o proggie</span><br><span class="line"></span><br><span class="line"># pull in dependency info for *existing* .o files</span><br><span class="line">-include $(OBJS:.o=.d)</span><br><span class="line"></span><br><span class="line"># compile and generate dependency info</span><br><span class="line">%.o: %.c</span><br><span class="line">gcc -c $(CFLAGS) $*.c -o $*.o</span><br><span class="line">gcc -MM $(CFLAGS) $*.c &gt; $*.d</span><br><span class="line"></span><br><span class="line"># remove compilation products</span><br><span class="line">clean:</span><br><span class="line">rm -f proggie *.o *.d</span><br></pre></td></tr></table></figure><p>文章链接 <a href="http://www.codewoody.com/posts/56042/">http://www.codewoody.com/posts/56042/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Make一般是在Unix环境下使用的自动化编译工具。他本身不是编译器，而是将众多C/C++源文件组织起来，确定其编译方式和编译顺序的工具。一旦我们写好的Makefile配置文件，那么无论多么复杂的工程我们都可以用一条make命令来解决。事实上，尽管通常和C/C++搭配起来使用，make也能应用到其他的编程语言之中。&lt;/p&gt;
&lt;p&gt;在使用make过程中的第一个核心问题是处理文件依赖的问题。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo.o : foo.c defs.h       # foo模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cc -c -g foo.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;foo.o&lt;/code&gt;依赖于&lt;code&gt;foo.c&lt;/code&gt;和&lt;code&gt;defs.h&lt;/code&gt;。当后面两个文件发生变化时，make会自动运行&lt;code&gt;cc -c -g foo.c&lt;/code&gt;命令更新&lt;code&gt;foo.o&lt;/code&gt;文件。但是，随着项目扩大。这种文件之间的依赖关系会变得非常复杂，一个小的改动可能会涉及到众多依赖关系的修改。因此有必要在项目的开始就引入自动构建依赖关系的工具链。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="make" scheme="http://www.codewoody.com/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>关于无神论者的笑话两则</title>
    <link href="http://www.codewoody.com/posts/39480/"/>
    <id>http://www.codewoody.com/posts/39480/</id>
    <published>2018-11-29T06:37:50.000Z</published>
    <updated>2018-11-30T07:27:56.974Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>一个坚定的无神论者去世了，突然发现自己在一个昏暗的过道里。过道里有一个牌子，上写“通向地狱”。没办法，那就进地狱吧。他开门进去，几乎不敢相信自己的眼睛：阳光明媚，暖风宜人，白沙滩，棕榈树，每一百米一个酒吧，到处都是欢快的人们。他沿着沙滩漫步，突然发现一个长着马脚和尾巴的家伙坐在一个沙滩躺椅里。他走上前去问，你是魔鬼吗？魔鬼回答说是，并热烈欢迎新人到地狱。不久，想了解一下地狱的无神论者，两个沙包之间看到一个很大很深的坑，便好奇地往里看，结果吓坏了：坑底烧着熊熊大火，到处是哭天喊地的人，撒了疯的怪物披头盖脸地往人身上打。 无神论者疑惑地跑回魔鬼身边，痛心地问：后边沙包那里那个坑是怎么回事？魔鬼说：噢，他们哪，都是基督徒。他们非要这样，我也没什么办法……</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>一个忠诚的共产党员死了，上帝不愿意在天堂接受无神论者的灵魂，于是把他送到地狱。一个月后，魔鬼大汗淋漓跑来说“你赶紧把那人带走吧，他差不多把我所有小鬼都发展成了少先队员！” 上帝就接受了。</p><p>又过了一月，魔鬼幸灾乐祸地问上帝“那共产党员怎样了？”上帝说：“首先请叫我同志”</p><hr><p>非常惭愧，只讲了两个微小的笑话，谢谢大家</p><p>来源：<a href="https://www.zhihu.com/question/27030419/answer/121040045" target="_blank" rel="noopener">https://www.zhihu.com/question/27030419/answer/121040045</a></p><p>文章链接 <a href="http://www.codewoody.com/posts/39480/">http://www.codewoody.com/posts/39480/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/1cdc9cba5755c5d3658d280a46b7f01a.png&quot; alt=&quot;cover&quot;&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="宗教" scheme="http://www.codewoody.com/tags/%E5%AE%97%E6%95%99/"/>
    
  </entry>
  
  <entry>
    <title>酵素</title>
    <link href="http://www.codewoody.com/posts/25658/"/>
    <id>http://www.codewoody.com/posts/25658/</id>
    <published>2018-11-22T04:08:40.000Z</published>
    <updated>2018-11-22T04:11:01.298Z</updated>
    
    <content type="html"><![CDATA[<p>今天在朋友们的群里又看到有朋友在谈论吃酵素的事情。这让我想到了2017年二月，我去东京交流访问，参观了日本最大的酵素生产商之一：<a href="https://ssl.nakahara2001.co.jp" target="_blank" rel="noopener">中原株式会社</a>。有意思的是，这家公司虽然是日本的公司，却是中国人创立的。之所以公司的名字叫做中原，是因为创始人是郑州人。当时接待我们的人中，有一个负责做产品研发的生物博士，筑波大学毕业，也是中国人。他带我们参观了公司总部顶楼的一个小型的检测间。有一个随行的朋友很实诚地问道：“酵素这个东西到底有没有用。”那名生物学博士倒也没直接回答，而是笑着说：”大家都是学工科的，都懂“。<a id="more"></a></p><p>酵素这个东西，其实就是酶的另一种说法。吃酵素的风气，也是从日本舶来的。不过在日本那边，酵素是作为”保健食品的“，因此，在酵素包装上面，是不能声称任何疗效的。日本的酵素从业者，不得不利用各种渠道在宣传刊物上宣传酵素成分的一些益处（还不能直接说产品），然后在包装上注明这些成分，以此来吸引消费者购买。不过在中国，法规不是这么健全，因此中国的酵素商家，宣传起酵素功效来，宛如过去街头卖大力丸一般，怎么牛逼怎么来。</p><p><img src="https://imgs.codewoody.com/uploads/big/f25d396eef1857959956a7772a3c52b7.jpg" alt="某厂商的酵素宣传"></p><p>其实，酵素就是酶，也就是蛋白质，进入到肠胃，也都被分解成氨基酸，和鸡蛋，肉类无异。故，吃酵素还不如吃鸡蛋，同等营养的情况下，鸡蛋更便宜。</p><p>文章链接 <a href="http://www.codewoody.com/posts/25658/">http://www.codewoody.com/posts/25658/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在朋友们的群里又看到有朋友在谈论吃酵素的事情。这让我想到了2017年二月，我去东京交流访问，参观了日本最大的酵素生产商之一：&lt;a href=&quot;https://ssl.nakahara2001.co.jp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中原株式会社&lt;/a&gt;。有意思的是，这家公司虽然是日本的公司，却是中国人创立的。之所以公司的名字叫做中原，是因为创始人是郑州人。当时接待我们的人中，有一个负责做产品研发的生物博士，筑波大学毕业，也是中国人。他带我们参观了公司总部顶楼的一个小型的检测间。有一个随行的朋友很实诚地问道：“酵素这个东西到底有没有用。”那名生物学博士倒也没直接回答，而是笑着说：”大家都是学工科的，都懂“。
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="智商税" scheme="http://www.codewoody.com/tags/%E6%99%BA%E5%95%86%E7%A8%8E/"/>
    
  </entry>
  
  <entry>
    <title>macOS绕过SIP安全机制限制的一种办法</title>
    <link href="http://www.codewoody.com/posts/36948/"/>
    <id>http://www.codewoody.com/posts/36948/</id>
    <published>2018-11-21T06:08:18.000Z</published>
    <updated>2018-11-22T03:42:27.376Z</updated>
    
    <content type="html"><![CDATA[<br><a href="https://support.apple.com/en-us/HT204899" target="_blank" rel="noopener">SIP(System Security Protection)</a>是苹果在OSX EI Capitan及其后版本的操作系统中引入了一种新的安全机制。望文生义就可以看出，这个安全机制是用来维持系统的完整性，保护系统免收恶意软件的篡改。具体来说，SIP限制了root账户的权限范围，限制了root用户在对一些系统保护目录即其中文件的操作能力。</p><p>SIP的保护范围包括下列路径：</p><ul><li>/System</li><li>/usr</li><li>/bin</li><li>/sbin</li><li>OSX的预装应用</li></ul><p>第三方应用可以继续操作的目录包括：</p><ul><li>/Applications</li><li>/Library</li><li>/usr/local</li></ul><p>但是<strong>任何对于安全性加强都意味着对灵活性的削弱</strong>。例如，在SIP保护下，类似<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">proxychains-ng</a>的程序无法再给受保护的目录下的程序添加网络钩子(hook)。</p><blockquote><p>proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies.</p></blockquote><p>一般来说，很多解决方案都建议关闭SIP功能（例如proxychains-ng的issue中给出的方法：<a href="https://github.com/rofl0r/proxychains-ng/issues/78" target="_blank" rel="noopener"># issue78</a>）。不过这样也意味着丧失了SIP提供的保护功能。<a href="https://www.tcdw.net/post/proxychains-with-sip/" target="_blank" rel="noopener">这篇文章</a>给出了一个妥协的做法。在保留SIP的保护的同时，为保护目录下的程序应用proxychains-ng（其他类似的应用场景也可以使用这个办法）。这个解决方案的思路其实很简单：既然保护目录下的程序我们不能动，那么我们把保护目录下的程序复制一份到其他目录下运行就可以。</p><p>首先创建一个新的文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.unprotected_apps</span><br></pre></td></tr></table></figure><p>然后将这个路径添加到<code>PATH</code>环境变量的头部：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以添加到shell的配置文件中，如~/.bashrc或者~/.zshrc</span></span><br><span class="line">export PATH="~/.unprotected_apps:$PATH"</span><br></pre></td></tr></table></figure><p>然后将需要添加钩子的应用复制到这个目录下就可以了，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp $(which ssh) ~/usr/bin/ssh</span><br><span class="line">cp $(which curl) ~/usr/bin/curl</span><br></pre></td></tr></table></figure><p>文章链接 <a href="http://www.codewoody.com/posts/36948/">http://www.codewoody.com/posts/36948/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://support.apple.com/en-us/HT204899&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SIP(System Security Protection)&lt;/a&gt;是苹果在OSX EI Capitan及其后版本的操作系统中引入了一种新的安全机制。望文生义就可以看出，这个安全机制是用来维持系统的完整性，保护系统免收恶意软件的篡改。具体来说，SIP限制了root账户的权限范围，限制了root用户在对一些系统保护目录即其中文件的操作能力。但是&lt;strong&gt;任何对于安全性加强都意味着对灵活性的削弱&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="macOS" scheme="http://www.codewoody.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks上手配置</title>
    <link href="http://www.codewoody.com/posts/37347/"/>
    <id>http://www.codewoody.com/posts/37347/</id>
    <published>2018-11-20T08:00:57.000Z</published>
    <updated>2018-12-02T15:36:31.600Z</updated>
    
    <content type="html"><![CDATA[<p>Shadowsocks配置的一个非常便利之处在于，Shadowsocks支持将配置信息导出成二维码再在其他机器上导入。这节约了很多沟通成本。所以在开始这篇教程之前，你需要有一个Shadowsocks的配置信息。可以是具体参数，或者是一个配置二维码。<a id="more"></a></p><h2 id="1-客户端准备"><a href="#1-客户端准备" class="headerlink" title="1. 客户端准备"></a>1. 客户端准备</h2><p>Shadowsocks提供了绝大多数平台的客户端支持，甚至包括智能路由器。我们这里介绍最为常见桌面端的平台上的配置。 这里我提供了mac和win这两个主要平台截止到目前为止最新版本的客户端下载：</p><ol><li><p>macOS客户端<a href="https://query.codewoody.com/query?bucket=default&amp;resname=ShadowsocksX-NG.app.1.8.2.zip" target="_blank" rel="noopener">下载</a>;</p></li><li><p>win客户端<a href="https://query.codewoody.com/query?bucket=default&amp;resname=Shadowsocks-4.1.2.zip" target="_blank" rel="noopener">下载</a>.</p></li></ol><p>其中，mac文件下载下来解压缩后，直接拖拽进入<code>Application</code>文件夹（应用文件夹），然后双击打开使用就可以了。win端的文件解压缩后是一个可以直接运行的绿色版（不需要安装）。将解压缩文件移动到一个稳妥的位置，然后双击打开<code>Shadowsocks.exe</code>文件就可以了（此时右下角会出现一个小飞机图标）</p><blockquote><p>更加丰富的客户端下载：<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">https://shadowsocks.org/en/download/clients.html</a></p></blockquote><h2 id="2-导入配置"><a href="#2-导入配置" class="headerlink" title="2. 导入配置"></a>2. 导入配置</h2><p>写这篇文章的时候我使用的是mac，因此后面的配置方法过程都以mac为例。mac和win上客户端的使用都是相通的。不同的是小飞机图标在mac中位于顶部，而在win中位于底部。</p><p><img src="https://imgs.codewoody.com/uploads/big/4a786c9b2480fd09923f5a591e5ce51a.png" alt="ShadowsocksX-NG右键菜单截图"></p><p>右键点击小飞机图标可以看到如上图所示的菜单。其中</p><ol><li><p>第一个section中，负责控制Shadowsock的开启和关闭，我这里显示的是已经开启了Shadowsocks，如果你的客户端代理还没有启动，点击一下”打开 Shadowsocks”</p></li><li><p>第二个section中，可以设置Shadowsocks的代理模式。其中PAC模式是最为常用模式。在这种模式下，Shadowsocks会根据一张预先订好的表，来判断你当前访问的网址是否被墙了。如果是就会通过代理访问这个网站，否则照常直接连接网站就可以了。与之相对的，全局模式是让所有的网站都通过代理进行访问。</p></li><li><p>第三个section中，可以进行服务器的配置。</p><ol><li><p>如果你是使用二维码进行配置，那么，将二维码用预览打开，确保这个预览窗口位于最上层可见，然后点击菜单中的“扫描屏幕上的二维码”就可以导入服务器配置了。</p></li><li><p>如果你是使用详细配置信息进行配置，那么需要进入服务器 -&gt; 服务器设置，手动填写各个参数进行添加。</p></li></ol></li><li><p>第四个section是用来配置本地代理和PAC的，对于这部分的详细讨论超出了这篇文章的范畴，我们会在后续的文章中进行讨论。</p></li></ol><h2 id="3-手机端配置"><a href="#3-手机端配置" class="headerlink" title="3. 手机端配置"></a>3. 手机端配置</h2><p>由于政策原因，手机端APP，尤其是iOS的手机端APP的审查情况非常严重，基本上很少有APP能够长期屹立不倒。因此手机端APP的选择要实时来看。我自己使用的SuperWingy这个应用已经下架了（不过从已购里面还是可以下载的）。因此，大家发现还有什么可以用的手机端应用，就更新在评论里把。</p><p>文章链接 <a href="http://www.codewoody.com/posts/37347/">http://www.codewoody.com/posts/37347/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shadowsocks配置的一个非常便利之处在于，Shadowsocks支持将配置信息导出成二维码再在其他机器上导入。这节约了很多沟通成本。所以在开始这篇教程之前，你需要有一个Shadowsocks的配置信息。可以是具体参数，或者是一个配置二维码。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Shadowsocks" scheme="http://www.codewoody.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>开源对象存储服务(OSS) Minio 及其在Hexo中的使用</title>
    <link href="http://www.codewoody.com/posts/5440/"/>
    <id>http://www.codewoody.com/posts/5440/</id>
    <published>2018-11-16T09:33:40.000Z</published>
    <updated>2018-11-16T09:42:37.748Z</updated>
    
    <content type="html"><![CDATA[<p>研究对象存储服务(OSS)是因为考虑到将来可能会有在博客上放出一些可供分享的文件下载的服务需求，直接使用<a href="/posts/65048/">现有图床</a>，容易混杂乱。因此我考虑重新建立一个独立OSS存储服务。直接Google搜到了<a href="https://github.com/minio/minio" target="_blank" rel="noopener">Minio</a>这个框架，10k+的Star，就决定选择这个了。Minio框架有如下几个优势：</p><ul><li>可以Docker部署，非常省事</li><li>文档完善</li><li>全面的平台支持</li><li>多种客户端语言支持（有完善的JS SDK）<a id="more"></a><h2 id="1-Minio部署"><a href="#1-Minio部署" class="headerlink" title="1. Minio部署"></a>1. Minio部署</h2></li></ul><p>使用Docker部署可以说是非常方便省事了。我的部署命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker create -p 9000:9000 \</span><br><span class="line">-e <span class="string">"MINIO_ACCESS_KEY=your-access-key"</span> \</span><br><span class="line">-e <span class="string">"MINIO_SECRET_KEY=your-secret-key"</span> \</span><br><span class="line">--name=minio \</span><br><span class="line">-v /path/to/minio/data:/data \</span><br><span class="line">-v /path/to/minio/config:/root/.minio \</span><br><span class="line">minio/minio server /data</span><br></pre></td></tr></table></figure><p>其中的访问秘钥对需要替换成你自己设置的值。这一对值稍后会用于网页端的登录。然后用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start minio</span><br></pre></td></tr></table></figure><p>来启动镜像。完成后就可以在<a href="http://domain.com:9000" target="_blank" rel="noopener">http://domain.com:9000</a>中访问到了，输入docker命令中的秘钥对来登录。</p><p><img src="https://imgs.codewoody.com/uploads/big/fa25ef81a937d5b26195632cf8aff37a.png" alt="登录界面"></p><p>而后你可以按照<a href="/posts/65048/">Lychee图床教程</a>中的做法，添加Nginx反向代理和HTTPS支持。</p><h2 id="2-Hexo中使用"><a href="#2-Hexo中使用" class="headerlink" title="2. Hexo中使用"></a>2. Hexo中使用</h2><p>部署完成后我才发现一个问题，那就是Minio生成的外链是强制有过期时间的，而且长度最多只七天。那我就不能像直接复制粘贴外链来使用了，同时，手动来每七天更新一次链接也是不可接受的。因此用Hexo脚本来自动实现了利用Minio的API接口来更新下载链接。脚本内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Minio = <span class="built_in">require</span>(<span class="string">'minio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hexo = hexo || &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fs = fs || <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> yaml = yaml || <span class="built_in">require</span>(<span class="string">'js-yaml'</span>);</span><br><span class="line"><span class="keyword">var</span> minio_client  = minio_client || </span><br><span class="line">    <span class="keyword">new</span> Minio.Client(yaml.safeLoad(fs.readFileSync(__dirname + <span class="string">"/minio_key.yml"</span>, <span class="string">'utf8'</span>)));</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">'minio'</span>, <span class="keyword">async</span> (args, content) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> </span><br><span class="line">        bucket = <span class="string">'default'</span>,</span><br><span class="line">        resource_name = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        resource_name = args[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resource_name = args[<span class="number">1</span>];</span><br><span class="line">        bucket = args[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> file_url = <span class="keyword">await</span> minio_client.presignedGetObject(bucket, resource_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a target="_blank" href="<span class="subst">$&#123;file_url&#125;</span>"&gt;<span class="subst">$&#123;content&#125;</span>&lt;/a&gt;`</span>;</span><br><span class="line">&#125;, &#123;<span class="attr">async</span>: <span class="literal">true</span>, <span class="attr">ends</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>在博客工程的根目录下创建一个文件夹<code>scripts</code>,在其中创建一个js文件，如<code>index.js</code>，然后将上述脚本内容粘贴进去。然后在这个目录下创建设置文件，<code>minio_key.yml</code>，文件中需要包含如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">endPoint:</span> <span class="string">'minio.domain.com'</span></span><br><span class="line"><span class="attr">accessKey:</span> <span class="string">'your-access-key'</span></span><br><span class="line"><span class="attr">secretKey:</span> <span class="string">'your-secret-key'</span></span><br><span class="line"><span class="attr">useSSL:</span> <span class="literal">true</span>    <span class="comment"># 是否使用https</span></span><br></pre></td></tr></table></figure><p>然后还需要安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save minio</span><br></pre></td></tr></table></figure><p>至此我们完成了脚本的安装。脚本为我们提供了一个<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件</a>，其使用范例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% minio 'bucket<span class="emphasis">_name' 'resource_</span>name' %&#125;</span><br><span class="line">下载链接</span><br><span class="line">&#123;% endminio %&#125;</span><br></pre></td></tr></table></figure><p>在使用Hexo进行静态页面渲染时，这部分内容会被自动渲染成下载链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a target=&quot;_blank&quot; href=&quot;download_url&quot;&gt;下载链接&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>不过这种方法还是有一个显而易见的缺点：你需要是一个非常勤奋的作者，每周都来发布一次文章，不然旧文章的链接还是会失效。</p><p>文章链接 <a href="http://www.codewoody.com/posts/5440/">http://www.codewoody.com/posts/5440/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究对象存储服务(OSS)是因为考虑到将来可能会有在博客上放出一些可供分享的文件下载的服务需求，直接使用&lt;a href=&quot;/posts/65048/&quot;&gt;现有图床&lt;/a&gt;，容易混杂乱。因此我考虑重新建立一个独立OSS存储服务。直接Google搜到了&lt;a href=&quot;https://github.com/minio/minio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Minio&lt;/a&gt;这个框架，10k+的Star，就决定选择这个了。Minio框架有如下几个优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以Docker部署，非常省事&lt;/li&gt;
&lt;li&gt;文档完善&lt;/li&gt;
&lt;li&gt;全面的平台支持&lt;/li&gt;
&lt;li&gt;多种客户端语言支持（有完善的JS SDK）
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Hexo" scheme="http://www.codewoody.com/tags/Hexo/"/>
    
      <category term="Minio" scheme="http://www.codewoody.com/tags/Minio/"/>
    
      <category term="OSS" scheme="http://www.codewoody.com/tags/OSS/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks持续优化</title>
    <link href="http://www.codewoody.com/posts/35429/"/>
    <id>http://www.codewoody.com/posts/35429/</id>
    <published>2018-11-16T06:39:01.000Z</published>
    <updated>2018-11-16T06:39:09.344Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="Fast-TCP开启"><a href="#Fast-TCP开启" class="headerlink" title="Fast TCP开启"></a>Fast TCP开启</h2><p>如果双端都支持FastTCP，那么可以通过开启FastTCP来降低延时。服务端设置方法有两种，要门在<code>config.json</code>中添加<code>fast_open</code>为<code>true</code>，要么在执行<code>ssserver</code>带上<code>--fast-open</code>。然后在命令行中运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/net/ipv4/tcp_fastopen</span><br></pre></td></tr></table></figure><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>这个优化方法适合所有的shadowsocks版本，具体方法如下。创建文件<code>/etc/sysctl.d/local.conf</code>，并在文件中添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># max open files</span></span><br><span class="line">fs.file-max = 51200</span><br><span class="line"><span class="comment"># max read buffer</span></span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"><span class="comment"># max write buffer</span></span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"><span class="comment"># default read buffer</span></span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"><span class="comment"># default write buffer</span></span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"><span class="comment"># max processor input queue</span></span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"><span class="comment"># max backlog</span></span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># resist SYN flood attacks</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="comment"># reuse timewait sockets when safe</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="comment"># turn off fast timewait sockets recycling</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"><span class="comment"># short FIN timeout</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"><span class="comment"># short keepalive time</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"><span class="comment"># outbound port range</span></span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"><span class="comment"># max SYN backlog</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"><span class="comment"># max timewait sockets held by system simultaneously</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"><span class="comment"># turn on TCP Fast Open on both client and server side</span></span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line"><span class="comment"># TCP receive buffer</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"><span class="comment"># TCP write buffer</span></span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"><span class="comment"># turn on path MTU discovery</span></span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># for high-latency network</span></span><br><span class="line">net.ipv4.tcp_congestion_control = hybla</span><br><span class="line"></span><br><span class="line"><span class="comment"># for low-latency network, use cubic instead</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_congestion_control = cubic</span></span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>应用上述设置。最后在启动脚本中，于<code>ssserver</code>前添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ulimit</span> -n 51200</span><br></pre></td></tr></table></figure><p>这个设置方法，会消耗比较多的内存，但是会换来速度的大幅上升。</p><p>文章链接 <a href="http://www.codewoody.com/posts/35429/">http://www.codewoody.com/posts/35429/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇教程提供了优化Shadowsocks性能的一些方法。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Shadowsocks" scheme="http://www.codewoody.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks：多用户账号独立，并限制用户连接数</title>
    <link href="http://www.codewoody.com/posts/7835/"/>
    <id>http://www.codewoody.com/posts/7835/</id>
    <published>2018-11-13T08:50:23.000Z</published>
    <updated>2018-11-13T14:27:05.898Z</updated>
    
    <content type="html"><![CDATA[<p>自己搭建了一个SS服务器以后，自然而然的会同身边的朋友共享。自然，身边的朋友一起用，大部分服务器配置都可以毫无压力的支撑。但倘若一传十十传百，最后成百上千的人一起用一个服务器，那就撑不住了。<br>当然你可以隔一段时间换一次密码，但是后面的麻烦事也不少（要同步更新不同设备上的设置，身边的朋友来问你新设置）。<br>几天我研究了一下，为ss服务器增加了多用户即为每个用户设置独立的连接数限制的方法，这样能够比较完美的解决同朋友共享服务器的问题了。<br><a id="more"></a></p><p>这里默认你已经知道怎么按照通常的方法安装和配置SS了。如果你不了解的话，网络上的文章很多的。</p><h2 id="1-多用户的实现"><a href="#1-多用户的实现" class="headerlink" title="1. 多用户的实现"></a>1. 多用户的实现</h2><p>多用户的实现比较简单，Python和Go实现的服务器自带多用户支持。通常的配置我们一般是这么写<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: <span class="string">"::"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>: <span class="string">"8888"</span>,</span><br><span class="line">  <span class="attr">"password"</span>: <span class="string">"yourpassword"</span></span><br><span class="line">  // Other configs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要将配置文件按照下面的方式进行修改就可以实现多用户了。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: <span class="string">"::"</span>,</span><br><span class="line">  <span class="attr">"port_password"</span>: &#123;</span><br><span class="line">    <span class="attr">"8881"</span>: <span class="string">"password1"</span>,</span><br><span class="line">    <span class="attr">"8882"</span>: <span class="string">"password2"</span>,</span><br><span class="line">    <span class="attr">"8883"</span>: <span class="string">"password3"</span></span><br><span class="line">  &#125;</span><br><span class="line">  // other configs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就可以了。之后不同的用户可以通过不同的端口访问，而每个端口都有独立的密码。</p><blockquote><p>Further Reading: <a href="https://github.com/shadowsocks/shadowsocks/wiki/Configure-Multiple-Users" target="_blank" rel="noopener">Reference</a></p></blockquote><h2 id="2-限制用户连接"><a href="#2-限制用户连接" class="headerlink" title="2. 限制用户连接"></a>2. 限制用户连接</h2><p>我在网上调查了一下实现限制用户连接的方法，很多都提到了通过<code>iptables</code>来进行设置。但是这种方法太过复杂，很容易出问题。后来我找到一个ss的补丁，可以比较好的解决这个问题。补丁地址是<a href="https://github.com/falseen/PySocket" target="_blank" rel="noopener">falssen/PySocket</a>。<br>这个工程提供了一些其他的功能，但是我们这里只关注<code>Limit_Clients</code>文件夹下的<code>socket.py</code>这个文件。这个文件的原理是利用Python包导入的机制，用自定义的<code>socket.py</code>来替换默认的<code>socket</code>包，并在<code>socket</code>接口中植入一些新的功能。<br><del>按照<code>READMe.md</code>的提示安装好<code>socket.py</code>文件</del></p><blockquote><p>有很多朋友不知道这里要怎么处理socket.py文件。其实并不复杂。用<code>which</code>命令查看一下ss脚本安装的位置，一般情况下是<code>/usr/local/bin/</code>，那么你只需要把<code>socket.py</code>文件放到<code>/usr/local/bin</code>下面就行。这一操作的原理是，python在导入包时总是先检查当前目录。注意，如果修改了<code>socket.py</code>文件，需要重启进程才能生效。</p></blockquote><p>然后修改文件中<code>white_list</code>和<code>black_list</code>两个变量。例如我自己使用的<code>1017</code>端口，我不希望添加限制，则将<code>white_list</code>设置为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">white_list = [<span class="number">1017</span>]</span><br></pre></td></tr></table></figure></p><p>我给朋友们用的是[1018]端口，我希望这个端口的连接数不要超过40个，则将<code>black_list</code>设置为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black_list = &#123;<span class="number">1018</span>:<span class="number">40</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h2><p>注意方法的实质是限制接入的客户端IP数量，因此，处在同一路由器下面的多台设备也会被识别为一台。</p><p>文章链接 <a href="http://www.codewoody.com/posts/7835/">http://www.codewoody.com/posts/7835/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己搭建了一个SS服务器以后，自然而然的会同身边的朋友共享。自然，身边的朋友一起用，大部分服务器配置都可以毫无压力的支撑。但倘若一传十十传百，最后成百上千的人一起用一个服务器，那就撑不住了。&lt;br&gt;当然你可以隔一段时间换一次密码，但是后面的麻烦事也不少（要同步更新不同设备上的设置，身边的朋友来问你新设置）。&lt;br&gt;几天我研究了一下，为ss服务器增加了多用户即为每个用户设置独立的连接数限制的方法，这样能够比较完美的解决同朋友共享服务器的问题了。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Shadowsocks" scheme="http://www.codewoody.com/tags/Shadowsocks/"/>
    
  </entry>
  
</feed>
