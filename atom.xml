<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>治部少辅</title>
  
  <subtitle>大一大万大吉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codewoody.com/"/>
  <updated>2019-06-26T15:02:26.589Z</updated>
  <id>http://www.codewoody.com/</id>
  
  <author>
    <name>Woody Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo文章置顶/置底方法研究</title>
    <link href="http://www.codewoody.com/posts/42846/"/>
    <id>http://www.codewoody.com/posts/42846/</id>
    <published>2019-06-26T14:51:15.000Z</published>
    <updated>2019-06-26T15:02:26.589Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讨论如何在Hexo中方便地实现文章置顶功能。</p><p>最初我采用了<a href="https://blog.minhow.com/2017/08/20/hexo/article-top/" target="_blank" rel="noopener">Hexo文章置顶的方法</a>。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的<code>top</code>值将文章放在末尾。因此我做了 一点修改。</p><a id="more"></a><h2 id="原始方法">原始方法</h2><p>原始方法的核心思想是在Front-Matter中添加一个自定义的<code>top</code>字段，然后在<code>hexo-generator-index</code>中使用这一字段来实现排序。具体操作为，修改文件<code>node_modules/hexo-generator-index/lib/generator.js</code>，添加 如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">        <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更改后的完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">var</span> path = config.index_generator.path || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的front-matter中添加top字段。top值越大，则文章越靠前。top值一样的文章则根据日期排序。front-matter设置的一个例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo文章置顶方法研究</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-06</span><span class="bullet">-26</span> <span class="number">22</span><span class="string">:51:15</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">教程</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">MinHow</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">博客</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">开源项目</span></span><br><span class="line"><span class="attr">cover_picture:</span> <span class="attr">https://cloud.minhow.com/images/miho/theme/github-second.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="解决置底的问题">解决“置底”的问题</h2><p>无法置底的原因很简单，即在上面的js代码修改中，没有设置top值的文章的top变量是未定义的，且规定未定义top的文章总是比定义了top值的文章要靠后。我们赋予未定义top值的文章一个默认的0值，即可解决这个问题的。具体的操作是将修改代码内容替换成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = first.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = second.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">      <span class="keyword">return</span> b - a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> second.date - first.date</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讨论如何在Hexo中方便地实现文章置顶功能。&lt;/p&gt;
&lt;p&gt;最初我采用了&lt;a href=&quot;https://blog.minhow.com/2017/08/20/hexo/article-top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo文章置顶的方法&lt;/a&gt;。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的&lt;code&gt;top&lt;/code&gt;值将文章放在末尾。因此我做了 一点修改。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 1</title>
    <link href="http://www.codewoody.com/posts/25582/"/>
    <id>http://www.codewoody.com/posts/25582/</id>
    <published>2019-06-26T06:05:17.000Z</published>
    <updated>2019-06-27T14:59:20.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="so-whats-this">So what's this</h2><p>每周我都会读阮一峰的每周分享，有时候也会在其他的博客平台上看见别的博主整理的这些每周资源分享文章，觉得比较有用，我也打算整理一下自己的List。</p><p>最近一年多以来，我尝试尽可能将自己的思考过程以文字的方式记录下来，这样过几天回头来看，便于我整理思路。更重要的是，这种累积会给自己带来沉甸甸的“积累感”，给自己一个强大正反馈。</p><p>这篇是这一系类的每周分享的第一篇，贵在坚持！</p><a id="more"></a><h2 id="新闻">新闻</h2><h3 id="b站三体动画化">B站三体动画化</h3><p><a href="https://passport.weibo.com/visitor/visitor?entry=miniblog&amp;a=enter&amp;url=https%3A%2F%2Fweibo.com%2F1748075785%2FHAJ5ZiuBT&amp;domain=.weibo.com&amp;ua=php-sso_sdk_client-0.6.28&amp;_rand=1561603056.2875" target="_blank" rel="noopener">B站正式宣布《三体》动画化启动</a>: 作为重磅彩蛋，刘慈欣现身B站十周年活动现场。动画由B站出品、三体宇宙和制作方艺画开天联合出品。活动现场首播的概念版PV淋漓尽致地展现三体宇宙的宏大和黑暗森林法则的残酷。</p><blockquote><p>之前在B站上自己组团队做了三体动画（Minecraft版）的神游八方，也加入了动画化的主创团队。</p></blockquote><ul><li><a href="https://www.bilibili.com/3/" target="_blank" rel="noopener">专题页面</a></li></ul><h3 id="人民网联合腾讯网易等游戏公司发起游戏适龄提示倡议"><a href="https://finance.sina.com.cn/roll/2019-06-27/doc-ihytcitk8046473.shtml" target="_blank" rel="noopener">人民网联合腾讯、网易等游戏公司发起《游戏适龄提示倡议》</a></h3><p>6月26日，人民网联合腾讯、网易、完美世界等10家头部游戏公司发起《游戏适龄提示倡议》，把游戏玩家分成4个年龄层级，并提出了相应的提示体系，包括游戏内容、类型和运营等方面的标准。年龄分层方面，此次倡议把游戏玩家分为18+、16+、12+、6+四级。例如6+多是休闲益智类，18+则有大量竞技、策略、棋牌类游戏。</p><figure><img src="https://imgs.codewoody.com/uploads/big/9ecb92ae01cbca2fc5d9909793357417.jpg" alt="分级标准"><figcaption>分级标准</figcaption></figure><blockquote><p>之前听老梁说的好，文化审查领域重要的是“自由裁量权”，而并不是挂在口头上的细枝末节的审查细节。没有分级制度，那么我想让你过你就能过，不让你过，你就不能过，随心所欲，岂不快哉？</p><p>&quot;在国民党统治时期，制定了一个新闻法，我们共产党人仔细研究它的字句，抓它的辫子，钻它的空子。现在我们当权，我看还是不要新闻法好，免得人家钻我们空子。没有法，我们主动，想怎样控制就怎样控制。&quot; -- 陈云 （孙旭培教授曾在《新闻立法之路》一文中引述）</p></blockquote><p>Further Reading：<a href="http://www.midphoto.com/chinese/whatsnew/2016/lawofnews.htm" target="_blank" rel="noopener">为什么中国没有新闻法</a>(<a href="/knowledge-base/backups/为什么中国没有新闻法.md">Backup Link</a>)</p><h2 id="典故与梗">典故与梗</h2><p><strong>不作安安饿殍，效尤奋臂螳螂</strong></p><p>这句话，我一直理解反了意思。开始我以为是指不愿意做饿死鬼，即便是螳臂当车也要起来反抗的意思。结果，其原意是完全相反的。</p><p><a href="https://www.zhihu.com/question/68212300" target="_blank" rel="noopener">这句话出自顾诚的《明末农民战争史》的注释中</a>:</p><blockquote><p>【22】谈迁：《北游录》，《纪闻上》，《榜购一词》条。按：此条首云“总督杨文岳嗣昌出师，榜辑剧寇张献忠”，杨嗣昌字文弱，谈迁误为文岳，又称之为总督，遂与明保定总督杨文岳混为一人。杨复吉《梦阑琐笔》载此事时更写成“保督杨文岳出师榜缉张献忠”，均误。又杨氏所载词中“兴安、平利走四方”一句作“兴安、平利走东乡”。李馥荣：《滟滪囊》卷一所载杨嗣昌榜刊《西江月》词句为：“<strong>不作安安饿殍，效尤奋臂螳螂</strong>。往来楚蜀肆猖狂，弄兵潢池无状。云屯雨骤师集，蛇豕奔突奚藏？许尔军民绑来降，爵赏酬功上上。”或系杨嗣昌所刊另一榜文。</p></blockquote><p>这句话的意思是，尔等不安安静静地做一个饿死鬼，却效仿螳臂当车，自不量力（抵抗朝廷的剿灭大军）。当然，这句话可能并非杨总督本人所说，只是文人调侃他所做。不过，这句话透出的想法，杨总督脑子里大抵是有的，只不过要脸，不好说出来。对于这些统治者来捉，有这样的想法，其实不足为奇。但是，偏偏就有一些明明遇到乱世就会沦为“饿殍”的人，摆不正自己的位置。</p><p>历代造反的贫民，从陈胜吴广，到李自成，洪秀全，诚然造成了巨大的破坏，但若是不造反，又有什么活路呢？难道，做安安饿殍么？</p><h2 id="情绪">情绪</h2><p><strong>Youtube博主Etika自杀</strong></p><figure><img src="https://imgs.codewoody.com/uploads/big/b05fd2ee2db8d5adb14afe276509fe43.jpg" alt="Etika"><figcaption>Etika</figcaption></figure><p>2019年6月19日，Etika上传了一段疑似自杀宣言的视频，他背起书包，离开了家门。至此以后，没有人再看到Etika的任何踪迹。</p><p>6月22日，警方发现了Etika被遗弃的个人物品，在高达340英尺的大桥之上。</p><p>6月25日，纽约警方在布鲁克林大桥水域发现一具未明身份的男性遗体。今日，警方发布正式公告，遗体确为Etika本人，死因是自杀。</p><figure><img src="https://imgs.codewoody.com/uploads/big/d136781dd7e96199bc4f3697a7ccf46a.jpg" alt="网友在Etika自杀地的悼念"><figcaption>网友在Etika自杀地的悼念</figcaption></figure><blockquote><p>有很多极度抑郁的人以至于要自杀的人，有时候看起来会很开心的样子。永远不要以为自己有多么了解一个人，尤其是一个你没有那么熟悉，甚至是陌生的人。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;so-whats-this&quot;&gt;So what&#39;s this&lt;/h2&gt;
&lt;p&gt;每周我都会读阮一峰的每周分享，有时候也会在其他的博客平台上看见别的博主整理的这些每周资源分享文章，觉得比较有用，我也打算整理一下自己的List。&lt;/p&gt;
&lt;p&gt;最近一年多以来，我尝试尽可能将自己的思考过程以文字的方式记录下来，这样过几天回头来看，便于我整理思路。更重要的是，这种累积会给自己带来沉甸甸的“积累感”，给自己一个强大正反馈。&lt;/p&gt;
&lt;p&gt;这篇是这一系类的每周分享的第一篇，贵在坚持！&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="http://www.codewoody.com/categories/weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="weekly" scheme="http://www.codewoody.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>Python下的音频处理库librosa打开文件是显示NoBackendError的解决</title>
    <link href="http://www.codewoody.com/posts/40199/"/>
    <id>http://www.codewoody.com/posts/40199/</id>
    <published>2019-06-26T04:56:10.000Z</published>
    <updated>2019-06-26T05:24:00.597Z</updated>
    
    <content type="html"><![CDATA[<p>近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。 <a id="more"></a></p><p>由于我的程序中只采用了<code>librosa.load</code>这个命令，通过源代码可以发现librosa实际上是用<code>audioread</code>这个库的<code>audioread.audio_open</code>来读取音频文件的。这个函数的源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_open</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">"""Open an audio file using a library that is available on this</span></span><br><span class="line"><span class="string">    system.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Standard-library WAV and AIFF readers.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> rawread</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> rawread.RawAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Core Audio.</span></span><br><span class="line">    <span class="keyword">if</span> _ca_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> macca</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> macca.ExtAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GStreamer.</span></span><br><span class="line">    <span class="keyword">if</span> _gst_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> gstdec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> gstdec.GstAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MAD.</span></span><br><span class="line">    <span class="keyword">if</span> _mad_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> maddec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> maddec.MadAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FFmpeg.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> ffdec</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ffdec.FFmpegAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># All backends failed!</span></span><br><span class="line">    <span class="keyword">raise</span> NoBackendError()</span><br></pre></td></tr></table></figure><p>可见之前我们遇到的NoBackendError就是这里的最后一行抛出的了，由于我安装的FFmpeg，进一步进入ffdec.py这个文件中。不难发现实际打开文件的是下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">popen_multiple</span><span class="params">(commands, command_args, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Like `subprocess.Popen`, but can try multiple commands in case</span></span><br><span class="line"><span class="string">    some are not available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `commands` is an iterable of command names and `command_args` are</span></span><br><span class="line"><span class="string">    the rest of the arguments that, when appended to the command name,</span></span><br><span class="line"><span class="string">    make up the full first argument to `subprocess.Popen`. The</span></span><br><span class="line"><span class="string">    other positional and keyword arguments are passed through.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i, command <span class="keyword">in</span> enumerate(commands):</span><br><span class="line">        cmd = [command] + command_args</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> subprocess.Popen(cmd, *args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">if</span> i == len(commands) - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># No more commands to try.</span></span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>这里的<code>commands</code>是直接传入的第33行的<code>COMMANDS</code>变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>我这里倒腾了好几下，最终发现实际是错误的原因是没有找到ffmpeg这个命令。我们在这里将ffmpeg替换成ffmpeg的绝对路径。你可以通过下面这行命令找到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ffmpeg</span><br></pre></td></tr></table></figure><p>最终我改成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'/usr/bin/ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>Boom！一切就工作正常了。这么想起来应该是安装ffmpeg的时候的环境变量有问题，导致在command line方式下调用ffmpeg命令出错吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。
    
    </summary>
    
      <category term="debug" scheme="http://www.codewoody.com/categories/debug/"/>
    
    
      <category term="debug" scheme="http://www.codewoody.com/tags/debug/"/>
    
      <category term="python" scheme="http://www.codewoody.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Latex中各种各样的箭头</title>
    <link href="http://www.codewoody.com/posts/13297/"/>
    <id>http://www.codewoody.com/posts/13297/</id>
    <published>2019-06-24T01:52:42.000Z</published>
    <updated>2019-06-24T02:19:58.271Z</updated>
    
    <content type="html"><![CDATA[<p>Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。 <a id="more"></a></p><h2 id="默认箭头">默认箭头</h2><p>这里的默认指你不需要任何额外的<code>usepackage</code>就可以使用：</p><!-- ![默认箭头](https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png) --><img src="https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png" width="60%"><figcaption>默认箭头</figcaption><h2 id="amssymb提供的箭头">amssymb提供的箭头</h2><p>需要<code>\usepackage{amssymb}</code></p><!-- ![amssymb箭头](https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png) --><img src="https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png" width="60%"><figcaption>amssymb箭头</figcaption><h2 id="further-reading">Further Reading</h2><p><a href="http://www.sascha-frank.com/Arrow/latex-arrows.html" target="_blank" rel="noopener">LaTeX arrows</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="latex" scheme="http://www.codewoody.com/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>部署Pritunl来使用OpenVPN</title>
    <link href="http://www.codewoody.com/posts/23676/"/>
    <id>http://www.codewoody.com/posts/23676/</id>
    <published>2019-06-13T06:16:27.000Z</published>
    <updated>2019-06-13T07:04:39.437Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="why-vpn">Why VPN</h2><p>为什么要使用VPN？尤其是，为什么个人用户需要使用VPN呢？其实如果你只有一台电脑，其实一般用不上VPN（当然，用VPN来翻墙另说），如果你有多个电脑，甚至是服务器，这些服务器的网络情况还比较复杂，而你希望随时随地方便地访问这些机器，那么建立VPN虚拟网络将这些机器连接起来就能极大的方便访问过程。例如，如果一台服务器是在路由器后面，没有公网IP，与其在路由器上配置复杂的端口映射表，不如通过VPN网络自由地访问各个端口。又例如在一些特定的场景下，一些服务器的低位（1024以下）端口的访问会收到限制，这个也可以同VPN来解决。</p><p>当然，还有可能，你处于校园网中，而你通过种种途径有了一个无限流量服务器，通过VPN，可以让你在校园网场景下能够随时通过这台服务器上网，从而免去流量费用。另外，将这一宝贵资源分享给同学使用，用VPN也非常方便。</p><h2 id="why-pritunl">Why Pritunl</h2><p>我试过很多VPN方案，例如PPTP，OpenVPN，IPSec等等。其实使用VPN过程中的一个痛点在于用户管理要尽可能方便，虽然我也比较多的在用命令行工具，但是使用命令行工具去管理用户体验还是非常差。Pritunl提供了OpenVPN的网页GUI管理界面。这也是我为什么推荐使用Priunl的原因。而且，Pritunl中免费用户就可以使用无数量限制的账户和设备，这对于个人用户来说足够了。</p><p>另一方面，Pritunl的客户端支持也非常全面</p><h2 id="how-to-deploy">How to deploy</h2><h3 id="installation">Installation</h3><p>官方文档在这里: <a href="https://docs.pritunl.com/docs/installation" target="_blank" rel="noopener">Installation</a>。事实上按照官方文档的推荐，Pritunl最好部署在企业级的Linux OS上，如Red Hat, Oracle Linux, CentOS等。不过对于个人用户，对于性能，稳定性和安全性要求没有那么严格的情况下，用Debian系的系统也未尝不可。我的Pritunl服务器就是部署在Ubuntu上的，几个月使用下来，性能和稳定性都非常好。</p><p>对于不同版本的系统，安装脚本不同。例如，Ubuntu 16.04，安装脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list &lt;&lt; EOF</span><br><span class="line">deb https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.0 multiverse</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo tee /etc/apt/sources.list.d/pritunl.list &lt;&lt; EOF</span><br><span class="line">deb http://repo.pritunl.com/stable/apt xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 9DA31620334BD75D9DCB49F368818C72E52529D4</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 7568D9BB55FF9E5287D586017AE645C0CF8E292A</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get --assume-yes install pritunl mongodb-org</span><br><span class="line">sudo systemctl start pritunl mongod</span><br><span class="line">sudo systemctl enable pritunl mongod</span><br></pre></td></tr></table></figure><h3 id="configuration">Configuration</h3><p>在安装完Pritunl之后，访问服务器的443端口，即可以看到配置引导界面。</p><figure><img src="https://imgs.codewoody.com/uploads/big/04288b446ec0e7ad27b790dd4890d71b.png" alt="配置界面"><figcaption>配置界面</figcaption></figure><p>其中需要输入的主要是第一项Setup Key。数据库部分，如果你是使用上面的脚本安装的话，那么Pritunl服务本机上就已经安装运行了MongoDB，这里第二个配置MongoDB URI就不需要变动。要获取Setup Key，ssh进入部署服务器，运行<code>pritunl setup-key</code>即可.</p><p>完成这一步设置以后就来到管理员登录界面：</p><figure><img src="https://imgs.codewoody.com/uploads/big/5310344dc5cd485d83835f900fdf38df.png" alt="管理员登录界面"><figcaption>管理员登录界面</figcaption></figure><p>初始时用户名和密码都是<code>pritunl</code>，在完成第一次登录之后会被要求修改管理员的用户名和密码：</p><figure><img src="https://imgs.codewoody.com/uploads/big/88164d6b435cfb64cc84a35bd6188235.png" alt="修改密码"><figcaption>修改密码</figcaption></figure><h2 id="further-reading">Further Reading</h2><p>Pritunl的使用方法非常直观，文档可以参见<a href="https://docs.pritunl.com/docs/connecting" target="_blank" rel="noopener">Connecting</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/0f3a766a78effb06b6770d8a61ad2e55.png&quot; alt=&quot;Pritunl&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="vpn" scheme="http://www.codewoody.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Linux下OpenVPN客户端配置</title>
    <link href="http://www.codewoody.com/posts/38823/"/>
    <id>http://www.codewoody.com/posts/38823/</id>
    <published>2019-05-17T02:46:41.000Z</published>
    <updated>2019-05-17T03:21:20.760Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.codewoody.com/uploads/big/cb54becbed976afbcd2d21733fcf85c6.png" alt="OpenVPN"> <a id="more"></a></p><h2 id="环境配置">环境配置</h2><p>安装OpenVPN的方法很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn</span><br></pre></td></tr></table></figure><h2 id="使用方法">使用方法</h2><p>首先你需要从OpenVPN服务提供商那里得到<code>*.ovpn</code>配置文件，然后在服务器上运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openvpn --config your.ovpn</span><br></pre></td></tr></table></figure><p>不过这个命令会在前台运行，当我们退出SSH之后就会终止。为了让OpenVPN能够在后台运行，且能够自动开机启动，我们需要借助于Systemctl的帮助。首先我们将ovpn文件复制到<code>/etc/openvpn/client/</code>下，<strong>将后缀直接修改为<code>.conf</code></strong>。如果配置文件需要我们手动输入密码，我们需要将密码以配置文件的形式固定下来，不然自动启动会失败。在<code>/etc/openvpn/client/</code>新建一个<code>account.txt</code>文件，在其中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username</span><br><span class="line">password</span><br></pre></td></tr></table></figure><blockquote><p>有些OpenVPN服务端工具只会生成密码（例如Pritunl），在这里username可以随意输入一个，然后在下面一行添加密码。</p></blockquote><p>然后进入配置文件，找到<code>auth-user-pass</code>。默认情况下这个配置条目后面是空的，我们将其修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth-user-pass /etc/openvpn/client/account.txt</span><br></pre></td></tr></table></figure><p>假设前面我们复制过来的配置文件的名字为<code>default.conf</code>。输入下面的命令以启用这个vpn：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn-client@default</span><br></pre></td></tr></table></figure><p>要启动这个vpn，使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvpn-client@default</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/cb54becbed976afbcd2d21733fcf85c6.png&quot; alt=&quot;OpenVPN&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
      <category term="vpn" scheme="http://www.codewoody.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib in Virtualenv</title>
    <link href="http://www.codewoody.com/posts/30912/"/>
    <id>http://www.codewoody.com/posts/30912/</id>
    <published>2019-05-16T05:56:36.000Z</published>
    <updated>2019-05-16T06:19:13.484Z</updated>
    
    <content type="html"><![CDATA[<p>我使用的是macOS系统。当在虚拟环境中尝试使用matplotlib时，会出现如下的报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of &apos;python&apos; with &apos;pythonw&apos;. See &apos;Working with Matplotlib on OSX&apos; in the Matplotlib FAQ for more informatio</span><br></pre></td></tr></table></figure><a id="more"></a><p>根据错误信息，要么我们使用Python as Framework，要么我们更换使用的后端（backend）。Matplot专门就matplotlib的后端问题有一个网页：<a href="https://matplotlib.org/faq/virtualenv_faq.html" target="_blank" rel="noopener">Working with Matplotlib in Virtual environments</a>。文章中提到，<code>Tk</code>这个框架（即<code>TkAgg</code>后端）一般来说总是可用的，不需要额外的外部依赖。（不过在特定的Linux发行版本中可能需要安装<code>python-tk</code>）。要使用<code>Tk</code>需要做如下配置过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">"TkAgg"</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>每次这么配置比较麻烦，我们可以通过<code>~/.matplotlib/matplitlibrc</code>文件来固化配置（如果这个文件不存在可以手动创建），文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backend: TkAgg</span><br></pre></td></tr></table></figure><p>不过我在使用过程中发现使用<code>TkAgg</code>时会出现系统级的错误，抛出了<code>Terminating app due to uncaught exception</code>的错误。因此我尝试替换成其他后端。我主要选择包括：</p><figure><img src="https://imgs.codewoody.com/uploads/big/bdd0f72aede5a20bf5378bc373287e55.png" alt="Matplotlib可用后端类型"><figcaption>Matplotlib可用后端类型</figcaption></figure><p>而又因为<code>PySide</code>只支持比较早的python版本，因此我选择了Qt5作为后端。在这之前，我们需要安装下面的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install qt</span><br><span class="line">pip install PySide2</span><br></pre></td></tr></table></figure><p>安装完成后配置过程和<code>TkAgg</code>的类似，后端的名字为<code>QT5Agg</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我使用的是macOS系统。当在虚拟环境中尝试使用matplotlib时，会出现如下的报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ImportError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of &amp;apos;python&amp;apos; with &amp;apos;pythonw&amp;apos;. See &amp;apos;Working with Matplotlib on OSX&amp;apos; in the Matplotlib FAQ for more informatio&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="debug" scheme="http://www.codewoody.com/tags/debug/"/>
    
      <category term="python" scheme="http://www.codewoody.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ns3 在模块中使用第三方库</title>
    <link href="http://www.codewoody.com/posts/53831/"/>
    <id>http://www.codewoody.com/posts/53831/</id>
    <published>2019-05-12T12:47:21.000Z</published>
    <updated>2019-05-12T13:31:18.615Z</updated>
    
    <content type="html"><![CDATA[<p>ns3使用了waf编译系统，因此在ns3中尝试引入第三方模块时，就没有make那么直接了。</p><a id="more"></a><p>其实思路的核心还是想办法最终为编译器提供<code>-L</code>和<code>-I</code>的设置。这个过程我们通过<code>wscript</code>中的<code>configure</code>函数来实现。这里我们假设模块使用的库的位置放在模块源码目录下的<code>libs</code>子目录。库的名字为<code>example-lib</code>。目录结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libs</span><br><span class="line">└── example-lib</span><br><span class="line">  ├── include</span><br><span class="line">  └── libexample-lib.a</span><br></pre></td></tr></table></figure><p>其中，<code>include</code>文件夹内为头文件，<code>libexample-lib.a</code>为静态库文件。</p><p>修改<code>wscript</code>文件中的configure函数，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(conf)</span>:</span></span><br><span class="line">    root_dir = conf.path.abspath()</span><br><span class="line">    example_lib_dir = os.path.join(root_dir, <span class="string">"libs/example-lib"</span>)</span><br><span class="line">    conf.env.append_value(<span class="string">"LINKFLAGS"</span>, </span><br><span class="line">        [<span class="string">"-L%s/"</span> % example_lib_dir])</span><br><span class="line">    conf.env.append_value(<span class="string">"LIB"</span>, [<span class="string">"example-lib"</span>])</span><br><span class="line">    conf.env.append_value(<span class="string">"CPPFLAGS"</span>, </span><br><span class="line">        [<span class="string">"-I%s/include"</span> % example_lib_dir, ])</span><br></pre></td></tr></table></figure><p>修改<code>configure</code>函数之后要重新运行<code>./waf configure</code>命令来让设置生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ns3使用了waf编译系统，因此在ns3中尝试引入第三方模块时，就没有make那么直接了。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>ns3 wscript: 自动寻找需编译的源文件</title>
    <link href="http://www.codewoody.com/posts/3426/"/>
    <id>http://www.codewoody.com/posts/3426/</id>
    <published>2019-05-11T08:19:17.000Z</published>
    <updated>2019-05-15T05:15:05.307Z</updated>
    
    <content type="html"><![CDATA[<p>在ns3的编译体系中，每个module会包含一个名为wscript的python脚本来提供编译信息。例如，一个通过<code>create-module.py</code>创建的module中的wscript为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def options(opt):</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def configure(conf):</span></span><br><span class="line"><span class="comment">#     conf.check_nonfatal(header_name='stdint.h', define_name='HAVE_STDINT_H')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(bld)</span>:</span></span><br><span class="line">    module = bld.create_ns3_module(<span class="string">'example-module'</span>, [<span class="string">'core'</span>])</span><br><span class="line">    module.source = [</span><br><span class="line">        <span class="string">'model/example-module.cc'</span>,</span><br><span class="line">        <span class="string">'helper/example-module-helper.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    module_test = bld.create_ns3_module_test_library(<span class="string">'example-module'</span>)</span><br><span class="line">    module_test.source = [</span><br><span class="line">        <span class="string">'test/example-module-test-suite.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    headers = bld(features=<span class="string">'ns3header'</span>)</span><br><span class="line">    headers.module = <span class="string">'example-module'</span></span><br><span class="line">    headers.source = [</span><br><span class="line">        <span class="string">'model/example-module.h'</span>,</span><br><span class="line">        <span class="string">'helper/example-module-helper.h'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bld.env.ENABLE_EXAMPLES:</span><br><span class="line">        bld.recurse(<span class="string">'examples'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bld.ns3_python_bindings()</span></span><br></pre></td></tr></table></figure><p>其中，<code>module.source</code>中包含需要编译的<code>.cc</code>源文件，而<code>headers.source</code>中包含对应的头文件。每次新建C++源代码文件时，都需要手动添加到这里的列表中。下面我给出一个自动从<code>module</code>的<code>model</code>, <code>helper</code>目录下搜索源文件的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def options(opt):</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def configure(conf):</span></span><br><span class="line"><span class="comment">#     conf.check_nonfatal(header_name='stdint.h', define_name='HAVE_STDINT_H')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_list_sources</span><span class="params">(bld, suffix)</span>:</span></span><br><span class="line">    root_dir = bld.path.abspath()</span><br><span class="line">    res = [</span><br><span class="line">        x <span class="keyword">for</span> x <span class="keyword">in</span> </span><br><span class="line">            [os.path.join(<span class="string">"model"</span>, y) <span class="keyword">for</span> y <span class="keyword">in</span> os.listdir(os.path.join(root_dir, <span class="string">"model"</span>))]</span><br><span class="line">        <span class="keyword">if</span> x.endswith(suffix)</span><br><span class="line">    ]</span><br><span class="line">    res += [</span><br><span class="line">        x <span class="keyword">for</span> x <span class="keyword">in</span> </span><br><span class="line">            [os.path.join(<span class="string">"helper"</span>, y) <span class="keyword">for</span> y <span class="keyword">in</span> os.listdir(os.path.join(root_dir, <span class="string">"helper"</span>))]</span><br><span class="line">        <span class="keyword">if</span> x.endswith(suffix)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(bld)</span>:</span></span><br><span class="line">    module = bld.create_ns3_module(<span class="string">'example-module'</span>, [<span class="string">"core"</span>])</span><br><span class="line">    module.source = _list_sources(bld, <span class="string">".cc"</span>)</span><br><span class="line"></span><br><span class="line">    module_test = bld.create_ns3_module_test_library(<span class="string">'example-module'</span>)</span><br><span class="line">    module_test.source = [</span><br><span class="line">        <span class="string">'test/mix-autonomy-test-suite.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    headers = bld(features=<span class="string">'ns3header'</span>)</span><br><span class="line">    headers.module = <span class="string">'example-module'</span></span><br><span class="line">    headers.source = _list_sources(bld, <span class="string">".h"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bld.env.ENABLE_EXAMPLES:</span><br><span class="line">        bld.recurse(<span class="string">'examples'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bld.ns3_python_bindings()</span></span><br></pre></td></tr></table></figure><blockquote><p>注意不要直接套用上面的范例文件，需要将&quot;example-module&quot;的名字改为你的module的名字</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在ns3的编译体系中，每个module会包含一个名为wscript的python脚本来提供编译信息。例如，一个通过&lt;code&gt;create-module.py&lt;/code&gt;创建的module中的wscript为&lt;/p&gt;
&lt;figure class=&quot;highlight py
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线原理</title>
    <link href="http://www.codewoody.com/posts/50553/"/>
    <id>http://www.codewoody.com/posts/50553/</id>
    <published>2019-05-10T02:38:26.000Z</published>
    <updated>2019-05-10T03:03:53.812Z</updated>
    
    <content type="html"><![CDATA[</p><p>这是一篇<a href="https://www.cnblogs.com/hnfxs/p/3148483.html" target="_blank" rel="noopener">转载文章</a>。Bézier curve(贝塞尔曲线)是应用于二维图形应用程序的数学曲线。 曲线定义：起始点、终止点（也称锚点）、控制点。通过调整控制点，贝塞尔曲线的形状会发生变化。 1962年，法国数学家Pierre Bézier第一个研究了这种矢量绘制曲线的方法，并给出了详细的计算公式，因此按照这样的公式绘制出来的曲线就用他的姓氏来命名，称为贝塞尔曲线。</p><h2 id="抛物线三切线定理">抛物线三切线定理</h2><p>设<span class="math inline">\(P_0\)</span>，<span class="math inline">\(P_0^2\)</span>，<span class="math inline">\(P_2\)</span>是一跳抛物线上顺序不同的三个点。过<span class="math inline">\(P_0\)</span>和<span class="math inline">\(P2\)</span>的切线交于<span class="math inline">\(P_1\)</span>。过<span class="math inline">\(P_0^2\)</span>的切线交<span class="math inline">\(P_0 P_1\)</span>和<span class="math inline">\(P_2 P_1\)</span>相交于<span class="math inline">\(P_0^1\)</span>和<span class="math inline">\(P_1^1\)</span>，则有如下比例成立：</p><p><span class="math display">\[\begin{equation}\frac{P_{0} P_{0}^{1}}{P_{0}^{1} P_{1}}=\frac{P_{1} P_{1}^{1}}{P_{1}^{1} P_{2}}=\frac{P_{0}^{1} P_{0}^{2}}{P_{0}^{2} P_{1}^{1}}\end{equation}\]</span></p><figure><img src="https://imgs.codewoody.com/uploads/big/c6362fee9c4a8ffabc786c7b8c37a826.gif" alt="抛物线三切线定理示意图"><figcaption>抛物线三切线定理示意图</figcaption></figure><p>此即为抛物线的三切线定理。</p><h2 id="二次贝塞尔曲线">二次贝塞尔曲线</h2><p>当<span class="math inline">\(P_0\)</span>，<span class="math inline">\(P_2\)</span>固定时，引入参数<span class="math inline">\(t\)</span>，令上述比例值为<span class="math inline">\(t:(1-t)\)</span>，即有：</p><p><span class="math display">\[\begin{equation}\begin{array}{l}{P_{0}^{1}=(1-t) P_{0}+t P_{1}} \\ {P_{1}^{1}=(1-t) P_{1}+t P_{2}} \\ {P_{0}^{2}=(1-t) P_{0}^{1}+t P_{1}^{1}}\end{array}\end{equation}\]</span></p><p>将第一，二个式子代入第三个有：</p><p><span class="math display">\[\begin{equation}P_{0}^{2}=(1-t)^{2} P_{0}+2 t(1-t) P_{1}+t^{2} P_{2}\end{equation}\]</span></p><p>当<span class="math inline">\(t\)</span>从0变到1时，<span class="math inline">\(P_0^2\)</span>点经过的轨迹即为上图中的抛物线，也即为由三顶点<span class="math inline">\(P_0\)</span>, <span class="math inline">\(P_1\)</span>, <span class="math inline">\(P_2\)</span>决定的一条二次贝塞尔曲线。也可以认为这条二次贝塞尔曲线是由两个前顶点<span class="math inline">\((P_0, P_1)\)</span>以及两个后顶点<span class="math inline">\((P_1, P_2)\)</span>决定的。</p><h2 id="更高阶的贝塞尔曲线">更高阶的贝塞尔曲线</h2><p>类似于二次贝塞尔曲线的推导过程，我们可以推广到更高阶的贝塞尔曲线。</p><p>由四个控制点定义的三次Bezier曲线<span class="math inline">\(P_0^3\)</span>可被定义为分别由<span class="math inline">\((P_0,P_1,P_2)\)</span>和<span class="math inline">\((P_1,P_2,P_3)\)</span>确定的二条二次Bezier曲线的线性组合，由<span class="math inline">\((n+1)\)</span>个控制点<span class="math inline">\(P_i(i=0,1,...,n)\)</span>定义的n次Bezier曲线<span class="math inline">\(P_0^n\)</span>可被定义为分别由前、后<span class="math inline">\(n\)</span>个控制点定义的两条<span class="math inline">\((n-1)\)</span>次Bezier曲线<span class="math inline">\(P_0^{n-1}\)</span>与<span class="math inline">\(P+0^{n-1}\)</span>的线性组合：</p><p><span class="math display">\[\begin{equation}P_{0}^{n}=(1-t) P_{0}^{n-1}+t P_{1}^{n-1} \quad t \in[0,1]\end{equation}\]</span></p><p>由此可以得到Bezier曲线的踢腿计算公式</p><p><span class="math display">\[\begin{equation}P_{i}^{k}=\left\{\begin{array}{c}{P_{i}} &amp; {k=0} \\ {(1-t) P_{i}^{k-1}+t P_{i+1}^{k-1}} &amp; {k=1,2, \cdots, n, i=0,1, \cdots, n-k}\end{array}\right.\end{equation}\]</span></p><p>这就是de Castelijau算法。</p><h2 id="贝塞尔曲线原理动图">贝塞尔曲线原理动图</h2><figure><img src="https://imgs.codewoody.com/uploads/big/bcaaa9ffd59424956ecaf9bf9997ad41.gif" alt="一阶贝塞尔曲线"><figcaption>一阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/5f61dfa0ca56be6f035a7800a5be35d2.gif" alt="二阶贝塞尔曲线"><figcaption>二阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/8fad9c6df6e51bc78f83b44ee9fb65d1.gif" alt="三阶贝塞尔曲线"><figcaption>三阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/318c16114eacc2f0899fdf6f19df996b.gif" alt="四阶贝塞尔曲线"><figcaption>四阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/16bd24901ea98b88916dcbb0ead66cd7.gif" alt="五阶贝塞尔曲线"><figcaption>五阶贝塞尔曲线</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/16bd24901ea98b88916dcbb0ead66cd7.gif&quot; alt=&quot;五阶贝塞尔曲线&quot;&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.codewoody.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="processing" scheme="http://www.codewoody.com/tags/processing/"/>
    
      <category term="数学" scheme="http://www.codewoody.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Docker Volume的权限问题</title>
    <link href="http://www.codewoody.com/posts/25188/"/>
    <id>http://www.codewoody.com/posts/25188/</id>
    <published>2019-05-08T06:38:09.000Z</published>
    <updated>2019-05-15T05:08:48.691Z</updated>
    
    <content type="html"><![CDATA[<p>这里我们要解决的是使用Docker过程中常见的Volume权限问题。具体而言，当我们用<code>-v</code>将宿主机的路径绑定到Docker镜像的内部路径时，有时候会导致Docker镜像缺少对这个目录的访问权限，从而导致进程出错。</p><a id="more"></a><h2 id="why">Why</h2><p>当我们绑定宿主目录到镜像时，如果该目录不存在，Docker也会自动创建该目录。这种方式创建出来的目录的拥有者是root用户。如果该目录已经存在，那么其拥有者就取决于宿主配置的情况了。</p><p>由于Docker内部的用户空间和宿主的用户空间是独立的，如果镜像内运行进程的用户和宿主目录的拥有者不符合，就会出现权限问题。</p><h2 id="how-to-solve-it">How to solve it</h2><p>由于镜像内和宿主的用户名空间是不同的，所以通过用户名的方式来变更宿主目录的所有权会失效。然而，事实上用户系统是通过uid来标识不同的用户的，我们只需要将宿主的路径的拥护者改为镜像内用户相通的uid即可。镜像内用户的uid可以通过如下方式查看，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jovyan@8fed6b266a3c:~$ id</span><br><span class="line">uid=1000(jovyan) gid=100(users) groups=100(users)</span><br></pre></td></tr></table></figure><p>继而再修改宿主机上对应目录的拥有者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R 1000 /path/to/volume</span><br></pre></td></tr></table></figure><h2 id="further-research">Further Research</h2><p>上面的方法可以解决Volume访问权限的问题，不过会产生潜在的漏洞。从镜像内获得的uid在宿主上可能表示的是不同的用户，在宿主机上修改目录的拥有者会导致数据被同一服务器上的其他用户访问，带来安全性上的问题。</p><p>另一方面，如果有多个镜像需要共享一个Volume，而他们内部的运行用户的uid不同的话，就需要在宿主上进行更加复杂的用户以及组的配置。</p><p>更优雅的执行方法有下面两种：</p><h3 id="use-named-volume">Use Named Volume</h3><p>Named Volumes</p><h3 id="由容器自行配置权限问题">由容器自行配置权限问题</h3><h2 id="reference">Reference</h2><ol type="1"><li><a href="https://yq.aliyun.com/articles/53990" target="_blank" rel="noopener">谈谈 Docker Volume 之权限管理（一）</a></li><li><a href="https://stackoverflow.com/questions/23544282/what-is-the-best-way-to-manage-permissions-for-docker-shared-volumes?spm=a2c4e.11153940.blogcont53990.8.3421149142aS92" target="_blank" rel="noopener">What is the (best) way to manage permissions for Docker shared volumes?</a></li><li><a href="https://medium.com/@ramangupta/why-docker-data-containers-are-good-589b3c6c749e" target="_blank" rel="noopener">Why Docker Data Containers (Volumes!) are Good</a></li><li><a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">Use volumes</a></li><li><a href="https://success.docker.com/article/different-types-of-volumes" target="_blank" rel="noopener">Different Types of Volumes</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我们要解决的是使用Docker过程中常见的Volume权限问题。具体而言，当我们用&lt;code&gt;-v&lt;/code&gt;将宿主机的路径绑定到Docker镜像的内部路径时，有时候会导致Docker镜像缺少对这个目录的访问权限，从而导致进程出错。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="debug" scheme="http://www.codewoody.com/tags/debug/"/>
    
      <category term="docker" scheme="http://www.codewoody.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>读书破万卷,下笔如有神</title>
    <link href="http://www.codewoody.com/posts/60435/"/>
    <id>http://www.codewoody.com/posts/60435/</id>
    <published>2019-05-06T03:00:06.000Z</published>
    <updated>2019-05-06T06:16:16.744Z</updated>
    
    <content type="html"><![CDATA[<p>能够获得暴利的职业，都有一个共同特点：可扩展性（scaling），一次劳动可以服务成千上万的人。</p><p>软件、电影、游戏行业都具有可扩展性，作品的生产成本是固定的，但可以被消费无数次，所以有巨大的获利空间，创造出许许多多的富豪。另一方面，理发师、厨师、出租车司机一次劳动，只能服务少数几个人，就不具有可扩展性，很难获得暴利，生存得很辛苦。</p><p>最近，我读到美国一个风险投资家的<a href="https://andrewchen.co/professional-blogging/" target="_blank" rel="noopener">文章</a>。他说了一句发人深思的话：</p><p>&quot;写作是最具可扩展性的活动。你呆在家里，不去参加活动/会议，只是在网上写下自己的想法，然后你就具有了最好的可扩展性。&quot;</p><p>我想了一下，还真是这样。你写了一篇文章，想让其他人看到，只要到处张贴就行了。每次转贴，就是扩展了一次。这比其他产品的扩展容易多了。面包师傅想要更多的人尝到自己的面包，只能多开面包店；网站要扩展，只能购买更多的服务器。相比之下，文字的扩展简直是零成本。</p><p>大公司每年花费数十亿美元用于广告，以求人们关注他们的产品。但是，一个好的作家可以免费获得这种扩展性。这就是为什么你应该把自己的想法写下来的原因，这么好的免费传播渠道，为什么不用呢？你以为，写下来不会有人看。错，其实是有人会看到的，如果他们觉得有价值，就会帮你传播出去。</p><div class="note info">            <p>这篇文章转载自<a href="http://www.ruanyifeng.com/blog/2019/05/weekly-issue-54.html" target="_blank" rel="noopener">阮一峰的博客</a>。这篇文章其实说了一个非常简洁明了却价值巨大的道理，也给我们启示：我们应该如何规划自己的职业道路。只是靠出售自己的时间，即便是清北的同学，也只是能做到一个尚算富裕，但是辛苦中产阶级。要更上一层楼，还是需要手握资本。而怎么获得资本呢？其实就是靠文章里说的“可扩展性的工作”。</p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;能够获得暴利的职业，都有一个共同特点：可扩展性（scaling），一次劳动可以服务成千上万的人。&lt;/p&gt;
&lt;p&gt;软件、电影、游戏行业都具有可扩展性，作品的生产成本是固定的，但可以被消费无数次，所以有巨大的获利空间，创造出许许多多的富豪。另一方面，理发师、厨师、出租车司机一次
      
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Pandoc渲染引擎导致Hexo Tag渲染失败的临时解决办法</title>
    <link href="http://www.codewoody.com/posts/62502/"/>
    <id>http://www.codewoody.com/posts/62502/</id>
    <published>2019-04-25T06:06:21.000Z</published>
    <updated>2019-04-25T06:20:14.806Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.codewoody.com/posts/20215/">Hexo+Next: 使用Latex公式</a>这篇文章中我发现在使用<code>Pandoc</code>作为Hexo的渲染引擎时，Hexo的标签功能会有问题，具体表现为Hexo的标签内部的内容会输出markdown源码，而非渲染后的html。 <a id="more"></a></p><h2 id="问题研究">问题研究</h2><p>经过我的研究，这是因为<code>hexo-render-pandoc</code>在注册自己的<code>renderer</code>时，只注册了异步渲染的renderer，而没有注册同步渲染的renderer，而Hexo的标签中主要是用同步renderer。以当时我使用的NexT的note标签为例。其实现代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postNote</span>(<span class="params">args, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;div class="note <span class="subst">$&#123;args.join(<span class="string">' '</span>)&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;hexo.render.renderSync(&#123;text: content, engine: <span class="string">'markdown'</span>&#125;</span>).split('\n').join('')&#125;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">'note'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">hexo.extend.tag.register(<span class="string">'subnote'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>由于没有注册同步渲染器，这里的<code>hexo.render.renderSync</code>渲染会失败，从而返回的是<code>content</code>中的原本内容，也即Markdown形式的源码。</p><h2 id="解决办法">解决办法</h2><p>彻底的解决办法，自然是在<code>hexo-render-pandoc</code>中同时注册同步渲染器。不过我自己尝试之后发现作为同步渲染器，<code>pandoc</code>和Hexo使用模板引擎貌似有冲突。更细致深入的修改最好还是由原作者来进行（我已经提交了<a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/33" target="_blank" rel="noopener">Issue</a>）。</p><p>这里我给出一个临时的解决办法：既然<code>hexo-render-pandoc</code>只注册了异步渲染代码，那么我们在Tag的实现代码中调用异步渲染的接口就可以了。仍然以NexT主题的note标签为例，可以将代码修改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postNote</span>(<span class="params">args, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hexo.render.render(&#123;<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`&lt;div class="note <span class="subst">$&#123;args.join(<span class="string">' '</span>)&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;res.split(<span class="string">'\n'</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">          &lt;/div&gt;`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">// return `&lt;div class="note $&#123;args.join(' ')&#125;"&gt;</span></span><br><span class="line">  <span class="comment">//           $&#123;hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;).split('\n').join('')&#125;</span></span><br><span class="line">  <span class="comment">//         &lt;/div&gt;`;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">'note'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">hexo.extend.tag.register(<span class="string">'subnote'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>经过这样修改就可以了。不过这种方法仍然只是权宜之计，要是去修改每个Tag的实现，就太繁琐了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.codewoody.com/posts/20215/&quot;&gt;Hexo+Next: 使用Latex公式&lt;/a&gt;这篇文章中我发现在使用&lt;code&gt;Pandoc&lt;/code&gt;作为Hexo的渲染引擎时，Hexo的标签功能会有问题，具体表现为Hexo的标签内部的内容会输出markdown源码，而非渲染后的html。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Next: 使用Latex公式</title>
    <link href="http://www.codewoody.com/posts/20215/"/>
    <id>http://www.codewoody.com/posts/20215/</id>
    <published>2019-04-24T04:55:54.000Z</published>
    <updated>2019-04-25T05:27:15.577Z</updated>
    
    <content type="html"><![CDATA[<p>这次更换主题的很大一个动因就是因为在NexT这个主题上，开启Latex的支持很方便。网上关于这方面的文章其实不少，但是大部分都不全面，照本宣科下来，很可能不能用。这些教程一般就给了<code>_config.yml</code>文件的配置以及<code>pandoc</code>依赖安装，但是一些关键细节缺失了。这篇文章里我梳理了一下整个流程。 <a id="more"></a></p><h2 id="reference">0. Reference</h2><p>英语好的话，其实可以尝试直接阅读<a href="https://theme-next.org/docs/third-party-services/math-equations" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="install-dependencies">1. Install Dependencies</h2><p>Next支持<code>mathjax</code>和<code>katex</code>两种渲染方式，其中<code>katex</code>的速度更快，但是对于Latex的支持有一定的限制。所以除非你的博客数量实在是过于庞大，不然就可以直接使用<code>mathjax</code>。</p><p><code>mathjax</code>可以选用下面两种渲染引擎的中的任一一种</p><ul><li><code>hexo-renderer-kramed</code></li><li><code>hexo-render-pandoc</code></li></ul><div class="note info">            <p>使用<code>hexo-render-pandoc</code>还需要安装pandoc渲染引擎。其安装方法可以参考 <a href="http://pandoc.org/installing.html" target="_blank" rel="noopener">pandoc官网</a>。如果在macOS上可以使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>安装.</p>          </div><p>这里以<code>pandoc</code>为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要先卸载默认的渲染引擎</span></span><br><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><div class="note danger">            <p>替换渲染器之后会导致NexT note功能出现问题，note内的元素内容无法渲染，会输出markdown源代码。 这个问题我在<code>hexo-render-pandoc</code>上提了一个<a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/33" target="_blank" rel="noopener">Issue</a>，看原作者什么时候能够更新解决吧。</p>          </div><h2 id="configuration">2. Configuration</h2><p>配置NexT主题的<code>_config.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="comment">#engine: katex</span></span><br></pre></td></tr></table></figure><p>很多文章都漏掉了在配置中一个重要的信息：在主题配置<code>math</code>下有一个名为<code>per_page</code>的选项，其值为<code>true</code>或者<code>false</code>。这个选项用来控制是否对每个篇文章都渲染数学公式。默认情况下是<code>true</code>，这意味只对Front Matter中含有<code>mathjax: true</code>的文章进行公式渲染。将<code>per_page</code>设置为<code>false</code>，则会对每一篇文章都尝试进行公式渲染。</p><p>由于公式渲染时一个很费时的操作，因此还是保持默认配置，通过Front Matter进行渲染控制.</p><h2 id="how-to-use">3. How to use</h2><h3 id="行内嵌套公式">3.1 行内嵌套公式</h3><p>如：质能方程<span class="math inline">\(e=mc^2\)</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：质能方程$e=mc^2$</span><br></pre></td></tr></table></figure><h3 id="独占一行的公式">3.2 独占一行的公式</h3><p>如： <span class="math display">\[1=\sum_{i=0}^{m}\sum_{k=0}^{W_i-1}b_{i,k}=\sum_{i=0}^{m}b_{i,0}\sum_{k=0}^{W_i-1}\frac{W_i-k}{W_i}=\sum_{i=0}^{m}b_{i,0}\frac{W_i+1}{2}\\=\frac{b_{0,0}}{2}\left[W\left(\sum_{i=0}^{m-1}(2p)^i+\frac{(2p)^m}{1-p}\right) + \frac{1}{1-p}\right]\]</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">$$</span><br><span class="line">1=\sum_&#123;i=0&#125;^&#123;m&#125;\sum_&#123;k=0&#125;^&#123;W_i-1&#125;b_&#123;i,k&#125;=\sum_&#123;i=0&#125;^&#123;m&#125;b_&#123;i,0&#125;\sum_&#123;k=0&#125;^&#123;W_i-1&#125;\frac&#123;W_i-k&#125;&#123;W_i&#125;=\sum_&#123;i=0&#125;^&#123;m&#125;b_&#123;i,0&#125;\frac&#123;W_i+1&#125;&#123;2&#125;\\</span><br><span class="line">=\frac&#123;b_&#123;0,0&#125;&#125;&#123;2&#125;\left[W\left(\sum_&#123;i=0&#125;^&#123;m-1&#125;(2p)^i+\frac&#123;(2p)^m&#125;&#123;1-p&#125;\right) + \frac&#123;1&#125;&#123;1-p&#125;\right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><div class="note info">            <p>更多latex的使用方法，请参考官方文档</p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次更换主题的很大一个动因就是因为在NexT这个主题上，开启Latex的支持很方便。网上关于这方面的文章其实不少，但是大部分都不全面，照本宣科下来，很可能不能用。这些教程一般就给了&lt;code&gt;_config.yml&lt;/code&gt;文件的配置以及&lt;code&gt;pandoc&lt;/code&gt;依赖安装，但是一些关键细节缺失了。这篇文章里我梳理了一下整个流程。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>清华GPA事件备份:2019.04.16</title>
    <link href="http://www.codewoody.com/posts/34235/"/>
    <id>http://www.codewoody.com/posts/34235/</id>
    <published>2019-04-16T06:42:27.000Z</published>
    <updated>2019-04-23T08:55:08.071Z</updated>
    
    <content type="html"><![CDATA[<p>大图预警 <a id="more"></a> <img src="https://imgs.codewoody.com/uploads/big/d08181298573faecd2ad04bcdf7931dc.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大图预警
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Haproxy支持Ipv6</title>
    <link href="http://www.codewoody.com/posts/12489/"/>
    <id>http://www.codewoody.com/posts/12489/</id>
    <published>2019-04-13T08:47:20.000Z</published>
    <updated>2019-05-10T03:06:06.896Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="haproxy">Haproxy</h2><p><a href="http://www.haproxy.org/" target="_blank" rel="noopener">Haproxy is a reliable, high performance TCP/HTTP Load Balancer</a></p><p>这是官网对于Haproxy的介绍，其作用的类似于Nginx，是一个均衡负载的服务器。其相比于Nginx的好处是其代理TCP流量的功能配置起来非常的简单。我这里主要拿Haproxy来配置Shadowsocks的跳板机。</p><p>前一段时间，GFW的墙好像又加高了，很多时候在教育网外连接服务器不是很可靠。所以我考虑干脆在教育网环境下做一个跳板服务器，这样在外面可以先跳到教育网，然后再从教育网过墙。</p><p>教育网的另一个好处是有IPv6。貌似IPv6上面的拦截比较弱，而且，绝大多数的高校对于IPv6都是免流量费的。因此，我们可以从IPv4公口进，然后走IPv6出。</p><h2 id="how-to">How to</h2><p>不过，问题是通过apt安装的haproxy是<a href="https://github.com/Entware/Entware-ng/issues/426" target="_blank" rel="noopener">不支持IPv6的</a>！</p><p>我们只能自己动手从源码编译了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.haproxy.org/download/1.7/src/haproxy-1.7.2.tar.gz</span><br><span class="line">tar -xzf haproxy-1.7.2.tar.gz</span><br><span class="line">cd haproxy-1.7.2</span><br><span class="line">make TARGET=linux2626 USE_GETADDRINFO=1</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><!-- \begin{equation*}x = \sum_{i=1}^{N}x^2\end{equation*} -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;haproxy&quot;&gt;Haproxy&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.haproxy.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haproxy is a reliable, h
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Shadowsocks" scheme="http://www.codewoody.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>政史:珍珠港事件前日方决策过程梳理</title>
    <link href="http://www.codewoody.com/posts/10462/"/>
    <id>http://www.codewoody.com/posts/10462/</id>
    <published>2019-04-08T14:05:57.000Z</published>
    <updated>2019-04-10T13:36:37.978Z</updated>
    
    <content type="html"><![CDATA[<p>在知乎上看到的比较好的回答，作为备份放在这里：</p><ol type="1"><li>原文链接：<a href="https://www.zhihu.com/question/306368870/answer/639051842" target="_blank" rel="noopener">https://www.zhihu.com/question/306368870/answer/639051842</a></li><li>archive.is上的备份网页：<a href="http://archive.is/4dOL3" target="_blank" rel="noopener">http://archive.is/4dOL3</a></li></ol><a id="more"></a><figure><img src="https://imgs.codewoody.com/uploads/big/b38e3bdd40d9c4234935f6853ff6d154.jpg" alt="珍珠港俯视图（1941年10月30日）"><figcaption>珍珠港俯视图（1941年10月30日）</figcaption></figure><p>以下是原文内容：</p><p>因为再不突袭，日本人这大东亚战争就算是白打了。</p><p>咱们这里需要补充一个小知识，在20世纪30年代末，日本的能源结构是这样的：80%的石油来自美国，10%的石油来自东印度群岛，只有7%左右的石油可以自给。那么问题来了，日本从918开始折腾到40年，找到能替代美国的石油生产地了么？</p><p>没有。不仅石油高度依赖美国，铁和各种军需物资都严重依赖美国，甚至可以这么说，要是没有美国人提供的这些物资，日本这侵华战争就根本打不起来。</p><blockquote><p>1937年美国对日出口总值为2.89亿美元,其中石油、精炼油、废钢铁、原棉这四项战略物资就达1,42亿美元,约占二分之一。以石油一项而论,日本所需石油来自美国的份额,1937年占80%,1939年占85%。——齐世荣.绥靖政策研究.,北京：首都师范大学出版社,1998：413 据统计，1937－1938年，日本从美国进口的军需品占其军需品总进口额的55%。1937年，美对日废钢铁的出口量是1931年的40倍之多。——杨玉圣.中国人的美国观.上海: 复旦大学出版社，1997：152 （1937、1938年日本）从美国输入铁合金为77.53%和82.71%,铜的比例高达95.18%和90.89%,煤油及其产品为6.271%和65.57%,汽车及零件为9.241%和64%,飞机及零件为70.19%和7.692%,金属工作母机为69.53%和67.09%。——沈庆林.中国抗战时期的国际援助.上海人民出版社,2000：53</p></blockquote><p>这就是二战中最讽刺的地方，美国人是日本人在二战前期最主要石油来源国，而且没有之一。日本人觉得不能任由老美这么掐着自己的脖子，于是1934年出台了《石油工业法》表示要加强本国石油产业建设，效果……一般吧；然后37年又搞了个《合成油法案》，表示要开动大日本帝国先进之科技手段以煤改油，效果……更一般。</p><p>考虑到1937年日本的财政收入才47亿日元，而以当时的汇率来看大概3日元可以折合1美元，大家可以感受一下每年日美之间几亿美元的进口额意味着什么。而更倒霉的是虽然侵华战争开始以后日军进展极其顺利，然而中国是个贫穷的农业国，重工业基础极其薄弱，而工业建设又是个耗时巨大、烧钱极多的活儿……所以日本人十分郁闷地发现自己这仗是越打越大，然而钱却都进了美国人的兜。</p><p>这就是为什么37年日本人在扬子江上炸了美国船，罗斯福把这事按下去的原因之一——顺便一提，日本人为了平事掏出来了2214007.36刀，1937年的两百万美元啊……日本人在占领区甚至搞了一次“抵制美货”的闹剧，然而美国人对此并不在意：有本事你抵制我的石油啊？</p><p>美国国内群众此时对日本人的反感情绪已经是十分强烈了，甚至有几百名学生代表参与了焚烧日本丝绸的行动。等到了1938年美国政府觉得实在不能再这么容忍日本人了！必须上点手段了！于是政府向上百家工厂写信：<strong>建议不要跟日本人做生意</strong>。</p><p>这就是赫赫有名的“道义禁运”</p><blockquote><p>6月11日,赫尔在记者招待上公开谴贵对和平居民的空袭轰炸,随后他写给美国148家注册出口飞机和飞机部件的厂家,表示:政府强烈反对把飞机和航空设备出售给世界上任何对和平居民进行轰炸的国家——赫尔回忆录·第一卷：569</p></blockquote><p>道义禁运的效果极其明显，立竿见影，日本人37年从美国进口的飞机及部件达到248.4万美元，38年为1745.4万美元，增长了7倍。 这么拖拖拖一直拖到39年重庆轰炸，美国人民一看艾玛这太惨了，咱们真的不能再卖给日本人石油了，罗斯福表示那不成啊，你不卖给他石油了他狗急跳墙去打英荷东印度群岛怎么办？为了避免战争扩大咱们还是继续做生意吧……</p><p>对日本人来讲，事情非常尴尬——你要是想继续从美国人手里拿到物资，就必须按照美国人的意思，控制战争规模；而你想控制战争规模又控制不下来，TG在敌后遍地开花，老蒋死活就不投降，你占领的地方地大物博可就是没有好用的石油，重工业基础又弱到不行。所以日本人思前想后，最后还是向东南亚伸出了魔爪。</p><p>1939年2月，日本占领海南岛；3月，日本人又搞定了距马尼拉700英里的南沙群岛；6月，派兵封锁天津英租界，7月强迫英国人跟自己一起建设“东亚新秩序”，正在欧洲被希特勒搞得焦头烂额的英国人几乎没怎么犹豫，就在7月24号跟日本人签订了“有田——克莱琪协定”，承认了日本在中国有“特殊需要”。</p><p>这下美国人终于坐不住了，7月26号美国政府正式通知日本没，咱们那个美日商约即将在六个月后废止——半年时间，你自己想想清楚，到底还要不要铁和石油了。日本人终于发现这自己扛不住啊！赶紧还是跟美国人谈谈吧，于是9月25日，海军稳健派、熟悉米英鬼畜内部动向之大将野村吉三郎任专职外相，开始跟美国进行谈判，美国人说这事好办，你们开放长江下游、尊重我们在华权利，有钱大伙一起赚嘛！只要你们肯把中国的利益让出来一点，咱们这个商约还是可以再签的。</p><p>未果。</p><p>这期间的态势十分有趣，日本人在诺门坎吃了大败仗，彻底打消了北进的念头；敌后大规模扫荡、扫荡、再扫荡，八路就是扫不干净；正面战场进入相持状态，长沙会战、随枣会战都没能达成预定的战略目标，日本国内的经济开始遭不住了。</p><p>美国人此时反而比较克制，由于罗斯福担心“再进一步就会激怒日本”，所以1940年1月日美商约失效之后两国的贸易竟然还在诡异的继续着，然而谁也不知道这样的日子会持续多久。</p><p>对日本来说，他们必须做出选择了。</p><p>1940年3月，日本拟定了军需物资自给自足计划，将更多的精力投入到了东南亚</p><blockquote><p>日本政府深切关怀足以改变荷属东印度群岛现状的任何事态——1940年4月15日,外相有田八郎讲话,太平洋战争史·第二卷：21</p></blockquote><p>日本人在东南亚的脚步越来越快，而美国人则在抓紧时间，卖出自己的最后一份石油。所以一方面是日趋紧张的局势，而另一方面则是不断攀升的石油贸易，美孚石油在7月18日向国务院报告，说日本人提出要买下他们的全部产量！美国政府内部已经吵到不可开交，罗斯福接到的报告说假如我们再不限制日本人购买航空汽油，我们自己军队就可能出现6到9个月的汽油供应不足！</p><p>在巨大的压力面前罗斯福终于决定对日本进行禁运，经过漫长的扯皮与大撕逼之后，政府官员们最终达成了一致，在7月26日宣布对航空发动机燃料及润滑油和第一号高熔度的废钢铁实行出口管制。先总统 蒋公激动地浑身颤抖，跟美国大使表示艾玛你们太够意思了！</p><blockquote><p>总统和国务卿的伟大而辉煌的举动，减轻了中国自卷入冲突以来面临的极严峻的危机。——先总统 蒋公</p></blockquote><p>在这个后来被无数人称颂的禁运限制里，国务院表示辛烷值87以上的航空汽油都必须禁运！ &gt; 日本人：解释解释，什么叫“辛烷值87以上的航空汽油都必须禁运”？ &gt; 国务院：难道你不懂什么叫禁运？ &gt; 日本人：我要你解释解释，什么叫他妈的“辛烷值87以上的航空汽油都必须禁运”？ &gt; 石油公司：87号以上禁运的意思，就是他妈的87号以下不！禁！运！，还有，往86号航空汽油里加铅可以他妈的提高辛烷值！你懂了没有！？ &gt; 日本人：哦大哥，原来这就是他妈的禁运啊！小弟明白了！</p><p>于是1940年7月到12月，日本从美国进口的86号航空汽油同比增加了550%。</p><p>此时日本的经济已经开始在崩溃的边缘上晃悠了，国家总动员法的条款几乎已经全都实施了，结果40年日本西部和朝鲜还遭遇了旱灾，粮食收成不好，好多人连吃大米都成了问题。关键是此时日本的外汇储备也接近枯竭，再这么拖下去用不了多久你想买都买不成了！最后高层达成一致，再不对东南亚下手咱们就得先完蛋了。于是1941年7月2日，御前会议最终制定了《适应形势变化的帝国国策纲要》，表示就算是跟米英鬼畜开战，咱们也得南进！7月24日，日本出兵印度支那南部。</p><p>然后罗斯福炸了：老子不禁运你石油就是为了不让你打那边，你自己心里没点数么？于是26号冻结了日本在美的全部资产；英国人表示弟儿你说的对，我们也禁运，然后切断了日本在婆罗洲的石油供给。27号荷兰人跟进，冻结日本资产。这下子事情再也没有回转的余地了。</p><p>日本人的精神一下子紧张了起来（……为什么才紧张！？），军方此前一直认为我把印度支那南部这么一占，你们这些米英鬼畜还不得乖乖坐下来跟我和谈么？咱们这和平近在眼前啊！</p><blockquote><p>……以此确保东亚的战略要地。由此或可使英美荷死心不再压迫日本,并给重庆政府以打击,以找到解决日中战争的突破口,进而或许有助于打开日荷谈判。所以只有尽快抓住时机实行“战略上先发制人之措施”,才能避免同英美作战,此即不战而胜之上策——信天清三郎,日本外交史·下册：668</p></blockquote><p>1941年11月，两艘日本油轮自洛杉矶附近海域空载而归。大怒的日本人……切断了英美使馆的取暖油供应。（……我是一直没搞懂日本人的脑回路）而在此之前，8月份美国人已经提出了自己的条件：日本从中国撤军、各国在中国机会均等以及日本改变三国同盟，这个条件被日本人毫不犹豫地拒绝了。9月6日，日本御前会议批准了《帝国国策施行要点》，指出10月上旬外交依然没有进展，则准备开战。</p><p>日本人最开始的计划是咱们先赶紧在东南亚占地盘，然后建立个防御圈——考虑到东南亚还有个美属菲律宾，那美国人妥妥是要来跟咱们打的，到时候咱们舰队决战，拼个你死我活！</p><p>然后联合舰队的指挥官山本五十六对此表示了不同意见——美国人啥工业能力？你什么工业能力？心里没点数么？既然已经料到要打，那为什么不趁着美国人还没有完全动员的时候直接先下手为强？要知道，海军要想重建，那难度可比陆军难多了。咱们一鼓作气消灭美国的太平洋海上力量，然后趁着美国人重建海军无暇的关口逼他就范，承认咱们大日本帝国在亚洲的霸权那是十分合理的！</p><p>11月20日，日本向美国提出最后一个谈判方案，日本人表示这绝对是自己最后的底线了</p><blockquote><p>1.日本政府和美国政府都保证,除了目前己驻有日军的法属印度支那以外,不向东南亚和南太平洋地区的任何地方进行任何武装进军。 2.一俟日本和中国之间恢复和平,或在太平洋地区建立了公正的和平,日本政府保证撤走目前驻扎在法属印度支那的军队。同时,日本政府宣布在本协议(以后将包含在最后协议中)订立时,准备把现驻法属印支南部的军队移驻该地区北部. 3.日美两国政府将进行合作,以保证两国在荷属东印度群岛取得所需要的货物和商品。 4.日本政府和美国相互保证把通商关系恢复到日方资金被冻结前的状态.美国政府将按日本所需的数量供应石油。 5.美国政府保证不采取任何措施和行动,不利于日本和中国之间为谋求全面和平所作的努力。——United States Department of State.Papers relating to the foreign relations of the United States, Japan, 1931–1941, Volume II</p></blockquote><p>美国人对此表示难以置信，并回复了一份由国务卿起草的备忘录，基本上重申了自己在8月份提出的要求。美国人所不知道的，是在自己做出这个回复以前，一支规模空前的舰队已经在单冠湾集结完毕了，那上面的飞行员此前曾反复地练习过如何低空投放鱼雷和炸弹。罗斯福此时还在犹豫要不要向日本示好，以挽回两国之间的关系，11月22日美国国务院远东司甚至接到命令，起草一份新的草案，有限度地恢复对日本的石油、食品及药物供应。然而由于中国及英国的强烈反对，这份草案最终也没能实施。</p><p>1941年12月1日，日本御前会议做出了决定：与美国开战。</p><p>1941年12月7日，珍珠港事件爆发，美国太平洋舰队遭到重创。</p><p>1942年，日本军队逼近东印度群岛的巴厘巴板炼油厂，1943年第一季度，日本的石油危机大大缓和。</p><blockquote><p>石油问题已经基本得到解决——东条英机·1943</p></blockquote><p>以上。</p><hr><p>后记：这篇文章的作者设置了禁止转载，不过我这博客也没什么人看，我放在这里也是为了备份，也许将来某天知乎挂了或者作者决定退出知乎了删除了这篇问答？另外，作者的这篇文章里面还是有一些戏谑口吻的地方，我打算围绕着作者写的主干，做一做考据，让这篇文章能够成为之后“键政”的有力资料。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在知乎上看到的比较好的回答，作为备份放在这里：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;原文链接：&lt;a href=&quot;https://www.zhihu.com/question/306368870/answer/639051842&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/306368870/answer/639051842&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;archive.is上的备份网页：&lt;a href=&quot;http://archive.is/4dOL3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://archive.is/4dOL3&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="政治" scheme="http://www.codewoody.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>996 License 1.0</title>
    <link href="http://www.codewoody.com/posts/12613/"/>
    <id>http://www.codewoody.com/posts/12613/</id>
    <published>2019-04-08T02:07:49.000Z</published>
    <updated>2019-04-08T02:56:18.458Z</updated>
    
    <content type="html"><![CDATA[<p>Copyright (c) <year> <copyright holders=""></copyright></year></p><p>996 License Version 1.0 (Draft)</p><p>Permission is hereby granted to any individual or legal entity obtaining a copy of this licensed work (including the source code, documentation and/or related items, hereinafter collectively referred to as the &quot;licensed work&quot;), free of charge, to deal with the licensed work for any purpose, including without limitation, the rights to use, reproduce, modify, prepare derivative works of, publish, distribute and sublicense the licensed work, subject to the following conditions:</p><ol type="1"><li><p>The individual or the legal entity must conspicuously display, without modification, this License on each redistributed or derivative copy of the Licensed Work.</p></li><li><p>The individual or the legal entity must strictly comply with all applicable laws, regulations, rules and standards of the jurisdiction relating to labor and employment where the individual is physically located or where the individual was born or naturalized; or where the legal entity is registered or is operating (whichever is stricter). In case that the jurisdiction has no such laws, regulations, rules and standards or its laws, regulations, rules and standards are unenforceable, the individual or the legal entity are required to comply with Core International Labor Standards.</p></li><li><p>The individual or the legal entity shall not induce or force its employee(s), whether full-time or part-time, or its independent contractor(s), in any methods, to agree in oral or written form, to directly or indirectly restrict, weaken or relinquish his or her rights or remedies under such laws, regulations, rules and standards relating to labor and employment as mentioned above, no matter whether such written or oral agreement are enforceable under the laws of the said jurisdiction, nor shall such individual or the legal entity limit, in any methods, the rights of its employee(s) or independent contractor(s) from reporting or complaining to the copyright holder or relevant authorities monitoring the compliance of the license about its violation(s) of the said license.</p></li></ol><p>THE LICENSED WORK IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN ANY WAY CONNECTION WITH THE LICENSED WORK OR THE USE OR OTHER DEALINGS IN THE LICENSED WORK.</p><p>版权所有（c）<年份><版权持有人></版权持有人></年份></p><p>反996许可证版本1.0</p><p>在符合下列条件的情况下，特此免费向任何得到本授权作品的副本（包括源代码、文件和/或相关内容，以下统称为“授权作品”）的个人和法人实体授权：被授权个人或法人实体有权以任何目的处置授权作品，包括但不限于使用、复制，修改，衍生利用、散布，发布和再许可：</p><ol type="1"><li>个人或法人实体必须在许可作品的每个再散布或衍生副本上包含以上版权声明和本许可证，不得自行修改。</li><li>个人或法人实体必须严格遵守与个人实际所在地或个人出生地或归化地、或法人实体注册地或经营地（以较严格者为准）的司法管辖区所有适用的与劳动和就业相关法律、法规、规则和标准。如果该司法管辖区没有此类法律、法规、规章和标准或其法律、法规、规章和标准不可执行，则个人或法人实体必须遵守国际劳工标准的核心公约。</li><li>个人或法人不得以任何方式诱导或强迫其全职或兼职员工或其独立承包人以口头或书面形式同意直接或间接限制、削弱或放弃其所拥有的，受相关与劳动和就业有关的法律、法规、规则和标准保护的权利或补救措施，无论该等书面或口头协议是否被该司法管辖区的法律所承认，该等个人或法人实体也不得以任何方法限制其雇员或独立承包人向版权持有人或监督许可证合规情况的有关当局报告或投诉上述违反许可证的行为的权利。</li></ol><p>该授权作品是&quot;按原样&quot;提供，不做任何明示或暗示的保证，包括但不限于对适销性、特定用途适用性和非侵权性的保证。在任何情况下，无论是在合同诉讼、侵权诉讼或其他诉讼中，版权持有人均不承担因本软件或本软件的使用或其他交易而产生、引起或与之相关的任何索赔、损害或其他责任。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/kattgu7/996-License-Draft/" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//github.com/kattgu7/996-License-Draft/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Developer&#39;s Life Matters&lt;/p&gt;
&lt;style&gt;
svg {
  border: 3px solid #fff;
  border-radius: 150px;
  width: 150px;
  height: 150px;
  background: #de335e;
  margin: auto !important;
  display: block;
}
&lt;/style&gt;
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;512px&quot; viewbox=&quot;0 0 464 464&quot; width=&quot;512px&quot;&gt;
&lt;g&gt;&lt;path d=&quot;m24 144c-4.414062 0-8 3.585938-8 8v120h16v-120c0-4.414062-3.585938-8-8-8zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m104 256h-32c-10.414062 0-19.214844 6.710938-22.527344 16h77.046875c-3.304687-9.289062-12.105469-16-22.519531-16zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m56 417.472656v-97.472656h-16v97.472656c-9.304688 3.304688-16 12.09375-16 22.527344 0 13.257812 10.742188 24 24 24s24-10.742188 24-24c0-10.433594-6.695312-19.222656-16-22.527344zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m0 288h464v16h-464zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m48 248.207031c.089844-.070312.160156-.144531.246094-.207031-.085938-.0625-.15625-.136719-.246094-.207031zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m101.121094 192h-29.121094c-13.230469 0-24 10.769531-24 24s10.769531 24 24 24h29.121094c13.230468 0 24-10.769531 24-24s-10.769532-24-24-24zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m143.191406 272h304.335938c-3.992188-35.945312-34.527344-64-71.527344-64h-192c-11.128906 0-22.257812 2.625-32.191406 7.601562l-11.214844 5.605469c-1.363281 10.3125-6.609375 19.320313-14.289062 25.609375 8.542968 5.769532 14.757812 14.742188 16.886718 25.183594zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m413.273438 80-29.882813-69.734375-33.503906 92.140625-9.605469-14.40625h-52.28125v-72c0-8.824219-7.175781-16-16-16h-80c-8.824219 0-16 7.175781-16 16v40h-69.273438l-18.117187 42.265625-30.488281-83.859375-22.402344 33.59375h-35.71875v16h44.28125l9.597656-14.40625 33.503906 92.140625 29.890626-69.734375h58.726562v40c0 8.824219 7.175781 16 16 16h16v24h16v40h16v-40h16v-24h16c8.824219 0 16-7.175781 16-16v-8h43.71875l22.402344 33.59375 30.496094-83.859375 18.109374 42.265625h61.273438v-16zm-157.273438-16h-16v16h-16v-16h-16v-16h16v-16h16v16h16zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;path d=&quot;m424 417.472656v-97.472656h-16v97.472656c-9.304688 3.304688-16 12.09375-16 22.527344 0 13.257812 10.742188 24 24 24s24-10.742188 24-24c0-10.433594-6.695312-19.222656-16-22.527344zm0 0&quot; data-original=&quot;#000000&quot; data-old_color=&quot;#ffffff&quot; fill=&quot;#ffffff&quot; class=&quot;active-path&quot;/&gt;&lt;/g&gt;
&lt;/svg&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>OC和Swift混编Frameowork优雅指南</title>
    <link href="http://www.codewoody.com/posts/56606/"/>
    <id>http://www.codewoody.com/posts/56606/</id>
    <published>2019-04-04T06:09:04.000Z</published>
    <updated>2019-04-04T06:29:41.111Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.codewoody.com/uploads/big/b5d15c27a9f2a989d35696f515aec8d6.jpeg" alt="cover"> <a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/Swift/%20%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%80%E5%8F%91Swift%E5%92%8CObjective%20C%E6%B7%B7%E7%BC%96%E7%9A%84Framework.md" target="_blank" rel="noopener">本文主要参考了优雅地开发Swift和Object C混编的Framework</a>。不过实际发现，完全按照文章里面”优雅的解决方案“里面的说法操作，还是没法成功。我这里根据实际情况作出了调整。 <a id="more"></a></p><ol type="1"><li>参考的文章中在“优雅的解决方案”这个section之前的内容都是好用的，你可以用用来创建一个兼容OC和Swift的Cooca Touch Framework。</li><li>这里说的“优雅”，指的是控制OC部分接口保留的问题（详情可以参考原文部分）</li></ol><p>原文里面只说了具体的操作步骤，没有高屋建瓴地说出这种方法的实际思路：事实上，采用<code>module.modulemap</code>的方法是将OC部分打包成一个可以使用Swfit语句进行导入(import)的模块。以这个视角，我们再来梳理一下操作步骤：</p><h4 id="新建一个module.modulemap文件">新建一个<code>module.modulemap</code>文件</h4><p>文件里的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module OCSource [system] &#123;</span><br><span class="line">    //由于module.modulemap和OCSource.h是在同一个文件夹的，如果不是同一个，路径要写全</span><br><span class="line">    header &quot;OCSource.h&quot;</span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一个容易犯错的问题是将这里的模块名字, OCSource命名为了Cocoa Touch Framework的名字。这样会导致编译出错，错误信息会提示你Module名字重复定义。这里的名字要区别的Framework的名字，具体是什么可以自己自由选择。不过推荐和头文件的名字一致</p></blockquote><p>后一步操作是把<code>module.modulemap</code>的路径添加到Build Settings的<code>Import Paths</code>中，这是为了让我们在Swift里面<code>import</code>这个module的时候能够找到目标.</p><figure><img src="https://imgs.codewoody.com/uploads/big/f9b81bd3d7c4bff9b05b4548ed039922.png" alt="Import Paths in Build Settings"><figcaption>Import Paths in Build Settings</figcaption></figure><p>那么，这里的<code>$(SRCROOT)/MixFramework</code>其实就是指的<code>module.modulemap</code>的路径。</p><h4 id="将ocsouce.h文件的权限改为project">将<code>OCSouce.h</code>文件的权限改为project</h4><figure><img src="https://imgs.codewoody.com/uploads/big/7d7b91d9291919efb1de5b5c3543655d.png" alt="Header Visibility Settings"><figcaption>Header Visibility Settings</figcaption></figure><p>这可以让<code>OCSource.h</code>不再对外可见。 然后，删除MixFramework.h(umbrella header)中#import 的OC header。</p><hr><p>原文的内容到此结束，但是其实还是不够的。这时候如果编译，会发现你在Framework内部的Swift使用OCSource的地方都会报错说OCSource不存在。因为将<code>OCSource.h</code>从umbrella header中删除之后Swift就无法看到这个文件了。然而，通过<code>module.modulemap</code>文件我们将<code>OCSource.h</code>及相关的OC文件打包成了了一个Swift模块，因此我们可以在Swift代码中import进来：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OCSource</span><br></pre></td></tr></table></figure><p>在报错的Swift文件中添加这个导入，就可以解决这个问题了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/b5d15c27a9f2a989d35696f515aec8d6.jpeg&quot; alt=&quot;cover&quot;&gt; &lt;a href=&quot;https://github.com/LeoMobileDeveloper/Blogs/blob/master/Swift/%20%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%80%E5%8F%91Swift%E5%92%8CObjective%20C%E6%B7%B7%E7%BC%96%E7%9A%84Framework.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文主要参考了优雅地开发Swift和Object C混编的Framework&lt;/a&gt;。不过实际发现，完全按照文章里面”优雅的解决方案“里面的说法操作，还是没法成功。我这里根据实际情况作出了调整。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ios" scheme="http://www.codewoody.com/tags/ios/"/>
    
      <category term="swift" scheme="http://www.codewoody.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Universal(Fat) Framework for Swift Projects</title>
    <link href="http://www.codewoody.com/posts/28461/"/>
    <id>http://www.codewoody.com/posts/28461/</id>
    <published>2019-04-03T03:41:42.000Z</published>
    <updated>2019-04-03T05:59:46.740Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://imgs.codewoody.com/uploads/big/ec2894c1da024327344a0c2fb0f0e55a.jpg" alt="Cocoa Touch Framework"><figcaption>Cocoa Touch Framework</figcaption></figure><p>最近在给朋友做一个项目，要求将涉及到的算法内容整理成一个单独的framework，这样可以隐藏算法细节，方便交付。这个需求可以很容易地通过<a href="https://medium.com/@Rageeni16/create-cocoa-touch-framework-and-publish-it-be9ad6535f33" target="_blank" rel="noopener">Cocoa Touch Framework</a>实现。不过在交付的时候存在一个头疼的问题：默认情况下，Xcode在编译Cocoa Touch Framework时只会编译出支持模拟器或者真机的Framework，而无法编译出同时支持模拟器和真机的Framework，即Universal(Fat) Framework。这一需求还需要进一步地利用一些系统脚本来实现。 <a id="more"></a></p><p>这里假设你已经有了一个能够正常工作，编译的包含Cocoa Touch Framework的工程。我这里实现时使用的是Xcode10.2。</p><blockquote><p>事实上我在调研中发现了很多不同的实现编译Universal Framework的教程，但是他们并不总是有用，我这里只遴选了我自己测试通过没有问题的思路。这一思路通过Archive过程来打包输出framework</p></blockquote><p>首先从Xcode左上角选择Cocoa Touch Framework的默认scheme，然后点击Edit Scheme</p><figure><img src="https://imgs.codewoody.com/uploads/big/c98bd864a870a5fa23da8ec4b330fd51.png" alt="Edit Scheme"><figcaption>Edit Scheme</figcaption></figure><p>在Archive的post-action中添加一个运行脚本(New Run Script Action)</p><figure><img src="https://imgs.codewoody.com/uploads/big/8928535c1633ad1bfab117bd46b5b20c.png" alt="New Run Script Action"><figcaption>New Run Script Action</figcaption></figure><p>脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> &gt; /tmp/<span class="variable">$&#123;PROJECT_NAME&#125;</span>_archive.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">UNIVERSAL_OUTPUTFOLDER=<span class="variable">$&#123;BUILD_DIR&#125;</span>/<span class="variable">$&#123;CONFIGURATION&#125;</span>-universal</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"true"</span> == <span class="variable">$&#123;ALREADYINVOKED:-false&#125;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"RECURSION: Detected, stopping"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">export</span> ALREADYINVOKED=<span class="string">"true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make sure the output directory exists</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;UNIVERSAL_OUTPUTFOLDER&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Building for iPhoneSimulator"</span></span><br><span class="line">xcodebuild -workspace <span class="string">"<span class="variable">$&#123;WORKSPACE_PATH&#125;</span>"</span> -scheme <span class="string">"<span class="variable">$&#123;TARGET_NAME&#125;</span>"</span> -configuration <span class="variable">$&#123;CONFIGURATION&#125;</span> -sdk iphonesimulator -destination <span class="string">'platform=iOS Simulator,name=iPhone 6'</span> ONLY_ACTIVE_ARCH=NO ARCHS=<span class="string">'i386 x86_64'</span> BUILD_DIR=<span class="string">"<span class="variable">$&#123;BUILD_DIR&#125;</span>"</span> BUILD_ROOT=<span class="string">"<span class="variable">$&#123;BUILD_ROOT&#125;</span>"</span> ENABLE_BITCODE=YES OTHER_CFLAGS=<span class="string">"-fembed-bitcode"</span> BITCODE_GENERATION_MODE=bitcode clean build</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1. Copy the framework structure (from iphoneos build) to the universal folder</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Copying to output folder"</span></span><br><span class="line"><span class="comment"># 这行是在我参考的脚本的基础上添加进去的。脚本在运行过程中有一个问题：在试图将</span></span><br><span class="line"><span class="comment"># archive过程中生成的device framework拷贝进来时，总是拷贝的framework文件夹</span></span><br><span class="line"><span class="comment"># 的内容，而非整个文件夹，所以我们这里手动创建这个文件夹</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;UNIVERSAL_OUTPUTFOLDER&#125;</span>/<span class="variable">$&#123;FULL_PRODUCT_NAME&#125;</span>"</span></span><br><span class="line">cp -R <span class="string">"<span class="variable">$&#123;ARCHIVE_PRODUCTS_PATH&#125;</span><span class="variable">$&#123;INSTALL_PATH&#125;</span>/<span class="variable">$&#123;FULL_PRODUCT_NAME&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;UNIVERSAL_OUTPUTFOLDER&#125;</span>/<span class="variable">$&#123;FULL_PRODUCT_NAME&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2. Copy Swift modules from iphonesimulator build (if it exists) to the copied framework directory</span></span><br><span class="line">SIMULATOR_SWIFT_MODULES_DIR=<span class="string">"<span class="variable">$&#123;BUILD_DIR&#125;</span>/<span class="variable">$&#123;CONFIGURATION&#125;</span>-iphonesimulator/<span class="variable">$&#123;TARGET_NAME&#125;</span>.framework/Modules/<span class="variable">$&#123;TARGET_NAME&#125;</span>.swiftmodule/."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"SIMULATOR_SWIFT_MODULES_DIR: <span class="variable">$&#123;SIMULATOR_SWIFT_MODULES_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;SIMULATOR_SWIFT_MODULES_DIR&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">cp -R <span class="string">"<span class="variable">$&#123;SIMULATOR_SWIFT_MODULES_DIR&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;UNIVERSAL_OUTPUTFOLDER&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.framework/Modules/<span class="variable">$&#123;TARGET_NAME&#125;</span>.swiftmodule"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3. Create universal binary file using lipo and place the combined executable in the copied framework directory</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Combining executables"</span></span><br><span class="line">lipo -create -output <span class="string">"<span class="variable">$&#123;UNIVERSAL_OUTPUTFOLDER&#125;</span>/<span class="variable">$&#123;FULL_PRODUCT_NAME&#125;</span>/<span class="variable">$&#123;EXECUTABLE_PATH&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;BUILD_DIR&#125;</span>/<span class="variable">$&#123;CONFIGURATION&#125;</span>-iphonesimulator/<span class="variable">$&#123;EXECUTABLE_PATH&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;ARCHIVE_PRODUCTS_PATH&#125;</span><span class="variable">$&#123;INSTALL_PATH&#125;</span>/<span class="variable">$&#123;EXECUTABLE_PATH&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4. Create universal binaries for embedded frameworks</span></span><br><span class="line"><span class="comment">#for SUB_FRAMEWORK in $( ls "$&#123;UNIVERSAL_OUTPUTFOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/Frameworks" ); do</span></span><br><span class="line"><span class="comment">#BINARY_NAME="$&#123;SUB_FRAMEWORK%.*&#125;"</span></span><br><span class="line"><span class="comment">#lipo -create -output "$&#123;UNIVERSAL_OUTPUTFOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/Frameworks/$&#123;SUB_FRAMEWORK&#125;/$&#123;BINARY_NAME&#125;" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;SUB_FRAMEWORK&#125;/$&#123;BINARY_NAME&#125;" "$&#123;ARCHIVE_PRODUCTS_PATH&#125;$&#123;INSTALL_PATH&#125;/$&#123;TARGET_NAME&#125;.framework/Frameworks/$&#123;SUB_FRAMEWORK&#125;/$&#123;BINARY_NAME&#125;"</span></span><br><span class="line"><span class="comment">#done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5. Convenience step to copy the framework to the project's directory</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Copying to project dir"</span></span><br><span class="line">yes | cp -Rf <span class="string">"<span class="variable">$&#123;UNIVERSAL_OUTPUTFOLDER&#125;</span>/<span class="variable">$&#123;FULL_PRODUCT_NAME&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;PROJECT_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">open <span class="string">"<span class="variable">$&#123;PROJECT_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>上述脚本的内容主要来自于<a href="https://gist.github.com/eladnava/0824d08da8f99419ef2c7b7fb6d4cc78" target="_blank" rel="noopener">export-fat-swift-dynamic-framework</a>，我在这里根据实际情况进行了更改</p></blockquote><p>此时执行archive操作(Product-&gt;Archive)完成后会自动弹出Finder窗口显示新生成的framework的位置（应当就是位于项目根目录下）。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/ec2894c1da024327344a0c2fb0f0e55a.jpg&quot; alt=&quot;Cocoa Touch Framework&quot;&gt;&lt;figcaption&gt;Cocoa Touch Framework&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;最近在给朋友做一个项目，要求将涉及到的算法内容整理成一个单独的framework，这样可以隐藏算法细节，方便交付。这个需求可以很容易地通过&lt;a href=&quot;https://medium.com/@Rageeni16/create-cocoa-touch-framework-and-publish-it-be9ad6535f33&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cocoa Touch Framework&lt;/a&gt;实现。不过在交付的时候存在一个头疼的问题：默认情况下，Xcode在编译Cocoa Touch Framework时只会编译出支持模拟器或者真机的Framework，而无法编译出同时支持模拟器和真机的Framework，即Universal(Fat) Framework。这一需求还需要进一步地利用一些系统脚本来实现。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ios" scheme="http://www.codewoody.com/tags/ios/"/>
    
      <category term="swift" scheme="http://www.codewoody.com/tags/swift/"/>
    
  </entry>
  
</feed>
