<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>治部少辅</title>
  
  <subtitle>大一大万大吉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codewoody.com/"/>
  <updated>2019-07-23T03:35:38.195Z</updated>
  <id>http://www.codewoody.com/</id>
  
  <author>
    <name>Woody Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网贷的法律问题相关</title>
    <link href="http://www.codewoody.com/posts/59410/"/>
    <id>http://www.codewoody.com/posts/59410/</id>
    <published>2019-07-23T02:45:36.000Z</published>
    <updated>2019-07-23T03:35:38.195Z</updated>
    
    <content type="html"><![CDATA[<p>最近家里有亲人沾染上了网贷的事情，果然是在身边印证了当前年轻人普遍负债的现象。不过这些网贷，既然这么容易就能借到，必然也是找各种擦边球的手段，来提高事实利率来对冲贸然接待的高风险。不然坏账这么多，肯定遭不住。</p><p>国家法律规定中，用24%和36%两个关键数字，划定了民间借贷的利率和利息问题。根据2015年9月1日起开始施行的<a href="http://www.court.gov.cn/zixun-xiangqing-15146.html" target="_blank" rel="noopener">《最高人民法院关于审理民间借贷案件适用法律若干问题的规定》</a>司法解释：</p><blockquote><p>借贷双方约定的利率未超过年利率24%，出借人请求借款人按照约定的利率支付利息的，人民法院应予支持。借贷双方约定的利率超过年利率36%，超过部分的利息约定无效。借款人请求出借人返还已支付的超过年利率36%部分的利息的，人民法院应予支持。</p></blockquote><p>不过，大部分的网贷平台，到目前也不太可能蠢到把事实上奇高的利息写到纸面上。相反，这些高额利息会被包装成手续费，服务费之类的名目。例如，A从某网贷借出20000，服务费的扣除5000，还款24%的利息，事实上的年化利息达到了65%。</p><p>不过，2017年12月1日，联网金融风险专项整治工作领导小组办公室、P2P网贷风险专项整治工作领导小组办公室印发并实施了<a href="https://baike.baidu.com/reference/22239759/03b2NZyCEsP_dOZTcSiWZzbIqKCEX5Jkhu_NEfYrze1dX3L8gwUgF-RR2YdZ3JkukrTyhnRcopyqhCwMTq-ZXLwvRvf5JfFruU3UUyQJZAPf-HcXIH-C1XjNuntz" target="_blank" rel="noopener">《关于规范整顿“现金贷”业务的通知》</a>。其中第四部分，「持续推进，完善P2P网络借贷信息中介机构业务管理 」，第一条规定：</p><blockquote><p>不得撮合或变相撮合不符合法律有关利率规定的借贷业务；禁止从借贷本金中先行扣除利息、手续费、管理费、保证金以及设定高额逾期利息、滞纳金、罚息等。</p></blockquote><p>另，2018年<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D%E5%8D%8F%E4%BC%9A" target="_blank" rel="noopener">中国互金会</a>发布<a href="http://finance.sina.com.cn/money/bank/hykx/2018-09-04/doc-ihiqtcan7041142.shtml" target="_blank" rel="noopener">《关于P2P网络借贷机构自律检查第一阶段会员自查自纠工作相关问题的说明》</a>，其中要求：</p><blockquote><p>会员机构不得撮合或变相撮合不符合法律有关利率规定的借贷业务，禁止从借贷本金中先行扣除利息、手续费、管理费、保证金以及设定高额逾期利息、滞纳金、罚息等,相关逾期罚息也要计算在综合资金成本中。</p></blockquote><p>随着法规的完善，这些网贷平台自然也是道高一尺，魔高一丈。很多网贷在收取服务费的时候，就是要求借款人将服务费转到私人账户。这样，将来有了纠纷，借款人也就无法举证说明这笔费用是平台收取的服务费了。今年春天爆出来的<a href="https://zh.wikipedia.org/zh-hans/%E8%A5%BF%E5%AE%89%E5%A5%94%E9%A9%B0%E6%96%B0%E8%BD%A6%E6%BC%8F%E6%B2%B9%E7%BB%B4%E6%9D%83%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">西安奔驰车主维权</a>中：</p><blockquote><p>在曝光的谈话录音里，车主提到自己本来可以全款购买，但4S店称奔驰金融贷款利息低，用各种方法“引诱”自己使用奔驰金融。此后，她付完首付款后，在不知情的情况下被开通奔驰金融，还被迫交纳服务费1.5万，对方还要求把钱转至一个私人账户，并且没有发票。交完这笔服务费，才接着为她办理后续业务。车主表示，并不理解自己交纳的这笔服务费，到底获得了什么服务。</p></blockquote><p>西安这个案子全国瞩目，自然，当事人被收取的<a href="http://www.nbd.com.cn/articles/2019-06-13/1342626.html" target="_blank" rel="noopener">金融服务费被退还了</a>。其他的普通人遇到同样的时间，自然是不会有这个待遇。而且就目前来说，如果服务费之类的内容已经打到了私人账户上，确实没有任何有效的手段能够追回，或是让法院认可这笔交易是交纳服务费了，举证非常困难。但是如果网贷平台的环节设置中存在漏洞，例如在平台APP上曾经显示服务费的项目，也许可以有一定的转机。</p><p>更多阅读：</p><ul><li><a href="https://www.weibo.com/ttarticle/p/show?id=2309404370716387587185&amp;mod=zwenzhang" target="_blank" rel="noopener">网贷乱象再调查：到手8万8要还近16万，变相砍头息用户维权难</a></li><li><a href="http://www.xinhuanet.com/local/2018-02/28/c_1122467345.htm" target="_blank" rel="noopener">网贷真能逼死人 别让高利贷钻了创新空子</a></li><li><a href="http://finance.sina.com.cn/chanjing/cyxw/2018-03-14/doc-ifysftkm3469332.shtml" target="_blank" rel="noopener">秘而不宣的网贷砍头息：借款5000元 手续费就得1200</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近家里有亲人沾染上了网贷的事情，果然是在身边印证了当前年轻人普遍负债的现象。不过这些网贷，既然这么容易就能借到，必然也是找各种擦边球的手段，来提高事实利率来对冲贸然接待的高风险。不然坏账这么多，肯定遭不住。&lt;/p&gt;
&lt;p&gt;国家法律规定中，用24%和36%两个关键数字，划定
      
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="折腾" scheme="http://www.codewoody.com/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="法律" scheme="http://www.codewoody.com/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mysql安装过程中没有提示设置密码的问题</title>
    <link href="http://www.codewoody.com/posts/9986/"/>
    <id>http://www.codewoody.com/posts/9986/</id>
    <published>2019-07-18T06:49:26.000Z</published>
    <updated>2019-07-19T02:51:53.257Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.digitalocean.com/community/questions/no-password-is-asked-when-installing-mysql-server" target="_blank" rel="noopener">原贴地址</a></li></ul><a id="more"></a><p>问题描述：在使用<code>sudo apt-get install -y mysql-server</code>的过程中没有提示设置<code>root</code>账户的密码，按照<a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-16-04" target="_blank" rel="noopener">教程</a>执行<code>mysql_secure_installation</code>时，无法以<code>root</code>账户登录进入MySQL。</p><p>解决方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mysqld_safe --skip-grant-tables&amp;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mysql --user=root mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> authentication_string=PASSWORD(<span class="string">'new-password'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit</span></span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><p>注意将<code>new-password</code>替换为你想要设置的密码。注意，我们仍然需要使用<code>sudo</code>才能运行<code>mysql_secure_installation</code>，否则会出现<code>Error: Access denied for user 'root'@'localhost'</code>的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/questions/no-password-is-asked-when-installing-mysql-server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原贴地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Debug" scheme="http://www.codewoody.com/categories/Debug/"/>
    
    
      <category term="翻译" scheme="http://www.codewoody.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>Sqlite: window function</title>
    <link href="http://www.codewoody.com/posts/35361/"/>
    <id>http://www.codewoody.com/posts/35361/</id>
    <published>2019-07-17T07:18:01.000Z</published>
    <updated>2019-07-22T07:40:51.183Z</updated>
    
    <content type="html"><![CDATA[</p><p><a href="https://www.sqlite.org/windowfunctions.html" target="_blank" rel="noopener">Sqlite Window Function</a></p><h2 id="简介">简介</h2><p>之前我们接触的SQL命令的结果，一般都是逐行的。即SQL命令返回的结果，都是来自原表的同一行。Window Function则赋予了我们在SQL 结果中，获得来自一组行的数据的能力。这样的组被称为「Window」。</p><p>Window Function最鲜明的特征是<code>OVER</code>关键字。如果 以一个函数有<code>OVER</code>子句，则此函数为Window Function。反之，如果这个函数不带<code>OVER</code>子句，则这个函数是简单的聚合(Aggregate)函数或者标量(Scalar)函数。Window Function在函数和<code>OVER</code>子句之间，还可能带有<code>FILTER</code>子句。</p><p>Window Function的语法结构如下：</p><figure><img src="https://www.sqlite.org/images/syntax/window-function-invocation.gif" alt="Window function invocation"><figcaption>Window function invocation</figcaption></figure><p>不同于普通的函数，Window Function不能使用Distinct子句。另外，Window Function只能出现在查询结果中和<code>ORDER BY</code>后面。</p><p>Window Function可以划归为的两种不同类型：聚合窗函数(Aggregate Window Function)和内建窗函数(Built-in Window Function)。每个聚合窗函数也可以当做普通的聚合函数使用（只需要舍去<code>OVER</code>和<code>FILTER</code>子句即可）。内建窗函数，也可以通过合适地配置<code>OVER</code>子句从而具备聚合函数的功能。在应用中，我们也可以通过<a href="https://www.sqlite.org/c3ref/create_function.html" target="_blank" rel="noopener">sqlite3_create_window_function()</a>接口（C）来自定义新的聚合窗函数。</p><p>下面是使用内建的<code>row_number()</code>窗函数的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t0(x <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>, y <span class="built_in">TEXT</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t0 <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'aaa'</span>), (<span class="number">2</span>, <span class="string">'ccc'</span>), (<span class="number">3</span>, <span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- The following SELECT statement returns:</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--   x | y | row_number</span></span><br><span class="line"><span class="comment">-----------------------</span></span><br><span class="line"><span class="comment">--   1 | aaa | 1</span></span><br><span class="line"><span class="comment">--   2 | ccc | 3</span></span><br><span class="line"><span class="comment">--   3 | bbb | 2</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">SELECT</span> x, y, row_number() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> y) <span class="keyword">AS</span> row_number <span class="keyword">FROM</span> t0 <span class="keyword">ORDER</span> <span class="keyword">BY</span> x;</span><br></pre></td></tr></table></figure><p><code>row_number()</code>窗函数函数可以每行添加一个行号。行号的顺序通过<code>OVER</code>后面的<code>ORDER BY y</code>确定。注意，<code>OVER</code>后面的<code>ORDER BY y</code>不会影响<code>SELECT</code>返回的查询结果的顺序。在上面的例子中，<code>SELECT</code>返回的顺序还是根据<code>x</code>来排序的。比对上面的「Window function invocation」图，<code>OVER</code>后的子句体称为<code>window-defn</code>。我们还可以在<code>SELECT</code>语句中通过<code>WINDOW</code>子句来声明<code>named window-defn</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> x, y, row_number() <span class="keyword">OVER</span> win1, <span class="keyword">rank</span>() <span class="keyword">OVER</span> win2</span><br><span class="line"><span class="keyword">FROM</span> t0</span><br><span class="line">WINDOW win1 <span class="keyword">AS</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> y <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>),</span><br><span class="line">       win2 <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> y <span class="keyword">ORDER</span> <span class="keyword">BY</span> x)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> x;</span><br></pre></td></tr></table></figure><p><code>WINDOW</code>子句，应当位于<code>HAVING</code>之后，<code>ORDER BY</code>之前。</p><h2 id="聚合窗函数">聚合窗函数</h2><p>在这个部分我们假设所有的数据库的结构都是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(a <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>, b, c);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>   (<span class="number">1</span>, <span class="string">'A'</span>, <span class="string">'one'</span>  ),</span><br><span class="line">                        (<span class="number">2</span>, <span class="string">'B'</span>, <span class="string">'two'</span>  ),</span><br><span class="line">                        (<span class="number">3</span>, <span class="string">'C'</span>, <span class="string">'three'</span>),</span><br><span class="line">                        (<span class="number">4</span>, <span class="string">'D'</span>, <span class="string">'one'</span>  ),</span><br><span class="line">                        (<span class="number">5</span>, <span class="string">'E'</span>, <span class="string">'two'</span>  ),</span><br><span class="line">                        (<span class="number">6</span>, <span class="string">'F'</span>, <span class="string">'three'</span>),</span><br><span class="line">                        (<span class="number">7</span>, <span class="string">'G'</span>, <span class="string">'one'</span>  );</span><br></pre></td></tr></table></figure><p>聚合窗函数类似于一般的聚合函数，添加聚合窗函数不会改变查询返回的行数。相反，聚合窗函数会将于「Window frame」中运行的得到的聚合结果添加到原本的每一行结果中。例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- The following SELECT statement returns:</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--   a | b | group_concat</span></span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line"><span class="comment">--   1 | A | A.B</span></span><br><span class="line"><span class="comment">--   2 | B | A.B.C</span></span><br><span class="line"><span class="comment">--   3 | C | B.C.D</span></span><br><span class="line"><span class="comment">--   4 | D | C.D.E</span></span><br><span class="line"><span class="comment">--   5 | E | D.E.F</span></span><br><span class="line"><span class="comment">--   6 | F | E.F.G</span></span><br><span class="line"><span class="comment">--   7 | G | F.G</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">SELECT</span> a, b, <span class="keyword">group_concat</span>(b, <span class="string">'.'</span>) <span class="keyword">OVER</span> (</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="number">1</span> <span class="keyword">FOLLOWING</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">group_concat</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们要做的将本行与上下两行的结果拼起来，而上下行关系，是根据<code>OVER</code>子句中的<code>ORDER BY</code>来确定的。</p><h3 id="partition-by-子句"><code>PARTITION BY</code> 子句</h3><p>为了计算窗函数，查询的返回结果通过<code>PARTITION BY</code>子句分割成多个「partitions」。<code>PARTITION BY</code>类似于<code>GROUP BY</code>，可以将查询结果中，于<code>PARTITION BY</code>后的<code>window-defn</code>所指定列拥有相通值的行组成组。若没有<code>PARTITION BY</code>子句，则所有的查询结果组成一个单一的组。窗函数在各个「partition」上运行。</p><p>例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- The following SELECT statement returns:</span></span><br><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="comment">--   c     | a | b | group_concat</span></span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="comment">--   one   | 1 | A | A.D.G       </span></span><br><span class="line"><span class="comment">--   one   | 4 | D | D.G         </span></span><br><span class="line"><span class="comment">--   one   | 7 | G | G           </span></span><br><span class="line"><span class="comment">--   three | 3 | C | C.F         </span></span><br><span class="line"><span class="comment">--   three | 6 | F | F           </span></span><br><span class="line"><span class="comment">--   two   | 2 | B | B.E         </span></span><br><span class="line"><span class="comment">--   two   | 5 | E | E           </span></span><br><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="keyword">SELECT</span> c, a, b, <span class="keyword">group_concat</span>(b, <span class="string">'.'</span>) <span class="keyword">OVER</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> c <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span> <span class="keyword">AND</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">group_concat</span></span><br><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> c, a;</span><br></pre></td></tr></table></figure><p>在上面的查询例子中，<code>PARTITION BY c</code>将查询结果划分成了三个Partition。第一个Parition的<code>c = one</code>，第二个Partition的<code>c = three</code>，第三个Partition的<code>c = two</code>。注意，Partiion的划分，及其后续的的<code>ORDER BY</code>的排序，和最终查询结果的顺序是没有关系的。上面的查询的例子的输出也可能是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- The following SELECT statement returns:</span></span><br><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="comment">--   c     | a | b | group_concat</span></span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="comment">--   one   | 1 | A | A.D.G       </span></span><br><span class="line"><span class="comment">--   two   | 2 | B | B.E         </span></span><br><span class="line"><span class="comment">--   three | 3 | C | C.F         </span></span><br><span class="line"><span class="comment">--   one   | 4 | D | D.G         </span></span><br><span class="line"><span class="comment">--   two   | 5 | E | E           </span></span><br><span class="line"><span class="comment">--   three | 6 | F | F           </span></span><br><span class="line"><span class="comment">--   one   | 7 | G | G           </span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">SELECT</span> c, a, b, <span class="keyword">group_concat</span>(b, <span class="string">'.'</span>) <span class="keyword">OVER</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> c <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span> <span class="keyword">AND</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">group_concat</span></span><br><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure><h3 id="frame-specification">Frame Specification</h3><p>Frame Specification是<code>OVER</code>子句的一个部分，规定了聚合窗函数读取的输出行的范围。<code>frame-spec</code>在<code>window-defn</code>中的位置如下:</p><p><img src="https://www.sqlite.org/images/syntax/window-defn.gif"></p><p><code>frame-spec</code>包含如下四个部分：</p><ul><li>Frame type: either ROWS, RANGE or GROUPS;</li><li>A starting frame boundary;</li><li>An ending frame broundary;</li><li>An EXCLUDE clause;</li></ul><p>细节的语法结构如下：</p><p><img src="https://www.sqlite.org/images/syntax/frame-spec.gif"></p><p>其中ending frame boundary可以被省略，此时默认情况下ending frame boundary默认为 <code>CURRENT ROW</code>。</p><p>如果frame type为<code>RANGE</code>或者<code>GROUPS</code>，那么在<code>ORDER BY</code>所指定的列上具有相同值的行被归为一组「peers」。如果没有<code>ORDER BY</code>，那么所有的行归于一组Peer。注意Peers总是属于相同的frame。</p><p>默认的<code>frame-spec</code>为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE NO OTHERS</span><br></pre></td></tr></table></figure><p>默认的配置的意思是，聚合窗函数从Partition的开头开始读取直到当前的行的所有Peers。同Peer组的行对从窗函数获取的返回值是相通的（其Window frame是相同的）。例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- The following SELECT statement returns:</span></span><br><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="comment">--   a | b | c | group_concat</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">--   1 | A | one   | A.D.G       </span></span><br><span class="line"><span class="comment">--   2 | B | two   | A.D.G.C.F.B.E</span></span><br><span class="line"><span class="comment">--   3 | C | three | A.D.G.C.F   </span></span><br><span class="line"><span class="comment">--   4 | D | one   | A.D.G       </span></span><br><span class="line"><span class="comment">--   5 | E | two   | A.D.G.C.F.B.E</span></span><br><span class="line"><span class="comment">--   6 | F | three | A.D.G.C.F   </span></span><br><span class="line"><span class="comment">--   7 | G | one   | A.D.G       </span></span><br><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="keyword">SELECT</span> a, b, c,</span><br><span class="line">       <span class="keyword">group_concat</span>(b, <span class="string">'.'</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> c) <span class="keyword">AS</span> <span class="keyword">group_concat</span> </span><br><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure><blockquote><p>关于Frame的更多细节，参考出处原文（页面顶部）</p></blockquote><h3 id="filter-子句"><code>FILTER</code> 子句</h3><p><img src="https://www.sqlite.org/images/syntax/filter.gif"></p><p>如果出现了<code>FILTER</code>子句，那么只有<code>expr</code>指定的行才会被包含到window frame中。这里的<code>FILTER</code>不会过滤查询结果，只是决定了窗函数作用的范围。</p><h2 id="内建窗函数">内建窗函数</h2><p>内建窗函数也具备和聚合窗函数同样的<code>PARTITION BY</code>子句功能：每个行都从属于一个Partition，而每个Partition被单独地进行处理。<code>ORDER BY</code>的作用，我们在下面进行阐述。有一些特定的窗函数（<code>rank()</code>, <code>dense_rank</code>, <code>percent_rank</code> and <code>ntile()</code>）采用了<code>peer group</code>的概念（rows within the same partition that have the same values for all ORDER BY expressions）。此时<code>frame-spec</code>中<code>frame type</code>(<code>ROWS</code>, <code>GROUPS</code>, <code>RANGE</code>) 就不起作用了。</p><p>SQLite支持如下11个内建的窗函数</p><ul><li><code>row_number()</code>: 当前行位于Partition中的位置（行号），从1开始排列，顺序由窗函数的<code>ORDER BY</code>决定。</li><li><code>rank()</code>: 每一个Group（同一个Partition内在<code>ORDER BY</code>指定的列上具有相同值的行归于一个Group）中的第一个peer（行）的<code>row_number</code>值。<code>rank</code>获取的序号可能是不连续的。</li><li><code>dense_rank()</code>: 相比于<code>rank()</code>, 压缩了序号的间隙，得到的序号总是连续的。从1开始排。</li><li><code>percent_rank()</code>: 将rank转化成百分比，等于<code>(rank - 1)/(partition-rows - 1)</code>。如果只有一个组，返回0.</li><li><code>cume_dist()</code>: 累积分布，等于<code>row-number/partition-rows</code>。</li><li><code>ntile(N)</code>: 参数N为整数，这个函数将partition划分为尽可能均匀的N份，并为每份分配一个1到N的整数，顺序由<code>ORDER BY</code>决定（若无<code>ORDER BY</code>，则为乱序）。如果需要的话，较大的组会先出现。</li><li><code>lag(expr)</code></li><li><code>lag(expr, offset)</code></li><li><code>lag(expr, offset, default)</code>: 返回对上一行执行<code>expr</code>得到的结果。如果没有上一行，返回空。可以通过<code>offset</code>修改偏移量（如设为2，返回往上数第二行执行结果，必须为费复制）。<code>offset</code>为0表示对当前行执行。<code>default</code>表示目标行不存在时需要返回的默认值。</li><li><code>lead(expr)</code></li><li><code>lead(expr, offset)</code></li><li><code>lead(expr, offset, default)</code>: 和<code>lag</code>函数类似，不过是向下获取。</li><li><code>first_value(expr)</code>: 返回第一个行的数据</li><li><code>last_value(expr)</code>: 返回最后一行的数据</li><li><code>nth_value(expr, N)</code>: 返回第N行的数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/34274a932d5bced7fbe1fed335fb4567.png&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="翻译" scheme="http://www.codewoody.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="sqlite" scheme="http://www.codewoody.com/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 4</title>
    <link href="http://www.codewoody.com/posts/24622/"/>
    <id>http://www.codewoody.com/posts/24622/</id>
    <published>2019-07-15T05:44:07.000Z</published>
    <updated>2019-07-22T02:11:41.287Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://imgs.codewoody.com/uploads/big/162af9ffc7fbac0835c29904548c369e.jpg" alt="「长安十二时辰」还是非常好看的，安利一下！"><figcaption>「长安十二时辰」还是非常好看的，安利一下！</figcaption></figure><h2 id="新闻">新闻</h2><h3 id="广州越秀区--轻微醉驾从宽免刑"><a href="https://auto.ifeng.com/c/7nu1P1tbUae" target="_blank" rel="noopener">广州越秀区 -「轻微醉驾从宽免刑」</a></h3><p>虽然不是这周发生的事情，不过进来看到了，深感滑稽，放在这里</p><blockquote><p>从今年 4 月 1 日起，越秀区检察院在轻微醉驾案件中引入社会公益服务考察项目。轻微醉驾者在满足一定的申请条件后，通过在一个月内参加 40 个小时的社会公益服务，来获得不起诉决定的机会。截至目前，已有48名轻微醉驾者申请该公益服务考察项目，其中已有 46 名获得罪轻不起诉决定。</p></blockquote><h3 id="朝阳区爆发诺如病毒感染">朝阳区爆发诺如病毒感染</h3><blockquote><p>7月15日凌晨，北京朝阳官方微博通报，7月12日晚，接到群众反映朝阳区豆各庄地区部分小区居民出现腹泻情况，截止到7月14日20时，调查了到医院就诊的49人、自述有症状未就诊的105人，并采集了肛拭子和便标本105件，已检测79件，其中，52件检测出诺如病毒。从调查情况判断，存在诺如病毒感染情况。专家提示，诺如病毒感染是一种常见消化道传染病，传染性强，常见症状为腹泻、呕吐。</p></blockquote><h3 id="张扣扣被执行死刑">张扣扣被执行死刑</h3><blockquote><p>7月17日，张扣扣被执行死刑。2018年除夕，张扣扣为母报仇，刺死了上坟返途中的邻居王家大儿子和三儿子，随后到王家将王家父亲刺死。2019年1月8日，汉中中院一审当庭判处张扣扣死刑，其当庭上诉。4月11日，陕西高院驳回上诉维持死刑判决。</p></blockquote><h3 id="京阿尼第一工作室火灾">京阿尼第一工作室火灾</h3><blockquote><p>堪称二次元911。这个工作室是京都动画最重要的工作室，这里集中了大多数制作部门。监督、演出、作监、原画、中割、上色、CG、美术、摄影……我们通常看到的京都动画内部的视频/照片，也都是在这里拍摄的。</p><p>预计死亡人数会超过10人，数十人受伤。本次火灾为人为纵火。</p></blockquote><p><img src="https://imgs.codewoody.com/uploads/big/3a1638df0964523e510db699d06a9e4f.jpg"></p><h3 id="章莹颖案被告获无期判决">章莹颖案被告获无期判决</h3><blockquote><p>历时两天、12名陪审团成员用8小时27分的时间完成了讨论，没有就判处章莹颖案凶手克里斯滕森死刑获得统一意见。克里斯滕森被判处终身监禁。根据美国联邦法律，他将老死狱中，不得假释。</p></blockquote><figure><img src="https://imgs.codewoody.com/uploads/big/ec4086430c5b1098979291cc5ba8ffba.jpg" alt="被告人克里斯滕森 Brendt Christensen"><figcaption>被告人克里斯滕森 Brendt Christensen</figcaption></figure><h3 id="魅族李楠辞职">魅族李楠辞职</h3><blockquote><p>这几天，关于李楠辞职创业的消息传得沸沸扬扬。电子烟，机械键盘，这位曾经魅族的功臣，活跃的知乎答主，会选择哪个方向作为职业的下一站，是很多“煤油”关心的问题。而早在今年 5 月，李楠就已经从魅族主要人员中移除。</p><p>针对此事，黄章昨晚再次在魅族论坛语出惊人：“能挣钱的就是人才，不断亏钱的就是费财”。虽然没有指名道姓，但结合最近的传言，很难不让人产生联想。</p></blockquote><p><img src="https://imgs.codewoody.com/uploads/big/a710fc7fe849fee648b3416892fed024.jpg"></p><h2 id="资源">资源</h2><ul><li><a href="https://www.sqlite.org/windowfunctions.html" target="_blank" rel="noopener">SQLite Window Function</a>：在最近的仿真研究中使用了Window function，是之前比较少接触到的，但是功能非常强大！</li></ul><h2 id="言论">言论</h2><ul><li><p>从本质上来说，父母选择怎样的育儿方式，不取决于父母小时候的经历，而取决于父母对孩子现在与未来的预测。 -- <a href="https://songshuhui.net/archives/106133" target="_blank" rel="noopener">科学松鼠会</a></p></li><li><p>经济学研究的是人们如何做出选择。社会学研究的是人们其实并无多少选择余地。 - 经济学家James Duesenberry</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/3a1638df0964523e510db699d06a9e4f.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Weekly" scheme="http://www.codewoody.com/categories/Weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Weekly" scheme="http://www.codewoody.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Git:恢复一个已经在提交中被删除的文件</title>
    <link href="http://www.codewoody.com/posts/10723/"/>
    <id>http://www.codewoody.com/posts/10723/</id>
    <published>2019-07-12T06:43:00.000Z</published>
    <updated>2019-07-12T06:54:47.315Z</updated>
    
    <content type="html"><![CDATA[<p>这里要研究的问题是，如果我们在之前的某一个提交中删除了一个文件，如何使用git将此文件恢复出来。</p><a id="more"></a><p>首先我们要做的是找到当时删除的这个文件对应的提交。比较简便的方法是使用一些图形化的Git软件，可以直接浏览找到对应的提交。这些软件包括SourceTree，Github Desktop等。纯命令行的环境可以使用如下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --diff-filter=D --summary</span><br></pre></td></tr></table></figure><p>在找到对应的提交后，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout $commit~1 path/to/file.ext</span><br></pre></td></tr></table></figure><p>注意一下，这里的<code>$commit</code>指的是对应的commit id。后面的<code>~n</code>是git的一种语法，表明追溯某个提交的第<code>n</code>个祖先。详情可以参考<a href="https://www.bignerdranch.com/blog/git-treeishes-considered-awesome/" target="_blank" rel="noopener">Git Treeishes Considered Awesome</a>。那这里的意思就是检出删除这个文件的提交的上一个提交（届时那个文件还存在）中的对应文件。</p><p><a href="https://stackoverflow.com/a/953573/5081487" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里要研究的问题是，如果我们在之前的某一个提交中删除了一个文件，如何使用git将此文件恢复出来。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="git" scheme="http://www.codewoody.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>时空错乱的名称二则</title>
    <link href="http://www.codewoody.com/posts/53783/"/>
    <id>http://www.codewoody.com/posts/53783/</id>
    <published>2019-07-11T06:59:45.000Z</published>
    <updated>2019-07-11T07:31:14.251Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="荷兰豆">荷兰豆</h2><p>荷兰豆在中国叫荷兰豆，在荷兰叫中国豆，类似的情况还有：</p><ol type="1"><li><p>梅毒：意大利人叫那不勒斯症状、法国病、高卢病，法国人叫意大利病，俄罗斯叫波兰人病，日耳曼人叫西班牙病，阿拉伯人叫基督徒病，大溪地叫英国人病，日本叫唐疮，琉球疮，葡萄牙病，有意思的是，中国人称之为广东疮。这基本上反映了梅毒的传染过程。</p></li><li><p>过山车：在法国、意大利、葡萄牙、西班牙等一些地方，“过山车”的字面意思是“俄罗斯山峰”，这是因为过山车的原型是俄罗斯的雪橇，从雪山上滑下来。在法国，当时就叫Les Montagnes Russes（俄罗斯山峰）。重点来了，在俄罗斯，过山车叫&quot;американские горки&quot; [Amerikanskie gorki]，字面意思就是“美国山峰”。</p></li><li><p>手抓饼在大陆叫台湾手抓饼，在台湾叫天津葱抓饼。</p></li></ol><p>关于荷兰豆在荷兰被称为中国豆的<a href="https://www.guokr.com/post/342270/" target="_blank" rel="noopener">考证</a>：</p><p>(1)刚开始豌豆Pisum sativum是只吃豆的。</p><p>(2)然后在中国南部接近东南亚的地区，人们培育了一种可以吃豆荚的豌豆，我们叫荷兰豆，英语里叫Chinese snow pea, 学名为Pisum sativum var. saccharatum,豌豆苗是它的嫩芽</p><p>(3)再然后出现了另一种吃豆荚的豌豆snap pea, Pisum sativum var. macrocarpon,我们叫甜豆，豆荚更鼓。</p><p>最后美国人把2和3杂交了一下，就出现了sweet snap pea(4),适合完全生吃。所有这些生吃都无毒.</p><p>为什么要叫荷兰豆？应该是荷兰蔬菜育种比较强,所以被联系在了一起，跟荷兰人无关.</p><p>资料来源：Plant Breeding Reviews, Volume 21，Chapter 3. Origin, History, and Genetic Improvement of the Snap Pea (Pisum sativum L.)</p><p>下面是我搜索到的例子：</p><figure><img src="https://imgs.codewoody.com/uploads/big/4f2ff0133e781f7a2e4f1f8095786cbe.png" alt="Cooking Snow Peas"><figcaption><a href="https://whatscookingamerica.net/Q-A/Snowpeas.htm" target="_blank" rel="noopener">Cooking Snow Peas</a></figcaption></figure><h2 id="中情局十条诫令">中情局十条诫令</h2><blockquote><p>“十条诫令” : 这是此谣言在中国大陆地区使用的名称。其他名称包括：十条戒令，十大戒令。虽然此谣言在全世界各地都有不同版本和名称，最流行的二个国家是中国大陆和巴西。而且还会有不同的中文版本。其首次在1940年代的美国出现。现在在全世界不同国家继续流传，是有不同作者，不同版本的都会传奇。所以根本就没有原始文件的存在。美国的名称是“共产党革命章程”。巴西和西班牙则说是列宁写的十诫。中国大陆则谣传是美国中央情报局1951年的绝密文件。随着时间推移，谣言的内容也会不断增加。在中国大陆地区，现在已经出现美国中情局的十二条诫令，又加入了新的第一条，和最后第十二条。</p></blockquote><p>下面三张图，是我今天听说的北京四中的给高中生做的讲座的内容：</p><p><img src="https://imgs.codewoody.com/uploads/big/b83d2d8aba24f88fe22df2e7813339a2.jpg"></p><p><img src="https://imgs.codewoody.com/uploads/big/2053f33e3b536f8b5f8b57c4278f9b19.jpg"></p><p><img src="https://imgs.codewoody.com/uploads/big/34ad58b27d2789a8c3e9a16fd8702556.jpg"></p><p>美国版本为 Communist Rules for Revolution</p><p><img src="https://imgs.codewoody.com/uploads/big/4ecddf57c56d93d01eb41fb5215f2a2f.jpg"></p><p><a href="https://www.truthorfiction.com/communist-rules-for-revolution-found-by-allied-forces-in-dusseldorf-germany-fiction/" target="_blank" rel="noopener">谣传的内容</a>是协约国在德国Dusseldorf发现了Communist Rules for Revolution，翻译过来就是共产党革命章程的。其内容的精神，无外乎就是说应该通过腐化国家的年轻一代以策动革命。</p><p>从Google Books最早可以搜到提到“共产主义者革命章程”的书籍是出版于1964年。美国纽约时报，署名Donald Janson在1970年7月10日，就发表文章，指出这些内容是假的。根据该篇文章报导，1946年2月，最早的版本发表在‘新世界新闻’。</p><p>包括瑞士，法国，巴西，西班牙等地流传的版本，可以进一步看<a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E6%9D%A1%E8%AF%AB%E4%BB%A4#cite_note-snopes-2" target="_blank" rel="noopener">维基</a></p><p>我这边最早接触到这一「谣言」的渠道，是中国大陆军方人士制作的长达90分钟的宣传片《较量无声》中引用了“十条诫令”，并称是前美国中央情报总监艾伦·杜勒斯提出来颠覆中国共产政权的。</p><h2 id="结语">结语</h2><blockquote><p>我们的对外宣传部门挤满了没有脑子的翻译机器，但我毫无办法。-- 长者</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;荷兰豆在中国叫荷兰豆，在荷兰叫中国豆。
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="智商税" scheme="http://www.codewoody.com/tags/%E6%99%BA%E5%95%86%E7%A8%8E/"/>
    
      <category term="宗教" scheme="http://www.codewoody.com/tags/%E5%AE%97%E6%95%99/"/>
    
      <category term="政治" scheme="http://www.codewoody.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 3</title>
    <link href="http://www.codewoody.com/posts/41583/"/>
    <id>http://www.codewoody.com/posts/41583/</id>
    <published>2019-07-07T07:49:29.000Z</published>
    <updated>2019-07-22T02:04:21.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新闻">新闻</h2><h3 id="三体一在日本大卖">三体一在日本大卖</h3><figure><img src="https://imgs.codewoody.com/uploads/big/b0f83d6cc9c93cfdd25eae7d3ec7fb85.jpg" alt="日亚·三体"><figcaption>日亚·三体</figcaption></figure><p>见证三体逐渐成长为一个全球性的超级IP！</p><h3 id="北京市发布三个房屋出租合同范本"><a href="https://www.huxiu.com/article/307640.html?f=wangzhan" target="_blank" rel="noopener">北京市发布三个房屋出租合同范本</a></h3><p>7月8日，北京发布《北京市住房租赁合同》《北京市房屋出租经纪服务合同》《北京市房屋承租经纪服务合同》三个合同示范文本。示范文本均在说明中强调，不得改变房屋内部结构分割出租、出租房屋人均居住面积不得低于5平方米、每个房间居住的人数不得超过2人等有关禁止违法群租的文件规定内容。</p><p>此外，租金方面，合同明确规定，未经双方当事人协商一致，出租人不得在租赁期限内单方面提高租金。合同提前解除的，出租人应在合同解除后约定日期内退还已收但尚未发生的租金。承租人应当在合同解除后约定时间内搬离。</p><h3 id="逃犯条例修订已寿终正寝"><a href="https://cn.reuters.com/article/hk-chief-0709-tues-idCNKCS1U40B6?feedType=RSS&amp;feedName=CNTopGenNews" target="_blank" rel="noopener">《逃犯条例》修订已「寿终正寝」</a></h3><p>路透香港7月9日 - 香港特首林郑月娥周二称，社会目前的矛盾、纷争、愤怒等都由《逃犯条例》修例引起，承认有关工作是完全失败，并清晰说明《逃犯条例》修订已经“寿终正寝”，政府愿意聆听社会更广泛民意，平息纷争。</p><h3 id="ibm-以-340-亿美元收购red-hat">IBM 以 340 亿美元收购Red Hat</h3><p>根据路透社报道，IBM周二宣布以340亿美元正式收购红帽。这笔交易最初公布于去年十月，当时IBM表示将会以每股190美元的价格，用现金购买红帽的所有股份。</p><figure><img src="https://imgs.codewoody.com/uploads/big/8bd2e52ab04476ac85f1b92d09581c19.png" alt="IBM &amp; Red Hat"><figcaption>IBM &amp; Red Hat</figcaption></figure><p>此次交易也是IBM迄今为止最大规模的一次收购交易，在美国历史上也可以排在前列。撇开AOL和时代华纳的并购不谈，美国科技产业的前两大收购交易分别是2016年戴尔和EMC之间价值670亿美元的并购以及JDS Uniphase在2000年以410亿美元收购光学元件供应商SDL。</p><p>按照交易合约，这家开源企业软件制造商将并入IBM的混合云部门，而红帽的首席执行官吉姆·怀特赫斯特（Jim Whitehurst）将加入IBM的高管团队，向IBM的首席执行官罗睿兰（Ginni Rometty）汇报工作。</p><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E7%B4%85%E5%B8%BD%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">Red Hat</a></li></ul><h3 id="日本制裁韩国"><a href="https://www.guancha.cn/internation/2019_07_01_507678.shtml" target="_blank" rel="noopener">日本制裁韩国</a></h3><p>据日本《产经新闻》6月30日报道，日本政府将从7月4日开始限制对韩国出口部分半导体、OLED材料出口。韩联社称，韩国相关业界高度紧张，认为稍有不慎就会出现严重状况。日本经济产业省已经于7月1日上午，公布了相关决定。</p><p>涉及的被限制对韩出口的材料包括「氟聚酰亚胺」，「光刻胶」，以及「高纯度氟化氢」等三个品种。日本在这几个材料上的市场份额占据压倒性的优势。</p><p>日本之所以宣布制裁韩国，可能是日本不满韩国无视1965年协议，不断向日本发起「二战」劳工诉讼。不过日本方面否认了这一说法。日本内阁官房长官菅义伟2日向媒体表示，这是出于安全保障考虑而进行的适当的出口管理，并不是围绕“劳工”问题而采取的对抗措施。</p><p>3日，据韩联社报道，韩国执政的共同民主党、政府、青瓦台周三就日本限制对韩半导体材料出口的应对方案表示，政府推进对半导体材料、零部件、设备研发每年投入1万亿韩元（约合人民币58.8亿元）的方案，并正在对此进行可行性调查。日本此举也激怒了韩国民众，从3日开始，韩国网络上出现不少鼓励抵制日货的言论。《中央日报》称，被韩国网友点名的日本商品覆盖从知名家电到汽车、化妆品、服装、手表、酒类等数十个种类。不仅如此，韩国网络上还开始出现抵制赴日旅游的号召。韩联社称，韩国政府3日开始向WTO提出申诉，目前韩贸易部已开始审查相关法律文件。</p><figure><img src="https://imgs.codewoody.com/uploads/big/cecd35e56014638f312ca49592461279.jpg" alt="图片来自蒋校长"><figcaption>图片来自<a href="https://bbs.tiexue.net/post2_13465562_1.html" target="_blank" rel="noopener">蒋校长</a></figcaption></figure><blockquote><p>全世界都在打贸易战</p></blockquote><h3 id="阮一峰的科技爱好者周刊增加就业栏目">阮一峰的科技爱好者周刊增加就业栏目</h3><p>阮一峰也是非常有名的中文技术博客博主，我开始写Weekly就是受他的科技爱好者周刊的启发。<a href="http://www.ruanyifeng.com/blog/2019/07/weekly-issue-64.html" target="_blank" rel="noopener">本周阮一峰想要为他的周刊增加一个《就业栏目》</a>。</p><blockquote><p>向大家报告，我想为周刊增加一个 《就业栏目》 ，每周发布招聘信息。如果你的公司正在招人，欢迎联系我（邮箱：yifeng.ruan@gmail.com）。</p></blockquote><h2 id="软件推荐">软件推荐</h2><p><a href="https://languagetool.org/" target="_blank" rel="noopener">LanguageTool</a> 是一款支持中文、英语、德语、日语等 27 种语言的语法与拼写检查工具，拥有网页版、Chrome 和 Firefox 插件，LibreOffice、Google Docs、MS Word、甚至还有 Android、Emacs、Vim、VS Code 等平台插件，服务器端开源。</p><p><img src="https://imgs.codewoody.com/uploads/big/1f611c5a984fff3067370d3d61458ec4.png"></p><h2 id="资源">资源</h2><ul><li><p>学习Java以及JavaScript的网站： <a href="https://javabrains.io/" target="_blank" rel="noopener">Java Brains</a></p></li><li><p><a href="https://jalammar.github.io/visual-numpy/" target="_blank" rel="noopener">Numpy可视化介绍</a></p></li><li><p><a href="https://tableconvert.com/" target="_blank" rel="noopener">表格转化工具</a>，支持markdown, json, html, xml, yaml等数据格式</p></li></ul><h2 id="段子与言论">段子与言论</h2><ul><li><p>2017 年初，为了验证亚马逊公司的「无限云」，一名叫 Beaston02 的男子坚持录制了 2000 TB 色情片上传到亚马逊云。半年后，亚马逊停止了无限云服务。-- <a href="https://sspai.com/post/55622" target="_blank" rel="noopener">来源</a></p></li><li><p>马克思的学说在今天的遭遇，正如历史上被压迫阶级在解放斗争中的革命思想家和领袖的学说常有的遭遇一样。当伟大的革命家在世时，压迫阶级总是不断迫害他们，以最恶毒的敌意、最疯狂的仇恨、最放肆的造谣和诽谤对待他们的学说。在他们逝世以后，便试图把他们变为无害的神像，可以说是把他们偶像化，赋予他们的名字某种荣誉，以便“安慰”和愚弄被压迫阶级，同时却阉割革命学说的内容，磨去它的革命锋芒，把它庸俗化。现在资产阶级和工人运动中的机会主义者在对马克思主义作这种“加工”的事情上正一致起来。他们忘记、抹杀和歪曲这个学说的革命方面，革命灵魂。他们把资产阶级可以接受或者觉得资产阶级可以接受的东西放在第一位来加以颂扬。 -- 列宁</p></li><li><p>发达国家人均预期寿命：美国以冠绝全球，接近18%的医疗GDP占比，人均寿命如图。（<a href="https://ourworldindata.org/the-link-between-life-expectancy-and-health-spending-us-focus" target="_blank" rel="noopener">出处</a>）</p></li></ul><p><img src="https://imgs.codewoody.com/uploads/big/fbca06ae942781af6fe9cfccf85b0996.jpg"></p><ul><li>要承认人工智能是作者，事实上也就意味着要在著作权法上创设一种新的独立法律主体，这将遇到极大的法律和伦理障碍，在相当长的一段时间内恐怕都难以实现。 - <a href="http://www.nipso.cn/onews.asp?id=46776" target="_blank" rel="noopener">人大法学院教授万勇</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/f7e6647dc85e02dcbaadb4609941a503.jpg&quot; alt=&quot;进击的巨人第四季要等到2020年了&quot;&gt;&lt;figcaption&gt;进击的巨人第四季要等到2020年了&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;终于看完了第三季，巨人可以说是近年来最优秀的动漫作品了。而且第三季的最后几集又将整个作品的世界观和精神层次提升了一大截，可以说是相当起来第四季艾主席的表现了。&lt;/p&gt;
    
    </summary>
    
      <category term="Weekly" scheme="http://www.codewoody.com/categories/Weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Weekly" scheme="http://www.codewoody.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Struct in Vector: 进一步讨论</title>
    <link href="http://www.codewoody.com/posts/62430/"/>
    <id>http://www.codewoody.com/posts/62430/</id>
    <published>2019-07-02T02:04:44.000Z</published>
    <updated>2019-07-12T06:10:07.074Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们讨论了<a href="C++中将结构体放置在std::vector容器内的操作风险">C++中将结构体放置在std::vector容器内的操作风险</a>。这里我们来进一步讨论如何处理在容器中存储的结构体数据。</p><a id="more"></a><p>前文中提到，如果我们尝试获取容器中的结构体时，我们直接拿到的是该结构体的拷贝，如果要对结构体成员修改，我们需要整体进行两次复制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct A&gt; data;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">val</span> = <span class="title">data</span>.<span class="title">at</span> (0);</span></span><br><span class="line">val.b = c;</span><br><span class="line">data[<span class="number">0</span>] = val;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">这种操作显然是不经济。一种『粗暴』的方法是使用`<span class="built_in">std</span>::<span class="built_in">vector</span>::data`函数获取底层数据的指针，然后操作这个指针。但是这种方法不太优雅，也不安全。合适的做法是使用引用</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct A&gt; data;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &amp; <span class="title">val</span> = <span class="title">data</span>[0];</span></span><br><span class="line">val.b = c;</span><br></pre></td></tr></table></figure><p>放在遍历的场景中，可以使用如下的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct A&gt; data;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : data) &#123;...&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们讨论了&lt;a href=&quot;C++中将结构体放置在std::vector容器内的操作风险&quot;&gt;C++中将结构体放置在std::vector容器内的操作风险&lt;/a&gt;。这里我们来进一步讨论如何处理在容器中存储的结构体数据。&lt;/p&gt;
    
    </summary>
    
      <category term="编程研究" scheme="http://www.codewoody.com/categories/%E7%BC%96%E7%A8%8B%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="C++" scheme="http://www.codewoody.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CPP: STL map的用法</title>
    <link href="http://www.codewoody.com/posts/3626/"/>
    <id>http://www.codewoody.com/posts/3626/</id>
    <published>2019-07-01T09:23:13.000Z</published>
    <updated>2019-07-12T06:10:21.731Z</updated>
    
    <content type="html"><![CDATA[<p>抛开具体的编程语言场景，map是一类非常基本的数据组织形式，其作用是将一个可Hash的值，映射到另一个值，而且一般来讲是一对一的（存在一对多的情况）。map内部使用了红黑树，这棵树具有对数据自动排序的功能，使得对map的检索意义达到非常高的效率。基于键值的查找的复杂度是Log(N)。</p><p>这里讲讲C++标准库里面map的用法。</p><a id="more"></a><h2 id="使用map">使用map</h2><p>头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明时需要指明键与值的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; persons;</span><br></pre></td></tr></table></figure><h2 id="数据插入">数据插入</h2><p>数据插入有三种方法：</p><ol type="1"><li>使用<code>insert</code>函数插入<code>pair</code>数据，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line">students.insert (<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; (<span class="number">1</span>, <span class="string">"Student A"</span>));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>用insert函数插入<code>value_type</code>的数据，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line">students.insert (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"Student A"</span>));</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>用Subscript方式插入数据，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line">students[<span class="number">1</span>] = <span class="string">"Student A"</span></span><br></pre></td></tr></table></figure><p>上面三种插入方式的区别在于，第三种默认会覆盖已经存在的映射，而前两个不会。前两个插入方式等价，在插入的键已经存在于映射中时，当前的插入语句会被忽略。那么如何知道插入是否成功呢？可以通过<code>insert</code>函数的返回值来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res为pair&lt;map&lt;int, string&gt;::iterator, bool&gt;乐行</span></span><br><span class="line"><span class="keyword">auto</span> res = students.insert (pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; (<span class="number">1</span>, <span class="string">"Student A"</span>));</span><br><span class="line"><span class="keyword">if</span> (res.second == <span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert successfully"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert fail"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="数据的遍历">数据的遍历</h2><p>使用迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = students.begin (); iter != students.end (); iter ++ )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// first为key，second为value</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="查找并获取map中的元素">查找并获取map中的元素</h2><p>查找是map的核心功能。我们可以使用<code>find</code>函数来进行查找。当找到目标时，返回一个迭代器，否则返回<code>end</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> iter = students.find (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (iter == students.end ())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"not found "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">string</span> studentName = iter.second;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素">删除元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; students;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> iter = students.find (<span class="number">1</span>);</span><br><span class="line">student.erase (iter);</span><br><span class="line"></span><br><span class="line">student.erase (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这会清空整个map</span></span><br><span class="line">student.erase (students.begin (), students.end ());</span><br></pre></td></tr></table></figure><h2 id="further-reading">Further Reading</h2><ul><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">C++中的STL中map用法详解</a></li><li><a href="http://www.cplusplus.com/reference/map/map/map/" target="_blank" rel="noopener">std::map::map</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抛开具体的编程语言场景，map是一类非常基本的数据组织形式，其作用是将一个可Hash的值，映射到另一个值，而且一般来讲是一对一的（存在一对多的情况）。map内部使用了红黑树，这棵树具有对数据自动排序的功能，使得对map的检索意义达到非常高的效率。基于键值的查找的复杂度是Log(N)。&lt;/p&gt;
&lt;p&gt;这里讲讲C++标准库里面map的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://www.codewoody.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 2</title>
    <link href="http://www.codewoody.com/posts/60429/"/>
    <id>http://www.codewoody.com/posts/60429/</id>
    <published>2019-07-01T03:28:09.000Z</published>
    <updated>2019-07-07T07:46:09.000Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="新闻">新闻</h2><h3 id="rick-and-morty-第四季将会在11月上映">Rick and Morty 第四季将会在11月上映</h3><figure><img src="https://imgs.codewoody.com/uploads/big/70077b2773d87db24e9407011d4830f9.jpeg" alt="Rick and Morty · Season 4"><figcaption>Rick and Morty · Season 4</figcaption></figure><h3 id="华为禁令取消"><a href="https://www.williamlong.info/archives/5750.html" target="_blank" rel="noopener">华为禁令「取消」</a></h3><p>6月29日，为期3天（6月27日至29日）的二十国集团领导人第十四次峰会刚刚在日本大阪落下帷幕。29日上午，中、美两国元首举行了约80分钟的会晤，此后两国共同宣布了两大成果：1）中美双方同意在平等和相互尊重的基础上重启经贸磋商。2）美方表示不再对中国出口产品加征新的关税。</p><p>在两国元首会谈之后，美国总统特朗普在记者会上表示，同意让美国公司继续销售产品给华为。</p><p>特朗普解释称，这些卖给华为的产品都是美国公司制造的，是很复杂很科学的产品，是只有美国拥有技术和在制造的产品。“实际上我们在硅谷做的事情令人难以执行，没有人能和我们竞争，所以我同意 -- 我很容易地就同意允许他们继续出售这些产品”，特朗普说，“我们让他们继续卖给华为。”</p><p>据华尔街日报报道，特朗普称将允许美企向华为供货，中国则将开始购买大量美国农产品。他强调了中国大宗采购美国农产品的意愿，将其归为允许向华为出售美国产品和推迟新关税的一大理由。据美国农业部，周五会谈前，中国采购了54.4万吨大豆。？</p><p>美国家经济委员会主席拉里·库德洛在电视采访中更加详细地解释了解禁一事。他表示解禁即将生效，美国商务部可能会考虑“授予一些临时许可证”，让美国公司与华为恢复业务。对于解禁范围，他强调华为仅可以购买“其它国家同样广泛销售的美国芯片产品”，否认这是“特赦”，表示国家安全仍然是最重要的考虑因素，只要不构成国家安全问题，华为可以恢复从美国企业采购产品。</p><h3 id="fuchsia官方开发者网站上线"><a href="https://www.phonearena.com/news/Google-launches-developer-site-for-Fuchsia_id117171" target="_blank" rel="noopener">Fuchsia官方开发者网站上线</a></h3><p>Fuchsia 是 Google 打造的下一代操作系统，它不基于 Linux 内核，运行方式也和 Android 完全不同，但可以通过相关工具让 Android 应用可以移植到新系统中。近日 Google 也正式上线了 Fuchsia 的 开发者网站，从这个网站中开发者可以了解到 Fuchsia 的系统开发进展及其采用的技术，为后续开发做好准备。</p><p>ps: Android的生态其实有点太过恶劣了：</p><blockquote><p>安卓碎片化严重到什么地步？安卓本身有12个版本，如果每个版本有12个厂商，每个厂商有12个手机型号，因此安卓生态至少包含1,728种&quot;版本- 品牌 - 设备&quot;的组合。</p></blockquote><h3 id="大兴机场竣工"><a href="https://www.ifanr.com/1230698?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=" target="_blank" rel="noopener">大兴机场竣工</a></h3><figure><img src="https://imgs.codewoody.com/uploads/big/e2e40d7ca813e5b6b63a3e9feae4efa0.jpg" alt="大兴机场"><figcaption>大兴机场</figcaption></figure><p>时 4 年半，北京大兴国际机场于 6 月 30 日正式竣工，9 月底将投入运营，各家航空公司也陆续公布了在新机场的航线投入计划。</p><p>各家航司的转场投运情况如下：</p><ul><li>国航系（国航、国货航、深航、山航、昆明航、国航内蒙、北京航、大连航）留守首都机场，但国航在大兴有 10% 航班时刻；</li><li>东航系（东航、上航、中联航、东航江苏、东航云南、东航武汉）转场大兴，但东航的京沪快线留守首都机场；</li><li>南航系（南航、厦航、河北航、江西航、重庆航、汕头航、珠海航、贵州航、南航河南）转场大兴；</li><li>海航、大新华航等留守首都机场；</li><li>首都航空转场大兴；</li><li>其他国内航司可选择首都机场或大兴机场任一机场运行，但不得两场运行；</li><li>允许外航及港澳台地区航空公司自行选择运行机场包括两场运行。</li></ul><h3 id="李彦宏演讲被砸场子"><a href="https://www.zhihu.com/question/333022816" target="_blank" rel="noopener">李彦宏演讲被砸场子</a></h3><p>只是为了这张图载一下这个新闻：</p><figure><img src="https://imgs.codewoody.com/uploads/big/94a887f5e808a756a8fded60d728edac.jpeg" alt="宏颜获水"><figcaption>宏颜获水</figcaption></figure><blockquote><p>7月3日，在2019年百度AI开发者大会上发生突发状况，百度董事长、CEO董事长李彦宏在展示完小度最新功能后，被台下观众泼水。由于事发突然，现场一度陷入沉默。面对这样的突发状态，现场观众集体给李彦宏加油打气，李彦宏也很快调整状态，并调侃道：发展AI的路上就是会遇到这种挫折。</p></blockquote><figure><img src="https://imgs.codewoody.com/uploads/big/adf636dd16a6ebf3dca5965471663920.gif" alt="事件现场"><figcaption>事件现场</figcaption></figure><h3 id="北京石景山发生枪战">北京石景山发生枪战</h3><p>应该与扫黑行动有关，据说肇事者已经被抓走了。具体情况不明，舆论被管控了。</p><h3 id="新城控股董事长王振华涉嫌猥亵女童"><a href="https://www.zhihu.com/question/333086645" target="_blank" rel="noopener">新城控股董事长王振华涉嫌猥亵女童</a></h3><figure><img src="https://imgs.codewoody.com/uploads/big/c0f7e4730be3bb36084336bd851b3f8b.jpg" alt="犯罪嫌疑人"><figcaption>犯罪嫌疑人</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/284c43e62d1f48e769b67565600e8f78.png" alt="警情通报"><figcaption>警情通报</figcaption></figure><p>据悉，犯罪行为发生于6月29日下午，地点为大渡河路一家五星级酒店。被猥亵女童事后向在江苏的母亲打电话哭诉，母亲即来沪报警，王某随即被采取强制措施。目前女童已验伤情，阴道有撕裂伤，构成轻伤。</p><p>据最新消息，带女童入住酒店的女子周某也已到案。周某49岁，江苏徐州人。据其供述，事发当天，她带了两个女孩入住酒店，一个9岁，一个12岁。两个女孩的母亲为周某朋友。周某谎称带两女孩去上海迪斯尼玩，从江苏带至上海。当天王某对9岁女童实施犯罪，事后给付周某现金1万元。</p><figure><img src="https://imgs.codewoody.com/uploads/big/d4af1fb2de3140c9a2695823155c924d.jpg" alt="王振华身家3000亿的帝国"><figcaption>王振华身家3000亿的帝国</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/198c60e8f0df06dc0443d0722566eea0.jpg" alt="王振华的更多背景资料"><figcaption>王振华的更多背景资料</figcaption></figure><h2 id="软件推荐">软件推荐</h2><p><a href="https://mathpix.com/" target="_blank" rel="noopener"><strong>Mathpix</strong></a>: 将图片转化成Latex公式，重点是这款软件是免费的！</p><p><img src="https://mathpix.com/images/snip-page/gif_2.gif"> <img src="https://mathpix.com/images/snip-page/gif_3.gif"></p><h2 id="文章与言论">文章与言论</h2><ul><li><p><a href="https://medium.com/swlh/why-defensive-programming-is-the-best-way-for-robust-coding-cfa790fe04cd" target="_blank" rel="noopener">Why defensive programming is the best way for robust coding</a></p></li><li><p><a href="https://www.zhihu.com/question/23979077/answer/730070106" target="_blank" rel="noopener">原生动物是如何演化成后生动物的？</a> <img src="https://imgs.codewoody.com/uploads/big/8aa938aa976af708b6f2a5496d68107b.jpg" alt="Nothing in biology makes sense except in the light of evolution. -- Dobzhansky"></p></li><li><p>日常劝退：<a href="https://www.sciencemag.org/careers/2019/06/it-s-ok-quit-your-phd" target="_blank" rel="noopener">It's ok to quit your Ph.D</a>，中文:<a href="https://zhuanlan.zhihu.com/p/71702212" target="_blank" rel="noopener">Science「劝退文」：读博压力山大，是时候退学了</a></p></li></ul><blockquote><p>读博无疑是一个痛苦的过程。甚至有人说，如今，读博已经变成了“赌博”。面对学业压力，很多博士生选择延期毕业。近日，《科学》杂志发表长文，提供了另一种选择：退学。美国研究生院理事会（Council of Graduate School）公布的数据显示，约1/4的美国科学与工程专业博士生在入学的头3年选择退学。《科学》杂志此次采访了9位博士阶段退学者，并总结了退学的3点理由：对研究失去兴趣，开始追寻其他事业，或是因在学术界的遭遇而心灰意冷。</p></blockquote><ul><li><a href="https://sspai.com/post/55433" target="_blank" rel="noopener">如何更快地读一本书</a></li></ul><figure><img src="https://imgs.codewoody.com/uploads/big/1bf513742dc4e3fe0aa2cd739cc6a1ee.jpeg" alt="呼吸读书法"><figcaption>呼吸读书法</figcaption></figure><ul><li><p>为什么<strong>供给能创造自己的需求</strong>呢？实际上，当生产者还没有生产或提供某种新的商品或消费品时，人们不能真正地看到或意识到这种东西带来的用处，因此很难想到对它的实际需求。就像是地铁，为什么10年前没有四通八达的地铁线路，人们也能按部就班地过日子，没有哭着喊着说没有地铁就不能活呢？这是因为当时人们还没有体会过地铁给他们带来的便捷，生活也并不依赖于它，因此并没有对于它有过于迫切的需求。相反，如果换成现在的我们失去了地铁，整个城市或许都会因此而崩溃。 -- <a href="https://www.toutiao.com/i6708094111167021572/?tt_from=weixin_moments&amp;utm_campaign=client_share&amp;wxshare_count=2&amp;from=timeline&amp;share_type=original&amp;timestamp=1562026117&amp;app=news_article&amp;utm_source=weixin_moments&amp;isappinstalled=0&amp;utm_medium=toutiao_android&amp;req_id=201907020808360100180692209643852&amp;group_id=6708094111167021572&amp;pbid=6677033007465252355" target="_blank" rel="noopener">地铁越修越多，交通反而拥挤</a></p></li><li><p>经济权力就是权力本身。-- <a href="https://www.zhihu.com/question/271847850/answer/726333668" target="_blank" rel="noopener">知乎 - 罗一觉</a></p></li><li><p>你问我宇宙大爆炸之前发生的事情，就像问我南极以南是什么地方。 -- 霍金</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/70077b2773d87db24e9407011d4830f9.jpeg&quot;&gt;
    
    </summary>
    
      <category term="Weekly" scheme="http://www.codewoody.com/categories/Weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Weekly" scheme="http://www.codewoody.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Hexo启用Han支持过程中发现的问题</title>
    <link href="http://www.codewoody.com/posts/36496/"/>
    <id>http://www.codewoody.com/posts/36496/</id>
    <published>2019-06-29T07:04:54.000Z</published>
    <updated>2019-07-12T06:10:47.333Z</updated>
    
    <content type="html"><![CDATA[<p>Han指的是<a href="https://hanzi.pro/manual/" target="_blank" rel="noopener">「汉字标准格式」</a>。 「汉字标准格式」是一个集合了「语意样式标准化」「文字设计」「高级排版功能」等三大概念的网页排版框架，使用Sass及JavaScript构架而成。其专为汉字网页提供的美观而标准化的环境，不仅符合传统阅读习惯、更为萤幕阅读提供了既成标准，得以完整解决现今汉字网页设计的排版需求。</p><figure><img src="https://hanzi.pro/img/typefaces.svg" alt="汉字标准格式"><figcaption>汉字标准格式</figcaption></figure><p>总而言之，使用Han这个框架可以让排版更好看。按道理，启用Han应该在NexT主题中的选项即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">han:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>不过这么设置之后还是不行。原因是启用之后只会引入CSS，而没有引入js渲染，导致一些比较高级的排版效果，如<a href="https://hanzi.pro/manual/hang_de_zucheng" target="_blank" rel="noopener">标点调整</a>无法使用。因此，还需要手动调整一下。于<code>themes/next/layout/_layout.swig</code>的<code>body</code>标签底部加入如下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ethantw.github.io/Han/latest/han.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.hinst = Han().setRoutine([</span></span><br><span class="line"><span class="javascript">      <span class="string">'initCond'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderElem'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderJiya'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderHanging'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'renderHWS'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'correctBasicBD'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'substCombLigaWithPUA'</span></span></span><br><span class="line"><span class="undefined">    ]).render()</span></span><br><span class="line"><span class="undefined">  &#125;()</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：<a href="https://hanzi.pro/manual/anzhuang_yu_qiyong" target="_blank" rel="noopener">使用文档</a>中给的cloudflare CDN地址里面的js文件渲染有问题，会导致标点不可见，使用<code>github.io</code>这个版本提供的文件就没有问题。另外，如果本地的<code>han.min.css</code>有问题，也可以切换成<code>github.io</code>版本。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://hanzi.pro/img/typefaces.svg&quot; alt=&quot;汉字标准格式&quot;&gt;&lt;figcaption&gt;汉字标准格式&lt;/figcaption&gt;
&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>C++中将结构体放置在std::vector容器内的操作风险</title>
    <link href="http://www.codewoody.com/posts/35148/"/>
    <id>http://www.codewoody.com/posts/35148/</id>
    <published>2019-06-28T08:39:21.000Z</published>
    <updated>2019-07-02T02:04:32.919Z</updated>
    
    <content type="html"><![CDATA[<p>有一组长度不固定的参数需要传输，且参数形式为结构体，那么一个比较简单的方法是将这些参数作为一个<code>std::vector</code>。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct ExampleStruct&gt; data)</span></span>;</span><br></pre></td></tr></table></figure><p>由于C++是采用值传递的方式，每次对<code>std::vector</code>进行元素的存取操作时，都会对涉及的结构体进行复制。如果结构体的数量比较多，或者结构体的体积比加大，那么这种方式对于计算和内存资源的浪费就比较大了。</p><a id="more"></a><p>那么，折中的办法是在<code>std::vector</code>中存放指针。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct ExampleStruct *&gt; data)</span></span>;</span><br></pre></td></tr></table></figure><p>不过，这就给指针的生命周期管理带来了很大的挑战，而且可能会引入非常多耦合性很强的代码。如果函数是state-less，即只对输入参数进行计算，而不更改其他的状态变量，问题倒不是很严重。反之，就会存在很多比较大的漏洞。</p><p>由于局部变量存在作用范围的限制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ExampleStruct</span> <span class="title">a</span>;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  data.push_back (&amp;a);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  f (data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当离开调用<code>f</code>的函数的作用域时，<code>a</code>就会被释放，后续在其他地方访问<code>data</code>时，对应的指针指向的内存区域已经被释放掉了，对其进行访问会导致错误。使用<code>new</code>来讲结构体创建在堆内存上可以解决这个问题，但是这意味着后续这一数据已经利用完之后，要确保此处申请的内存被恰当地释放掉。随着业务逻辑的复杂化，要准确做到这一点会非常困难，强行实现也会带来很多强耦合的代码，扩大引入bug的风险。</p><p>我们剩下的选择，就是使用智能指针<code>std::shared_ptr</code>自动管理堆内存的声明周期。就是形式有点复杂了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::share_ptr&lt;struct ExampleStruct&gt;&gt; data)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一组长度不固定的参数需要传输，且参数形式为结构体，那么一个比较简单的方法是将这些参数作为一个&lt;code&gt;std::vector&lt;/code&gt;。例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;struct ExampleStruct&amp;gt; data)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于C++是采用值传递的方式，每次对&lt;code&gt;std::vector&lt;/code&gt;进行元素的存取操作时，都会对涉及的结构体进行复制。如果结构体的数量比较多，或者结构体的体积比加大，那么这种方式对于计算和内存资源的浪费就比较大了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程研究" scheme="http://www.codewoody.com/categories/%E7%BC%96%E7%A8%8B%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
      <category term="C++" scheme="http://www.codewoody.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何自己搭建一个Time Machine服务器</title>
    <link href="http://www.codewoody.com/posts/14680/"/>
    <id>http://www.codewoody.com/posts/14680/</id>
    <published>2019-06-28T02:52:05.000Z</published>
    <updated>2019-06-28T03:00:55.912Z</updated>
    
    <content type="html"><![CDATA[<p>如何在Ubuntu上搭建一个简洁的Time Machine服务器呢？网上找到的教程说的都比较杂，这里整理一个刚刚经过实践检验的方法来供大家参考。目标系统是<code>Ubuntu 16.04 LTS</code>。 <a id="more"></a></p><h3 id="安装需要的工具">1. 安装需要的工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install netatalk avahi-daemon</span><br></pre></td></tr></table></figure><h3 id="创建一个用于专门用来运行time-machine进程的用户">2. 创建一个用于专门用来运行Time Machine进程的用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -c "Time machine" -m -s /bin/bash tm</span><br></pre></td></tr></table></figure><p>我这里命名为<code>tm</code>，你可以替换为任何你定的名字，但是最好不要使用<code>root</code>用户。 接下来给新用户设定密码 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd tm</span><br></pre></td></tr></table></figure></p><h3 id="准备文件夹">3. 准备文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -R /home/tm/TimeMachineFolder</span><br><span class="line">sudo chown -R tm /home/tm/TimeMachineFolder</span><br></pre></td></tr></table></figure><h3 id="设置netatalk">4. 设置<code>netatalk</code></h3><p>首先我们将原有的配置文件备份 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/netatalk/AppleVolumes.default /etc/netatalk/AppleVolumes.default.old</span><br></pre></td></tr></table></figure></p><p>然后创建一个新的配置文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/netatalk/AppleVolumes.default</span><br></pre></td></tr></table></figure></p><p>使用你偏好的编辑器（vim，nano之类）向这个配置文件中加入如下内容 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:DEFAULT: options:upriv,usedots</span><br><span class="line">/home/tm/TimeMachineFolder "My Time Machine" options:tm volsizelimit:500000 allow:tm</span><br></pre></td></tr></table></figure></p><p>注意将第二行的文件夹路径设定为你再第三步中创建的文件夹的路径。另外，第二行中的<code>volsizelimit</code>设定了Time Machine将会使用的最大硬盘空间，单位是MB。</p><h3 id="重启netatalk服务来应用更改">5. 重启<code>netatalk</code>服务来应用更改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service netatalk restart</span><br></pre></td></tr></table></figure><h3 id="在mac上连接到time-machine">6. 在Mac上连接到Time Machine</h3><p>首先直接尝试在Time Machine中选择这个服务器（会显示在可用磁盘下面，名字显示为第四步中你<code>netatalk</code>设置文件中指定的名字）。 如果你无法找到，那么打开Finder并按下⌘+K，在弹出来的窗口中，于服务器地址一栏输入<code>afp://IP.of.your.server/</code>，然后点连接。如果提示需要输入用户名和密码来登录，那就输入第二步中你设定的用户名密码即可。</p><figure><img src="https://imgs.codewoody.com/uploads/big/408d6956cd13b4c671b4519c1115d97c.png" alt="示意图"><figcaption>示意图</figcaption></figure><p>ref：<a href="http://dae.me/blog/1660/concisest-guide-to-setting-up-time-machine-server-on-ubuntu-server-12-04/" target="_blank" rel="noopener">Concisest guide to setting up Time Machine server on Ubuntu Server 12.04, 14.04 &amp; Debian | Dae’s blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在Ubuntu上搭建一个简洁的Time Machine服务器呢？网上找到的教程说的都比较杂，这里整理一个刚刚经过实践检验的方法来供大家参考。目标系统是&lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="macOS" scheme="http://www.codewoody.com/tags/macOS/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>键盘上的符号的英文读法</title>
    <link href="http://www.codewoody.com/posts/20487/"/>
    <id>http://www.codewoody.com/posts/20487/</id>
    <published>2019-06-28T02:49:04.000Z</published>
    <updated>2019-06-28T02:55:34.098Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">! 叹号 exclamation mark/bang </span><br><span class="line">? 问号 question mark </span><br><span class="line">, 逗号 comma </span><br><span class="line">. 点号 dot/period/point </span><br><span class="line">: 冒号 colon </span><br><span class="line">; 分号 semicolon </span><br><span class="line">” 双引号 quotation marks/double quote </span><br><span class="line">‘ 单引号/撇号 apostrophe/single quote </span><br><span class="line">` 重音号 backquote/grave accent </span><br><span class="line">* 星号 asterisk/star </span><br><span class="line">+ 加号 plus sign </span><br><span class="line">- 减号/横线 hyphen/dash/minus sign/ </span><br><span class="line">= 等号 equal sign </span><br><span class="line">/ 斜线 slash </span><br><span class="line">\ 反斜线 backslash/escape </span><br><span class="line">| 竖线 bar/pipe/vertical bar </span><br><span class="line">_ 下划线 underline/underscore </span><br><span class="line">$ 美元符号 dollar sign </span><br><span class="line">@ at at sign </span><br><span class="line"># 井号 crosshatch/sharp/hash </span><br><span class="line">% 百分号 percent sign/mod </span><br><span class="line">&amp; and/和/兼 and/ampersand </span><br><span class="line">^ 折音号 circumflex/caret </span><br><span class="line">~ 波浪号 tilde </span><br><span class="line">&#123;&#125; （左右）花括号/大括号 (left/right|open/close) braces </span><br><span class="line">[] （左右）方括号/中括号 (left/right|open/close) brackets </span><br><span class="line">() （左右）圆括号/小括号 (left/right|open/close) parentheses </span><br><span class="line">&lt;&gt; 尖括号 angle brackets </span><br><span class="line">&lt; 大于号 less than </span><br><span class="line">&gt; 小于号 greater than</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MAC: @rpath的坑</title>
    <link href="http://www.codewoody.com/posts/21028/"/>
    <id>http://www.codewoody.com/posts/21028/</id>
    <published>2019-06-28T02:47:47.000Z</published>
    <updated>2019-06-28T08:40:45.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem">Problem</h2><p>这篇文章的缘由是我在尝试使用<a href="https://www.nsnam.org" target="_blank" rel="noopener">ns3</a>带的NetAnim程序时，显示了下面这个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/QtGui.framework/Versions/4/QtGui</span><br><span class="line">  Referenced from: /path/to/ns-allinone-3.28/netanim-3.108/./NetAnim</span><br><span class="line">  Reason: image not found</span><br><span class="line">[1]    86663 abort      ./NetAnim</span><br></pre></td></tr></table></figure><a id="more"></a><p>这是一个动态链接的错误，所以没法通过编译的时候添加<code>LDFLAGS</code>来解决。不过错误里面的<code>@rpath</code>这个东西倒是挺有意思，显然并不是环境变量。我在网上查了很多，但是大多数是围绕xcode讨论的，不太适用于我面临的场景（命令行）。不过这些文章（如<a href="http://www.tanhao.me/pieces/1361.html/" target="_blank" rel="noopener">这篇</a>)能够大致阐明<code>@rpath</code>的用途。简而言之，<code>@rpath</code>是一个类似Shell中的<code>PATH</code>的变量，程序在执行时会从<code>@rpath</code>指定的路径中寻找动态链接库文件。那么剩下的问题就是我们如何操作这个变量了。</p><h2 id="solution">Solution</h2><p>通过<code>otool</code>我们可以查看一个程序的动态链接文件搜索地址，例如我要用的<code>NetAnim</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L ./NetAnim</span><br><span class="line">./NetAnim:</span><br><span class="line">@rpath/QtGui.framework/Versions/4/QtGui (compatibility version 4.8.0, current version 4.8.7)</span><br><span class="line">@rpath/QtCore.framework/Versions/4/QtCore (compatibility version 4.8.0, current version 4.8.7)</span><br><span class="line">/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.0)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4)</span><br></pre></td></tr></table></figure><p>而我们可以通过<code>install_name_tool</code>来对这些地址进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ install_name_tool -h</span><br><span class="line">Usage: /Library/Developer/CommandLineTools/usr/bin/install_name_tool [-change old new] ... [-rpath old new] ... [-add_rpath new] ... [-delete_rpath old] ... [-id name] input</span><br></pre></td></tr></table></figure><p>对我而言，我需要将Qt4的动态链接库添加到<code>NetAdmin</code>的搜索路径中去，可以使用如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -add_rpath /usr/<span class="built_in">local</span>/Cellar/qt@4/4.8.7_3/lib ./NetAnim</span><br></pre></td></tr></table></figure><p>大功告成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;这篇文章的缘由是我在尝试使用&lt;a href=&quot;https://www.nsnam.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ns3&lt;/a&gt;带的NetAnim程序时，显示了下面这个错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dyld: Library not loaded: @rpath/QtGui.framework/Versions/4/QtGui&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Referenced from: /path/to/ns-allinone-3.28/netanim-3.108/./NetAnim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Reason: image not found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1]    86663 abort      ./NetAnim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Debug" scheme="http://www.codewoody.com/categories/Debug/"/>
    
    
      <category term="macOS" scheme="http://www.codewoody.com/tags/macOS/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章置顶/置底方法研究</title>
    <link href="http://www.codewoody.com/posts/42846/"/>
    <id>http://www.codewoody.com/posts/42846/</id>
    <published>2019-06-26T14:51:15.000Z</published>
    <updated>2019-06-26T15:02:26.589Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讨论如何在Hexo中方便地实现文章置顶功能。</p><p>最初我采用了<a href="https://blog.minhow.com/2017/08/20/hexo/article-top/" target="_blank" rel="noopener">Hexo文章置顶的方法</a>。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的<code>top</code>值将文章放在末尾。因此我做了 一点修改。</p><a id="more"></a><h2 id="原始方法">原始方法</h2><p>原始方法的核心思想是在Front-Matter中添加一个自定义的<code>top</code>字段，然后在<code>hexo-generator-index</code>中使用这一字段来实现排序。具体操作为，修改文件<code>node_modules/hexo-generator-index/lib/generator.js</code>，添加 如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">        <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更改后的完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">var</span> path = config.index_generator.path || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的front-matter中添加top字段。top值越大，则文章越靠前。top值一样的文章则根据日期排序。front-matter设置的一个例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo文章置顶方法研究</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-06</span><span class="bullet">-26</span> <span class="number">22</span><span class="string">:51:15</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">教程</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">MinHow</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">博客</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">开源项目</span></span><br><span class="line"><span class="attr">cover_picture:</span> <span class="attr">https://cloud.minhow.com/images/miho/theme/github-second.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="解决置底的问题">解决“置底”的问题</h2><p>无法置底的原因很简单，即在上面的js代码修改中，没有设置top值的文章的top变量是未定义的，且规定未定义top的文章总是比定义了top值的文章要靠后。我们赋予未定义top值的文章一个默认的0值，即可解决这个问题的。具体的操作是将修改代码内容替换成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = first.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = second.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">      <span class="keyword">return</span> b - a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> second.date - first.date</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讨论如何在Hexo中方便地实现文章置顶功能。&lt;/p&gt;
&lt;p&gt;最初我采用了&lt;a href=&quot;https://blog.minhow.com/2017/08/20/hexo/article-top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo文章置顶的方法&lt;/a&gt;。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的&lt;code&gt;top&lt;/code&gt;值将文章放在末尾。因此我做了 一点修改。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 1</title>
    <link href="http://www.codewoody.com/posts/25582/"/>
    <id>http://www.codewoody.com/posts/25582/</id>
    <published>2019-06-26T06:05:17.000Z</published>
    <updated>2019-06-29T14:05:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="so-whats-this">So what's this</h2><p>每周我都会读阮一峰的每周分享，有时候也会在其他的博客平台上看见别的博主整理的这些每周资源分享文章，觉得比较有用，我也打算整理一下自己的List。</p><p>最近一年多以来，我尝试尽可能将自己的思考过程以文字的方式记录下来，这样过几天回头来看，便于我整理思路。更重要的是，这种累积会给自己带来沉甸甸的“积累感”，给自己一个强大正反馈。</p><p><em>这篇是这一系类的每周分享的第一篇，贵在坚持！</em></p><a id="more"></a><h2 id="新闻">新闻</h2><h3 id="树莓派4发布"><a href="https://www.ifanr.com/1228499" target="_blank" rel="noopener">树莓派4发布</a></h3><figure><img src="https://imgs.codewoody.com/uploads/big/8d9f81cf9870dc648b9486ff54025a1a.jpg" alt="树莓派4"><figcaption>树莓派4</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/8f4c25a7a87dd9c125bdf779b20c9861.png" alt="树莓派性能对比"><figcaption>树莓派性能对比</figcaption></figure><p>位于英国的教育慈善组织「Raspberry Pi 基金会」推出了它们的新一代产品：树莓派 4（Raspberry Pi 4），性能表现又上升了一个台阶，官方甚至称它「足以媲美一台入门级 x86 电脑」。树莓派的主要性能升级为：</p><ol type="1"><li>搭载了A72架构的BCM2711芯片，主频为1.5GHz</li><li>两个micro-HDMI</li><li>支持最高4GB LPDDR4内存</li><li>802.11ac 双频Wifi</li><li>千兆以太网</li><li>蓝牙5.0</li><li>5V/3A 的USB-C供电</li><li>USB2.0及USB3.0接口</li></ol><p>官方还承诺，会持续生产树莓派 4 至 2026 年 1 月.</p><h3 id="b站三体动画化">B站三体动画化</h3><p><a href="https://passport.weibo.com/visitor/visitor?entry=miniblog&amp;a=enter&amp;url=https%3A%2F%2Fweibo.com%2F1748075785%2FHAJ5ZiuBT&amp;domain=.weibo.com&amp;ua=php-sso_sdk_client-0.6.28&amp;_rand=1561603056.2875" target="_blank" rel="noopener">B站正式宣布《三体》动画化启动</a>: 作为重磅彩蛋，刘慈欣现身B站十周年活动现场。动画由B站出品、三体宇宙和制作方艺画开天联合出品。活动现场首播的概念版PV淋漓尽致地展现三体宇宙的宏大和黑暗森林法则的残酷。</p><blockquote><p>之前在B站上自己组团队做了三体动画（Minecraft版）的神游八方，也加入了动画化的主创团队。</p></blockquote><ul><li><a href="https://www.bilibili.com/3/" target="_blank" rel="noopener">专题页面</a></li></ul><h3 id="游戏适龄提示倡议"><a href="https://finance.sina.com.cn/roll/2019-06-27/doc-ihytcitk8046473.shtml" target="_blank" rel="noopener">《游戏适龄提示倡议》</a></h3><p>6月26日，人民网联合腾讯、网易、完美世界等10家头部游戏公司发起《游戏适龄提示倡议》，把游戏玩家分成4个年龄层级，并提出了相应的提示体系，包括游戏内容、类型和运营等方面的标准。年龄分层方面，此次倡议把游戏玩家分为18+、16+、12+、6+四级。例如6+多是休闲益智类，18+则有大量竞技、策略、棋牌类游戏。</p><figure><img src="https://imgs.codewoody.com/uploads/big/9ecb92ae01cbca2fc5d9909793357417.jpg" alt="分级标准"><figcaption>分级标准</figcaption></figure><blockquote><p>之前听老梁说的好，文化审查领域重要的是“自由裁量权”，而并不是挂在口头上的细枝末节的审查细节。没有分级制度，那么我想让你过你就能过，不让你过，你就不能过，随心所欲，岂不快哉？</p><p>&quot;在国民党统治时期，制定了一个新闻法，我们共产党人仔细研究它的字句，抓它的辫子，钻它的空子。现在我们当权，我看还是不要新闻法好，免得人家钻我们空子。没有法，我们主动，想怎样控制就怎样控制。&quot; -- 陈云 （孙旭培教授曾在《新闻立法之路》一文中引述）</p></blockquote><p>Further Reading：<a href="http://www.midphoto.com/chinese/whatsnew/2016/lawofnews.htm" target="_blank" rel="noopener">为什么中国没有新闻法</a>(<a href="/knowledge-base/backups/为什么中国没有新闻法.md">Backup Link</a>)</p><h3 id="联邦快递起诉美国政府"><a href="https://about.van.fedex.com/newsroom/fedex-statement-on-department-of-commerce-litigation/" target="_blank" rel="noopener">联邦快递起诉美国政府</a></h3><p>6月24日，联邦快递在官网发布声明称，已向哥伦比亚地区的美国地区法院提起诉讼，要求禁止美国商务部对联邦快递执行“出口管理条例”中的禁令。联邦快递认为，《出口管制条例》违反公共承运人在美国宪法第五修正案下的正当权利，因为他们不合理地要求承运人为可能违反《出口管制条例》的运品承担严格责任。</p><blockquote><p>魔幻现实主义</p></blockquote><h3 id="苹果首席设计官jonathan-ive将离职">苹果首席设计官Jonathan Ive将离职</h3><p>苹果首席设计官 Jonathan Ive 将于今年后期正式离开苹果，创立独立的设计公司 LoveFrom，其好友兼著名设计师 Marc Newson 将加入。届时，苹果将成为该设计公司其中一位主要客户。</p><p>Ive 在苹果的代表作包括 iMac、iPod、iPhone 等系列产品，参与设计了苹果的「飞船」总部 Apple Park。他在新闻稿中说：「在将近 30 年和无数项目后，让我最自豪的项目是我们持续投入精力创造了同行无法比拟的苹果设计团队，流程和文化。」</p><iframe width="560" height="315" src="https://www.youtube.com/embed/4xzLr7xSr-g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><blockquote><p>上面视频里的iOS 7即是Jonathan主导的，其革命性的变化在于用扁平化的设计取代拟物化的设计</p></blockquote><h3 id="全电动飞机-alice">全电动飞机 Alice</h3><p>在 6 月 17 日到 23 日举行的巴黎航空展上，以色列航空公司 Eviation 推出了自家首款全电动飞机 Alice。</p><p>这款用「爱丽丝」这个充满诗意的名字来命名的飞机，是全球首款全电动通勤飞机。</p><p>Eviation Alice 内部搭载了功率能达到 功率能够达到 900kW 的三台电机，以及一块可提供 900 千瓦时能量的锂电池。飞机充满一次电可以发行 1037 公里，巡航速度为每小时 407 公里。运载能力方面，Alice 飞机上有 9 个独立座位，同样也需要两名驾驶员才能驾驶。谈到 Alice 的机舱设计时，Eviation 官方表示飞机机舱做了一定的设计优化，自身能为乘客带来更好的降噪。售价方面，Alice 的定价为 400 万美元，折合约 2750 万人民币，每小时的飞行成本为 200 美元，折合约 1372 元。</p><figure><img src="https://imgs.codewoody.com/uploads/big/451b6c55f1bd4fc6d7259c70c17d8151.jpg" alt="巴黎航展 · Alice"><figcaption>巴黎航展 · Alice</figcaption></figure><h3 id="华为-p30-发货量破千万"><a href="http://www.sohu.com/a/323409776_223764?scm=1002.44003c.fe014a0151.PC_ARTICLE_REC&amp;spm=smpc.content.fd-d.32.15615936000232rn2g34" target="_blank" rel="noopener">华为 P30 发货量破千万</a></h3><p>6月27日，华为消费者业务手机产品线总裁何刚在MCW2019大会上公布了一系列数据，其中华为P30系列手机仅上市85天全球发货量就达到1000万台，比P20系列提前了62天。截止今年5月31日，华为手机整体出货量实现149天破亿。</p><figure><img src="https://imgs.codewoody.com/uploads/big/505dab1d529dfe5d3ef449446d007f59.png" alt="华为 P30 发货量破千万"><figcaption>华为 P30 发货量破千万</figcaption></figure><blockquote><p>果粉表示真香，想买。以及，辣鸡KOL</p></blockquote><h2 id="典故与梗">典故与梗</h2><p><strong>不作安安饿殍，效尤奋臂螳螂</strong></p><p>这句话，我一直理解反了意思。开始我以为是指不愿意做饿死鬼，即便是螳臂当车也要起来反抗的意思。结果，其原意是完全相反的。</p><p><a href="https://www.zhihu.com/question/68212300" target="_blank" rel="noopener">这句话出自顾诚的《明末农民战争史》的注释中</a>:</p><blockquote><p>【22】谈迁：《北游录》，《纪闻上》，《榜购一词》条。按：此条首云“总督杨文岳嗣昌出师，榜辑剧寇张献忠”，杨嗣昌字文弱，谈迁误为文岳，又称之为总督，遂与明保定总督杨文岳混为一人。杨复吉《梦阑琐笔》载此事时更写成“保督杨文岳出师榜缉张献忠”，均误。又杨氏所载词中“兴安、平利走四方”一句作“兴安、平利走东乡”。李馥荣：《滟滪囊》卷一所载杨嗣昌榜刊《西江月》词句为：“<strong>不作安安饿殍，效尤奋臂螳螂</strong>。往来楚蜀肆猖狂，弄兵潢池无状。云屯雨骤师集，蛇豕奔突奚藏？许尔军民绑来降，爵赏酬功上上。”或系杨嗣昌所刊另一榜文。</p></blockquote><p>这句话的意思是，尔等不安安静静地做一个饿死鬼，却效仿螳臂当车，自不量力（抵抗朝廷的剿灭大军）。当然，这句话可能并非杨总督本人所说，只是文人调侃他所做。不过，这句话透出的想法，杨总督脑子里大抵是有的，只不过要脸，不好说出来。对于这些统治者来捉，有这样的想法，其实不足为奇。但是，偏偏就有一些明明遇到乱世就会沦为“饿殍”的人，摆不正自己的位置。</p><p>历代造反的贫民，从陈胜吴广，到李自成，洪秀全，诚然造成了巨大的破坏，但若是不造反，又有什么活路呢？难道，做安安饿殍么？</p><h2 id="情绪">情绪</h2><p><strong>Youtube博主Etika自杀</strong></p><figure><img src="https://imgs.codewoody.com/uploads/big/b05fd2ee2db8d5adb14afe276509fe43.jpg" alt="Etika"><figcaption>Etika</figcaption></figure><p>2019年6月19日，Etika上传了一段疑似自杀宣言的视频，他背起书包，离开了家门。至此以后，没有人再看到Etika的任何踪迹。</p><p>6月22日，警方发现了Etika被遗弃的个人物品，在高达340英尺的大桥之上。</p><p>6月25日，纽约警方在布鲁克林大桥水域发现一具未明身份的男性遗体。今日，警方发布正式公告，遗体确为Etika本人，死因是自杀。</p><figure><img src="https://imgs.codewoody.com/uploads/big/d136781dd7e96199bc4f3697a7ccf46a.jpg" alt="网友在Etika自杀地的悼念"><figcaption>网友在Etika自杀地的悼念</figcaption></figure><blockquote><p>有很多极度抑郁的人以至于要自杀的人，有时候看起来会很开心的样子。永远不要以为自己有多么了解一个人，尤其是一个你没有那么熟悉，甚至是陌生的人。</p></blockquote><h2 id="文章与言论">文章与言论</h2><ol type="1"><li><p><a href="http://ohshitgit.com/" target="_blank" rel="noopener">Oh shit, git!</a>：作者针对一些在使用git过程中的痛点给出了解决方法</p></li><li><p><a href="https://jarv.is/notes/how-to-backup-linux-server/" target="_blank" rel="noopener">How To: Automatically Backup a Linux VPS to a Separate Cloud Storage Service</a>：如何将VPS备份到一个云存储平台</p></li><li><p>安卓碎片化严重到什么地步？安卓本身有12个版本，如果每个版本有12个厂商，每个厂商有12个手机型号，因此安卓生态至少包含1,728种&quot;版本- 品牌 - 设备&quot;的组合。</p></li><li><p><a href="https://www.prnewswire.com/news-releases/prose-proximity-services-for-lte--5g-networks-2017-2030---opportunities-challenges-strategies--forecasts-300396915.html" target="_blank" rel="noopener">ProSe (Proximity Services) for LTE &amp; 5G Networks: 2017-2030 - Opportunities, Challenges, Strategies &amp; Forecasts</a>: 5G是近年来的热词了，也是这次美国对华为发难的一个重要因素。不过舆论对于5G的认识，一般是一个加强版的4G蜂窝网。其实5G中引入的Promxity Service技术，将为传统蜂窝网引入D2D的能力，这可能带来深远的影响。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/6db29e24d20b926b20359a495e28fdcf.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Weekly" scheme="http://www.codewoody.com/categories/Weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="树莓派" scheme="http://www.codewoody.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Weekly" scheme="http://www.codewoody.com/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Python下的音频处理库librosa打开文件是显示NoBackendError的解决</title>
    <link href="http://www.codewoody.com/posts/40199/"/>
    <id>http://www.codewoody.com/posts/40199/</id>
    <published>2019-06-26T04:56:10.000Z</published>
    <updated>2019-06-28T08:40:42.899Z</updated>
    
    <content type="html"><![CDATA[<p>近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。 <a id="more"></a></p><p>由于我的程序中只采用了<code>librosa.load</code>这个命令，通过源代码可以发现librosa实际上是用<code>audioread</code>这个库的<code>audioread.audio_open</code>来读取音频文件的。这个函数的源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_open</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">"""Open an audio file using a library that is available on this</span></span><br><span class="line"><span class="string">    system.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Standard-library WAV and AIFF readers.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> rawread</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> rawread.RawAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Core Audio.</span></span><br><span class="line">    <span class="keyword">if</span> _ca_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> macca</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> macca.ExtAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GStreamer.</span></span><br><span class="line">    <span class="keyword">if</span> _gst_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> gstdec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> gstdec.GstAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MAD.</span></span><br><span class="line">    <span class="keyword">if</span> _mad_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> maddec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> maddec.MadAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FFmpeg.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> ffdec</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ffdec.FFmpegAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># All backends failed!</span></span><br><span class="line">    <span class="keyword">raise</span> NoBackendError()</span><br></pre></td></tr></table></figure><p>可见之前我们遇到的NoBackendError就是这里的最后一行抛出的了，由于我安装的FFmpeg，进一步进入ffdec.py这个文件中。不难发现实际打开文件的是下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">popen_multiple</span><span class="params">(commands, command_args, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Like `subprocess.Popen`, but can try multiple commands in case</span></span><br><span class="line"><span class="string">    some are not available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `commands` is an iterable of command names and `command_args` are</span></span><br><span class="line"><span class="string">    the rest of the arguments that, when appended to the command name,</span></span><br><span class="line"><span class="string">    make up the full first argument to `subprocess.Popen`. The</span></span><br><span class="line"><span class="string">    other positional and keyword arguments are passed through.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i, command <span class="keyword">in</span> enumerate(commands):</span><br><span class="line">        cmd = [command] + command_args</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> subprocess.Popen(cmd, *args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">if</span> i == len(commands) - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># No more commands to try.</span></span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>这里的<code>commands</code>是直接传入的第33行的<code>COMMANDS</code>变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>我这里倒腾了好几下，最终发现实际是错误的原因是没有找到ffmpeg这个命令。我们在这里将ffmpeg替换成ffmpeg的绝对路径。你可以通过下面这行命令找到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ffmpeg</span><br></pre></td></tr></table></figure><p>最终我改成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'/usr/bin/ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>Boom！一切就工作正常了。这么想起来应该是安装ffmpeg的时候的环境变量有问题，导致在command line方式下调用ffmpeg命令出错吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。
    
    </summary>
    
      <category term="Debug" scheme="http://www.codewoody.com/categories/Debug/"/>
    
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="python" scheme="http://www.codewoody.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Latex中各种各样的箭头</title>
    <link href="http://www.codewoody.com/posts/13297/"/>
    <id>http://www.codewoody.com/posts/13297/</id>
    <published>2019-06-24T01:52:42.000Z</published>
    <updated>2019-06-24T02:19:58.271Z</updated>
    
    <content type="html"><![CDATA[<p>Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。 <a id="more"></a></p><h2 id="默认箭头">默认箭头</h2><p>这里的默认指你不需要任何额外的<code>usepackage</code>就可以使用：</p><!-- ![默认箭头](https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png) --><img src="https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png" width="60%"><figcaption>默认箭头</figcaption><h2 id="amssymb提供的箭头">amssymb提供的箭头</h2><p>需要<code>\usepackage{amssymb}</code></p><!-- ![amssymb箭头](https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png) --><img src="https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png" width="60%"><figcaption>amssymb箭头</figcaption><h2 id="further-reading">Further Reading</h2><p><a href="http://www.sascha-frank.com/Arrow/latex-arrows.html" target="_blank" rel="noopener">LaTeX arrows</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="latex" scheme="http://www.codewoody.com/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>部署Pritunl来使用OpenVPN</title>
    <link href="http://www.codewoody.com/posts/23676/"/>
    <id>http://www.codewoody.com/posts/23676/</id>
    <published>2019-06-13T06:16:27.000Z</published>
    <updated>2019-06-13T07:04:39.437Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="why-vpn">Why VPN</h2><p>为什么要使用VPN？尤其是，为什么个人用户需要使用VPN呢？其实如果你只有一台电脑，其实一般用不上VPN（当然，用VPN来翻墙另说），如果你有多个电脑，甚至是服务器，这些服务器的网络情况还比较复杂，而你希望随时随地方便地访问这些机器，那么建立VPN虚拟网络将这些机器连接起来就能极大的方便访问过程。例如，如果一台服务器是在路由器后面，没有公网IP，与其在路由器上配置复杂的端口映射表，不如通过VPN网络自由地访问各个端口。又例如在一些特定的场景下，一些服务器的低位（1024以下）端口的访问会收到限制，这个也可以同VPN来解决。</p><p>当然，还有可能，你处于校园网中，而你通过种种途径有了一个无限流量服务器，通过VPN，可以让你在校园网场景下能够随时通过这台服务器上网，从而免去流量费用。另外，将这一宝贵资源分享给同学使用，用VPN也非常方便。</p><h2 id="why-pritunl">Why Pritunl</h2><p>我试过很多VPN方案，例如PPTP，OpenVPN，IPSec等等。其实使用VPN过程中的一个痛点在于用户管理要尽可能方便，虽然我也比较多的在用命令行工具，但是使用命令行工具去管理用户体验还是非常差。Pritunl提供了OpenVPN的网页GUI管理界面。这也是我为什么推荐使用Priunl的原因。而且，Pritunl中免费用户就可以使用无数量限制的账户和设备，这对于个人用户来说足够了。</p><p>另一方面，Pritunl的客户端支持也非常全面</p><h2 id="how-to-deploy">How to deploy</h2><h3 id="installation">Installation</h3><p>官方文档在这里: <a href="https://docs.pritunl.com/docs/installation" target="_blank" rel="noopener">Installation</a>。事实上按照官方文档的推荐，Pritunl最好部署在企业级的Linux OS上，如Red Hat, Oracle Linux, CentOS等。不过对于个人用户，对于性能，稳定性和安全性要求没有那么严格的情况下，用Debian系的系统也未尝不可。我的Pritunl服务器就是部署在Ubuntu上的，几个月使用下来，性能和稳定性都非常好。</p><p>对于不同版本的系统，安装脚本不同。例如，Ubuntu 16.04，安装脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list &lt;&lt; EOF</span><br><span class="line">deb https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.0 multiverse</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo tee /etc/apt/sources.list.d/pritunl.list &lt;&lt; EOF</span><br><span class="line">deb http://repo.pritunl.com/stable/apt xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 9DA31620334BD75D9DCB49F368818C72E52529D4</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 7568D9BB55FF9E5287D586017AE645C0CF8E292A</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get --assume-yes install pritunl mongodb-org</span><br><span class="line">sudo systemctl start pritunl mongod</span><br><span class="line">sudo systemctl enable pritunl mongod</span><br></pre></td></tr></table></figure><h3 id="configuration">Configuration</h3><p>在安装完Pritunl之后，访问服务器的443端口，即可以看到配置引导界面。</p><figure><img src="https://imgs.codewoody.com/uploads/big/04288b446ec0e7ad27b790dd4890d71b.png" alt="配置界面"><figcaption>配置界面</figcaption></figure><p>其中需要输入的主要是第一项Setup Key。数据库部分，如果你是使用上面的脚本安装的话，那么Pritunl服务本机上就已经安装运行了MongoDB，这里第二个配置MongoDB URI就不需要变动。要获取Setup Key，ssh进入部署服务器，运行<code>pritunl setup-key</code>即可.</p><p>完成这一步设置以后就来到管理员登录界面：</p><figure><img src="https://imgs.codewoody.com/uploads/big/5310344dc5cd485d83835f900fdf38df.png" alt="管理员登录界面"><figcaption>管理员登录界面</figcaption></figure><p>初始时用户名和密码都是<code>pritunl</code>，在完成第一次登录之后会被要求修改管理员的用户名和密码：</p><figure><img src="https://imgs.codewoody.com/uploads/big/88164d6b435cfb64cc84a35bd6188235.png" alt="修改密码"><figcaption>修改密码</figcaption></figure><h2 id="further-reading">Further Reading</h2><p>Pritunl的使用方法非常直观，文档可以参见<a href="https://docs.pritunl.com/docs/connecting" target="_blank" rel="noopener">Connecting</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/0f3a766a78effb06b6770d8a61ad2e55.png&quot; alt=&quot;Pritunl&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="vpn" scheme="http://www.codewoody.com/tags/vpn/"/>
    
  </entry>
  
</feed>
