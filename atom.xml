<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>治部少辅</title>
  
  <subtitle>大一大万大吉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codewoody.com/"/>
  <updated>2019-06-28T08:57:43.864Z</updated>
  <id>http://www.codewoody.com/</id>
  
  <author>
    <name>Woody Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中将结构体放置在std::vector容器内的操作风险</title>
    <link href="http://www.codewoody.com/posts/35148/"/>
    <id>http://www.codewoody.com/posts/35148/</id>
    <published>2019-06-28T08:39:21.000Z</published>
    <updated>2019-06-28T08:57:43.864Z</updated>
    
    <content type="html"><![CDATA[<p>有一组长度不固定的参数需要传输，且参数形式为结构体，那么一个比较简单的方法是将这些参数作为一个<code>std::vector</code>。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct ExampleStruct&gt; data)</span></span>;</span><br></pre></td></tr></table></figure><p>由于C++是采用值传递的方式，每次对<code>std::vector</code>进行元素的存取操作时，都会对涉及的结构体进行复制。如果结构体的数量比较多，或者结构体的体积比加大，那么这种方式对于计算和内存资源的浪费就比较大了。</p><a id="more"></a><p>那么，折中的办法是在<code>std::vector</code>中存放指针。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct ExampleStruct *&gt; data)</span></span>;</span><br></pre></td></tr></table></figure><p>不过，这就给指针的生命周期管理带来了很大的挑战，而且可能会引入非常多耦合性很强的代码。如果函数是state-less，即只对输入参数进行计算，而不更改其他的状态变量，问题倒不是很严重。反之，就会存在很多比较大的漏洞。</p><p>由于局部变量存在作用范围的限制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ExampleStruct</span> <span class="title">a</span>;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  data.push_back (&amp;a);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  f (data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当离开调用<code>f</code>的函数的作用域时，<code>a</code>就会被释放，后续在其他地方访问<code>data</code>时，对应的指针指向的内存区域已经被释放掉了，对其进行访问会导致错误。使用<code>new</code>来讲结构体创建在堆内存上可以解决这个问题，但是这意味着后续这一数据已经利用完之后，要确保此处申请的内存被恰当地释放掉。随着业务逻辑的复杂化，要准确做到这一点会非常困难，强行实现也会带来很多强耦合的代码，扩大引入bug的风险。</p><p>我们剩下的选择，就是使用智能指针<code>std::shared_ptr</code>自动管理堆内存的声明周期。就是形式有点复杂了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::share_ptr&lt;struct ExampleStruct&gt;&gt; data)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一组长度不固定的参数需要传输，且参数形式为结构体，那么一个比较简单的方法是将这些参数作为一个&lt;code&gt;std::vector&lt;/code&gt;。例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;struct ExampleStruct&amp;gt; data)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于C++是采用值传递的方式，每次对&lt;code&gt;std::vector&lt;/code&gt;进行元素的存取操作时，都会对涉及的结构体进行复制。如果结构体的数量比较多，或者结构体的体积比加大，那么这种方式对于计算和内存资源的浪费就比较大了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程研究" scheme="http://www.codewoody.com/categories/%E7%BC%96%E7%A8%8B%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
      <category term="C++" scheme="http://www.codewoody.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何自己搭建一个Time Machine服务器</title>
    <link href="http://www.codewoody.com/posts/14680/"/>
    <id>http://www.codewoody.com/posts/14680/</id>
    <published>2019-06-28T02:52:05.000Z</published>
    <updated>2019-06-28T03:00:55.912Z</updated>
    
    <content type="html"><![CDATA[<p>如何在Ubuntu上搭建一个简洁的Time Machine服务器呢？网上找到的教程说的都比较杂，这里整理一个刚刚经过实践检验的方法来供大家参考。目标系统是<code>Ubuntu 16.04 LTS</code>。 <a id="more"></a></p><h3 id="安装需要的工具">1. 安装需要的工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install netatalk avahi-daemon</span><br></pre></td></tr></table></figure><h3 id="创建一个用于专门用来运行time-machine进程的用户">2. 创建一个用于专门用来运行Time Machine进程的用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -c "Time machine" -m -s /bin/bash tm</span><br></pre></td></tr></table></figure><p>我这里命名为<code>tm</code>，你可以替换为任何你定的名字，但是最好不要使用<code>root</code>用户。 接下来给新用户设定密码 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd tm</span><br></pre></td></tr></table></figure></p><h3 id="准备文件夹">3. 准备文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -R /home/tm/TimeMachineFolder</span><br><span class="line">sudo chown -R tm /home/tm/TimeMachineFolder</span><br></pre></td></tr></table></figure><h3 id="设置netatalk">4. 设置<code>netatalk</code></h3><p>首先我们将原有的配置文件备份 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/netatalk/AppleVolumes.default /etc/netatalk/AppleVolumes.default.old</span><br></pre></td></tr></table></figure></p><p>然后创建一个新的配置文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/netatalk/AppleVolumes.default</span><br></pre></td></tr></table></figure></p><p>使用你偏好的编辑器（vim，nano之类）向这个配置文件中加入如下内容 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:DEFAULT: options:upriv,usedots</span><br><span class="line">/home/tm/TimeMachineFolder "My Time Machine" options:tm volsizelimit:500000 allow:tm</span><br></pre></td></tr></table></figure></p><p>注意将第二行的文件夹路径设定为你再第三步中创建的文件夹的路径。另外，第二行中的<code>volsizelimit</code>设定了Time Machine将会使用的最大硬盘空间，单位是MB。</p><h3 id="重启netatalk服务来应用更改">5. 重启<code>netatalk</code>服务来应用更改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service netatalk restart</span><br></pre></td></tr></table></figure><h3 id="在mac上连接到time-machine">6. 在Mac上连接到Time Machine</h3><p>首先直接尝试在Time Machine中选择这个服务器（会显示在可用磁盘下面，名字显示为第四步中你<code>netatalk</code>设置文件中指定的名字）。 如果你无法找到，那么打开Finder并按下⌘+K，在弹出来的窗口中，于服务器地址一栏输入<code>afp://IP.of.your.server/</code>，然后点连接。如果提示需要输入用户名和密码来登录，那就输入第二步中你设定的用户名密码即可。</p><figure><img src="https://imgs.codewoody.com/uploads/big/408d6956cd13b4c671b4519c1115d97c.png" alt="示意图"><figcaption>示意图</figcaption></figure><p>ref：<a href="http://dae.me/blog/1660/concisest-guide-to-setting-up-time-machine-server-on-ubuntu-server-12-04/" target="_blank" rel="noopener">Concisest guide to setting up Time Machine server on Ubuntu Server 12.04, 14.04 &amp; Debian | Dae’s blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在Ubuntu上搭建一个简洁的Time Machine服务器呢？网上找到的教程说的都比较杂，这里整理一个刚刚经过实践检验的方法来供大家参考。目标系统是&lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="macOS" scheme="http://www.codewoody.com/tags/macOS/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>键盘上的符号的英文读法</title>
    <link href="http://www.codewoody.com/posts/20487/"/>
    <id>http://www.codewoody.com/posts/20487/</id>
    <published>2019-06-28T02:49:04.000Z</published>
    <updated>2019-06-28T02:55:34.098Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">! 叹号 exclamation mark/bang </span><br><span class="line">? 问号 question mark </span><br><span class="line">, 逗号 comma </span><br><span class="line">. 点号 dot/period/point </span><br><span class="line">: 冒号 colon </span><br><span class="line">; 分号 semicolon </span><br><span class="line">” 双引号 quotation marks/double quote </span><br><span class="line">‘ 单引号/撇号 apostrophe/single quote </span><br><span class="line">` 重音号 backquote/grave accent </span><br><span class="line">* 星号 asterisk/star </span><br><span class="line">+ 加号 plus sign </span><br><span class="line">- 减号/横线 hyphen/dash/minus sign/ </span><br><span class="line">= 等号 equal sign </span><br><span class="line">/ 斜线 slash </span><br><span class="line">\ 反斜线 backslash/escape </span><br><span class="line">| 竖线 bar/pipe/vertical bar </span><br><span class="line">_ 下划线 underline/underscore </span><br><span class="line">$ 美元符号 dollar sign </span><br><span class="line">@ at at sign </span><br><span class="line"># 井号 crosshatch/sharp/hash </span><br><span class="line">% 百分号 percent sign/mod </span><br><span class="line">&amp; and/和/兼 and/ampersand </span><br><span class="line">^ 折音号 circumflex/caret </span><br><span class="line">~ 波浪号 tilde </span><br><span class="line">&#123;&#125; （左右）花括号/大括号 (left/right|open/close) braces </span><br><span class="line">[] （左右）方括号/中括号 (left/right|open/close) brackets </span><br><span class="line">() （左右）圆括号/小括号 (left/right|open/close) parentheses </span><br><span class="line">&lt;&gt; 尖括号 angle brackets </span><br><span class="line">&lt; 大于号 less than </span><br><span class="line">&gt; 小于号 greater than</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MAC: @rpath的坑</title>
    <link href="http://www.codewoody.com/posts/21028/"/>
    <id>http://www.codewoody.com/posts/21028/</id>
    <published>2019-06-28T02:47:47.000Z</published>
    <updated>2019-06-28T08:40:45.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem">Problem</h2><p>这篇文章的缘由是我在尝试使用<a href="https://www.nsnam.org" target="_blank" rel="noopener">ns3</a>带的NetAnim程序时，显示了下面这个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/QtGui.framework/Versions/4/QtGui</span><br><span class="line">  Referenced from: /path/to/ns-allinone-3.28/netanim-3.108/./NetAnim</span><br><span class="line">  Reason: image not found</span><br><span class="line">[1]    86663 abort      ./NetAnim</span><br></pre></td></tr></table></figure><a id="more"></a><p>这是一个动态链接的错误，所以没法通过编译的时候添加<code>LDFLAGS</code>来解决。不过错误里面的<code>@rpath</code>这个东西倒是挺有意思，显然并不是环境变量。我在网上查了很多，但是大多数是围绕xcode讨论的，不太适用于我面临的场景（命令行）。不过这些文章（如<a href="http://www.tanhao.me/pieces/1361.html/" target="_blank" rel="noopener">这篇</a>)能够大致阐明<code>@rpath</code>的用途。简而言之，<code>@rpath</code>是一个类似Shell中的<code>PATH</code>的变量，程序在执行时会从<code>@rpath</code>指定的路径中寻找动态链接库文件。那么剩下的问题就是我们如何操作这个变量了。</p><h2 id="solution">Solution</h2><p>通过<code>otool</code>我们可以查看一个程序的动态链接文件搜索地址，例如我要用的<code>NetAnim</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L ./NetAnim</span><br><span class="line">./NetAnim:</span><br><span class="line">@rpath/QtGui.framework/Versions/4/QtGui (compatibility version 4.8.0, current version 4.8.7)</span><br><span class="line">@rpath/QtCore.framework/Versions/4/QtCore (compatibility version 4.8.0, current version 4.8.7)</span><br><span class="line">/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.0)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4)</span><br></pre></td></tr></table></figure><p>而我们可以通过<code>install_name_tool</code>来对这些地址进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ install_name_tool -h</span><br><span class="line">Usage: /Library/Developer/CommandLineTools/usr/bin/install_name_tool [-change old new] ... [-rpath old new] ... [-add_rpath new] ... [-delete_rpath old] ... [-id name] input</span><br></pre></td></tr></table></figure><p>对我而言，我需要将Qt4的动态链接库添加到<code>NetAdmin</code>的搜索路径中去，可以使用如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -add_rpath /usr/<span class="built_in">local</span>/Cellar/qt@4/4.8.7_3/lib ./NetAnim</span><br></pre></td></tr></table></figure><p>大功告成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;这篇文章的缘由是我在尝试使用&lt;a href=&quot;https://www.nsnam.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ns3&lt;/a&gt;带的NetAnim程序时，显示了下面这个错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dyld: Library not loaded: @rpath/QtGui.framework/Versions/4/QtGui&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Referenced from: /path/to/ns-allinone-3.28/netanim-3.108/./NetAnim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Reason: image not found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1]    86663 abort      ./NetAnim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Debug" scheme="http://www.codewoody.com/categories/Debug/"/>
    
    
      <category term="macOS" scheme="http://www.codewoody.com/tags/macOS/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章置顶/置底方法研究</title>
    <link href="http://www.codewoody.com/posts/42846/"/>
    <id>http://www.codewoody.com/posts/42846/</id>
    <published>2019-06-26T14:51:15.000Z</published>
    <updated>2019-06-26T15:02:26.589Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讨论如何在Hexo中方便地实现文章置顶功能。</p><p>最初我采用了<a href="https://blog.minhow.com/2017/08/20/hexo/article-top/" target="_blank" rel="noopener">Hexo文章置顶的方法</a>。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的<code>top</code>值将文章放在末尾。因此我做了 一点修改。</p><a id="more"></a><h2 id="原始方法">原始方法</h2><p>原始方法的核心思想是在Front-Matter中添加一个自定义的<code>top</code>字段，然后在<code>hexo-generator-index</code>中使用这一字段来实现排序。具体操作为，修改文件<code>node_modules/hexo-generator-index/lib/generator.js</code>，添加 如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">        <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更改后的完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">return</span> first.top == second.top ? second.date - first.date : second.top - first.top <span class="comment">//若top值一样则按照文章日期降序排, 否则按照top值降序排</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> second.date - first.date;  <span class="comment">// 都没定义top，按照文章日期降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">var</span> path = config.index_generator.path || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的front-matter中添加top字段。top值越大，则文章越靠前。top值一样的文章则根据日期排序。front-matter设置的一个例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo文章置顶方法研究</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-06</span><span class="bullet">-26</span> <span class="number">22</span><span class="string">:51:15</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">教程</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">MinHow</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">博客</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">开源项目</span></span><br><span class="line"><span class="attr">cover_picture:</span> <span class="attr">https://cloud.minhow.com/images/miho/theme/github-second.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="解决置底的问题">解决“置底”的问题</h2><p>无法置底的原因很简单，即在上面的js代码修改中，没有设置top值的文章的top变量是未定义的，且规定未定义top的文章总是比定义了top值的文章要靠后。我们赋予未定义top值的文章一个默认的0值，即可解决这个问题的。具体的操作是将修改代码内容替换成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = first.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = second.top || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">      <span class="keyword">return</span> b - a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> second.date - first.date</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讨论如何在Hexo中方便地实现文章置顶功能。&lt;/p&gt;
&lt;p&gt;最初我采用了&lt;a href=&quot;https://blog.minhow.com/2017/08/20/hexo/article-top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo文章置顶的方法&lt;/a&gt;。这个方法还是非常简单有效，不过存在一个问题：即不支持使用负数的&lt;code&gt;top&lt;/code&gt;值将文章放在末尾。因此我做了 一点修改。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Weekly - 1</title>
    <link href="http://www.codewoody.com/posts/25582/"/>
    <id>http://www.codewoody.com/posts/25582/</id>
    <published>2019-06-26T06:05:17.000Z</published>
    <updated>2019-06-28T02:05:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="so-whats-this">So what's this</h2><p>每周我都会读阮一峰的每周分享，有时候也会在其他的博客平台上看见别的博主整理的这些每周资源分享文章，觉得比较有用，我也打算整理一下自己的List。</p><p>最近一年多以来，我尝试尽可能将自己的思考过程以文字的方式记录下来，这样过几天回头来看，便于我整理思路。更重要的是，这种累积会给自己带来沉甸甸的“积累感”，给自己一个强大正反馈。</p><p><em>这篇是这一系类的每周分享的第一篇，贵在坚持！</em></p><a id="more"></a><h2 id="新闻">新闻</h2><h3 id="树莓派4发布"><a href="https://www.ifanr.com/1228499" target="_blank" rel="noopener">树莓派4发布</a></h3><figure><img src="https://imgs.codewoody.com/uploads/big/8d9f81cf9870dc648b9486ff54025a1a.jpg" alt="树莓派4"><figcaption>树莓派4</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/8f4c25a7a87dd9c125bdf779b20c9861.png" alt="树莓派性能对比"><figcaption>树莓派性能对比</figcaption></figure><p>位于英国的教育慈善组织「Raspberry Pi 基金会」推出了它们的新一代产品：树莓派 4（Raspberry Pi 4），性能表现又上升了一个台阶，官方甚至称它「足以媲美一台入门级 x86 电脑」。树莓派的主要性能升级为：</p><ol type="1"><li>搭载了A72架构的BCM2711芯片，主频为1.5GHz</li><li>两个micro-HDMI</li><li>支持最高4GB LPDDR4内存</li><li>802.11ac 双频Wifi</li><li>千兆以太网</li><li>蓝牙5.0</li><li>5V/3A 的USB-C供电</li><li>USB2.0及USB3.0接口</li></ol><p>官方还承诺，会持续生产树莓派 4 至 2026 年 1 月.</p><h3 id="b站三体动画化">B站三体动画化</h3><p><a href="https://passport.weibo.com/visitor/visitor?entry=miniblog&amp;a=enter&amp;url=https%3A%2F%2Fweibo.com%2F1748075785%2FHAJ5ZiuBT&amp;domain=.weibo.com&amp;ua=php-sso_sdk_client-0.6.28&amp;_rand=1561603056.2875" target="_blank" rel="noopener">B站正式宣布《三体》动画化启动</a>: 作为重磅彩蛋，刘慈欣现身B站十周年活动现场。动画由B站出品、三体宇宙和制作方艺画开天联合出品。活动现场首播的概念版PV淋漓尽致地展现三体宇宙的宏大和黑暗森林法则的残酷。</p><blockquote><p>之前在B站上自己组团队做了三体动画（Minecraft版）的神游八方，也加入了动画化的主创团队。</p></blockquote><ul><li><a href="https://www.bilibili.com/3/" target="_blank" rel="noopener">专题页面</a></li></ul><h3 id="人民网联合腾讯网易等游戏公司发起游戏适龄提示倡议"><a href="https://finance.sina.com.cn/roll/2019-06-27/doc-ihytcitk8046473.shtml" target="_blank" rel="noopener">人民网联合腾讯、网易等游戏公司发起《游戏适龄提示倡议》</a></h3><p>6月26日，人民网联合腾讯、网易、完美世界等10家头部游戏公司发起《游戏适龄提示倡议》，把游戏玩家分成4个年龄层级，并提出了相应的提示体系，包括游戏内容、类型和运营等方面的标准。年龄分层方面，此次倡议把游戏玩家分为18+、16+、12+、6+四级。例如6+多是休闲益智类，18+则有大量竞技、策略、棋牌类游戏。</p><figure><img src="https://imgs.codewoody.com/uploads/big/9ecb92ae01cbca2fc5d9909793357417.jpg" alt="分级标准"><figcaption>分级标准</figcaption></figure><blockquote><p>之前听老梁说的好，文化审查领域重要的是“自由裁量权”，而并不是挂在口头上的细枝末节的审查细节。没有分级制度，那么我想让你过你就能过，不让你过，你就不能过，随心所欲，岂不快哉？</p><p>&quot;在国民党统治时期，制定了一个新闻法，我们共产党人仔细研究它的字句，抓它的辫子，钻它的空子。现在我们当权，我看还是不要新闻法好，免得人家钻我们空子。没有法，我们主动，想怎样控制就怎样控制。&quot; -- 陈云 （孙旭培教授曾在《新闻立法之路》一文中引述）</p></blockquote><p>Further Reading：<a href="http://www.midphoto.com/chinese/whatsnew/2016/lawofnews.htm" target="_blank" rel="noopener">为什么中国没有新闻法</a>(<a href="/knowledge-base/backups/为什么中国没有新闻法.md">Backup Link</a>)</p><h3 id="联邦快递起诉美国政府"><a href="https://about.van.fedex.com/newsroom/fedex-statement-on-department-of-commerce-litigation/" target="_blank" rel="noopener">联邦快递起诉美国政府</a></h3><p>6月24日，联邦快递在官网发布声明称，已向哥伦比亚地区的美国地区法院提起诉讼，要求禁止美国商务部对联邦快递执行“出口管理条例”中的禁令。联邦快递认为，《出口管制条例》违反公共承运人在美国宪法第五修正案下的正当权利，因为他们不合理地要求承运人为可能违反《出口管制条例》的运品承担严格责任。</p><blockquote><p>魔幻现实主义</p></blockquote><h3 id="苹果首席设计官jonathan-ive将离职">苹果首席设计官Jonathan Ive将离职</h3><p>苹果首席设计官 Jonathan Ive 将于今年后期正式离开苹果，创立独立的设计公司 LoveFrom，其好友兼著名设计师 Marc Newson 将加入。届时，苹果将成为该设计公司其中一位主要客户。</p><p>Ive 在苹果的代表作包括 iMac、iPod、iPhone 等系列产品，参与设计了苹果的「飞船」总部 Apple Park。他在新闻稿中说：「在将近 30 年和无数项目后，让我最自豪的项目是我们持续投入精力创造了同行无法比拟的苹果设计团队，流程和文化。」</p><iframe width="560" height="315" src="https://www.youtube.com/embed/4xzLr7xSr-g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><blockquote><p>上面视频里的iOS 7即是Jonathan主导的，其革命性的变化在于用扁平化的设计取代拟物化的设计</p></blockquote><h2 id="典故与梗">典故与梗</h2><p><strong>不作安安饿殍，效尤奋臂螳螂</strong></p><p>这句话，我一直理解反了意思。开始我以为是指不愿意做饿死鬼，即便是螳臂当车也要起来反抗的意思。结果，其原意是完全相反的。</p><p><a href="https://www.zhihu.com/question/68212300" target="_blank" rel="noopener">这句话出自顾诚的《明末农民战争史》的注释中</a>:</p><blockquote><p>【22】谈迁：《北游录》，《纪闻上》，《榜购一词》条。按：此条首云“总督杨文岳嗣昌出师，榜辑剧寇张献忠”，杨嗣昌字文弱，谈迁误为文岳，又称之为总督，遂与明保定总督杨文岳混为一人。杨复吉《梦阑琐笔》载此事时更写成“保督杨文岳出师榜缉张献忠”，均误。又杨氏所载词中“兴安、平利走四方”一句作“兴安、平利走东乡”。李馥荣：《滟滪囊》卷一所载杨嗣昌榜刊《西江月》词句为：“<strong>不作安安饿殍，效尤奋臂螳螂</strong>。往来楚蜀肆猖狂，弄兵潢池无状。云屯雨骤师集，蛇豕奔突奚藏？许尔军民绑来降，爵赏酬功上上。”或系杨嗣昌所刊另一榜文。</p></blockquote><p>这句话的意思是，尔等不安安静静地做一个饿死鬼，却效仿螳臂当车，自不量力（抵抗朝廷的剿灭大军）。当然，这句话可能并非杨总督本人所说，只是文人调侃他所做。不过，这句话透出的想法，杨总督脑子里大抵是有的，只不过要脸，不好说出来。对于这些统治者来捉，有这样的想法，其实不足为奇。但是，偏偏就有一些明明遇到乱世就会沦为“饿殍”的人，摆不正自己的位置。</p><p>历代造反的贫民，从陈胜吴广，到李自成，洪秀全，诚然造成了巨大的破坏，但若是不造反，又有什么活路呢？难道，做安安饿殍么？</p><h2 id="情绪">情绪</h2><p><strong>Youtube博主Etika自杀</strong></p><figure><img src="https://imgs.codewoody.com/uploads/big/b05fd2ee2db8d5adb14afe276509fe43.jpg" alt="Etika"><figcaption>Etika</figcaption></figure><p>2019年6月19日，Etika上传了一段疑似自杀宣言的视频，他背起书包，离开了家门。至此以后，没有人再看到Etika的任何踪迹。</p><p>6月22日，警方发现了Etika被遗弃的个人物品，在高达340英尺的大桥之上。</p><p>6月25日，纽约警方在布鲁克林大桥水域发现一具未明身份的男性遗体。今日，警方发布正式公告，遗体确为Etika本人，死因是自杀。</p><figure><img src="https://imgs.codewoody.com/uploads/big/d136781dd7e96199bc4f3697a7ccf46a.jpg" alt="网友在Etika自杀地的悼念"><figcaption>网友在Etika自杀地的悼念</figcaption></figure><blockquote><p>有很多极度抑郁的人以至于要自杀的人，有时候看起来会很开心的样子。永远不要以为自己有多么了解一个人，尤其是一个你没有那么熟悉，甚至是陌生的人。</p></blockquote><h2 id="文章与言论">文章与言论</h2><ol type="1"><li><p><a href="http://ohshitgit.com/" target="_blank" rel="noopener">Oh shit, git!</a>：作者针对一些在使用git过程中的痛点给出了解决方法</p></li><li><p><a href="https://jarv.is/notes/how-to-backup-linux-server/" target="_blank" rel="noopener">How To: Automatically Backup a Linux VPS to a Separate Cloud Storage Service</a>：如何将VPS备份到一个云存储平台</p></li><li><p>安卓碎片化严重到什么地步？安卓本身有12个版本，如果每个版本有12个厂商，每个厂商有12个手机型号，因此安卓生态至少包含1,728种&quot;版本- 品牌 - 设备&quot;的组合。</p></li><li><p><a href="https://www.prnewswire.com/news-releases/prose-proximity-services-for-lte--5g-networks-2017-2030---opportunities-challenges-strategies--forecasts-300396915.html" target="_blank" rel="noopener">ProSe (Proximity Services) for LTE &amp; 5G Networks: 2017-2030 - Opportunities, Challenges, Strategies &amp; Forecasts</a>: 5G是近年来的热词了，也是这次美国对华为发难的一个重要因素。不过舆论对于5G的认识，一般是一个加强版的4G蜂窝网。其实5G中引入的Promxity Service技术，将为传统蜂窝网引入D2D的能力，这可能带来深远的影响。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/6db29e24d20b926b20359a495e28fdcf.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="http://www.codewoody.com/categories/weekly/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="树莓派" scheme="http://www.codewoody.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="科技新闻" scheme="http://www.codewoody.com/tags/%E7%A7%91%E6%8A%80%E6%96%B0%E9%97%BB/"/>
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="weekly" scheme="http://www.codewoody.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>Python下的音频处理库librosa打开文件是显示NoBackendError的解决</title>
    <link href="http://www.codewoody.com/posts/40199/"/>
    <id>http://www.codewoody.com/posts/40199/</id>
    <published>2019-06-26T04:56:10.000Z</published>
    <updated>2019-06-28T08:40:42.899Z</updated>
    
    <content type="html"><![CDATA[<p>近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。 <a id="more"></a></p><p>由于我的程序中只采用了<code>librosa.load</code>这个命令，通过源代码可以发现librosa实际上是用<code>audioread</code>这个库的<code>audioread.audio_open</code>来读取音频文件的。这个函数的源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_open</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">"""Open an audio file using a library that is available on this</span></span><br><span class="line"><span class="string">    system.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Standard-library WAV and AIFF readers.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> rawread</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> rawread.RawAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Core Audio.</span></span><br><span class="line">    <span class="keyword">if</span> _ca_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> macca</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> macca.ExtAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GStreamer.</span></span><br><span class="line">    <span class="keyword">if</span> _gst_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> gstdec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> gstdec.GstAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MAD.</span></span><br><span class="line">    <span class="keyword">if</span> _mad_available():</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> maddec</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> maddec.MadAudioFile(path)</span><br><span class="line">        <span class="keyword">except</span> DecodeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FFmpeg.</span></span><br><span class="line">    <span class="keyword">from</span> . <span class="keyword">import</span> ffdec</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ffdec.FFmpegAudioFile(path)</span><br><span class="line">    <span class="keyword">except</span> DecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># All backends failed!</span></span><br><span class="line">    <span class="keyword">raise</span> NoBackendError()</span><br></pre></td></tr></table></figure><p>可见之前我们遇到的NoBackendError就是这里的最后一行抛出的了，由于我安装的FFmpeg，进一步进入ffdec.py这个文件中。不难发现实际打开文件的是下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">popen_multiple</span><span class="params">(commands, command_args, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Like `subprocess.Popen`, but can try multiple commands in case</span></span><br><span class="line"><span class="string">    some are not available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `commands` is an iterable of command names and `command_args` are</span></span><br><span class="line"><span class="string">    the rest of the arguments that, when appended to the command name,</span></span><br><span class="line"><span class="string">    make up the full first argument to `subprocess.Popen`. The</span></span><br><span class="line"><span class="string">    other positional and keyword arguments are passed through.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i, command <span class="keyword">in</span> enumerate(commands):</span><br><span class="line">        cmd = [command] + command_args</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> subprocess.Popen(cmd, *args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">if</span> i == len(commands) - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># No more commands to try.</span></span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>这里的<code>commands</code>是直接传入的第33行的<code>COMMANDS</code>变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>我这里倒腾了好几下，最终发现实际是错误的原因是没有找到ffmpeg这个命令。我们在这里将ffmpeg替换成ffmpeg的绝对路径。你可以通过下面这行命令找到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ffmpeg</span><br></pre></td></tr></table></figure><p>最终我改成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS = (<span class="string">'/usr/bin/ffmpeg'</span>, <span class="string">'avconv'</span>)</span><br></pre></td></tr></table></figure><p>Boom！一切就工作正常了。这么想起来应该是安装ffmpeg的时候的环境变量有问题，导致在command line方式下调用ffmpeg命令出错吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日在django项目中采用了librosa来分析用户上传的音频，主要是对其做一定间隔的采样用于绘制波形图。在本地(MacOS)上工作正常，部署到Ubuntu服务器后，自己手动用python方式运行django的server时，工作都是正常的，然而当我用superviosr挂起之后就一直报NoBackendError的错误，反复检查了FFmpeg的安装，应该是没有问题的。网上搜了一下没有看到比较合适的解决办法，故不得不自己读源码来调试了。
    
    </summary>
    
      <category term="Debug" scheme="http://www.codewoody.com/categories/Debug/"/>
    
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="python" scheme="http://www.codewoody.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Latex中各种各样的箭头</title>
    <link href="http://www.codewoody.com/posts/13297/"/>
    <id>http://www.codewoody.com/posts/13297/</id>
    <published>2019-06-24T01:52:42.000Z</published>
    <updated>2019-06-24T02:19:58.271Z</updated>
    
    <content type="html"><![CDATA[<p>Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。 <a id="more"></a></p><h2 id="默认箭头">默认箭头</h2><p>这里的默认指你不需要任何额外的<code>usepackage</code>就可以使用：</p><!-- ![默认箭头](https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png) --><img src="https://imgs.codewoody.com/uploads/big/43e7df8a651987e7b6897a0e0fa4d25b.png" width="60%"><figcaption>默认箭头</figcaption><h2 id="amssymb提供的箭头">amssymb提供的箭头</h2><p>需要<code>\usepackage{amssymb}</code></p><!-- ![amssymb箭头](https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png) --><img src="https://imgs.codewoody.com/uploads/big/7649e62ba185ffdbe255a3e10a36bbef.png" width="60%"><figcaption>amssymb箭头</figcaption><h2 id="further-reading">Further Reading</h2><p><a href="http://www.sascha-frank.com/Arrow/latex-arrows.html" target="_blank" rel="noopener">LaTeX arrows</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Latex中提供了各种“稀奇古怪的箭头形状”。一般箭头使用在公式环境下面。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="latex" scheme="http://www.codewoody.com/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>部署Pritunl来使用OpenVPN</title>
    <link href="http://www.codewoody.com/posts/23676/"/>
    <id>http://www.codewoody.com/posts/23676/</id>
    <published>2019-06-13T06:16:27.000Z</published>
    <updated>2019-06-13T07:04:39.437Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="why-vpn">Why VPN</h2><p>为什么要使用VPN？尤其是，为什么个人用户需要使用VPN呢？其实如果你只有一台电脑，其实一般用不上VPN（当然，用VPN来翻墙另说），如果你有多个电脑，甚至是服务器，这些服务器的网络情况还比较复杂，而你希望随时随地方便地访问这些机器，那么建立VPN虚拟网络将这些机器连接起来就能极大的方便访问过程。例如，如果一台服务器是在路由器后面，没有公网IP，与其在路由器上配置复杂的端口映射表，不如通过VPN网络自由地访问各个端口。又例如在一些特定的场景下，一些服务器的低位（1024以下）端口的访问会收到限制，这个也可以同VPN来解决。</p><p>当然，还有可能，你处于校园网中，而你通过种种途径有了一个无限流量服务器，通过VPN，可以让你在校园网场景下能够随时通过这台服务器上网，从而免去流量费用。另外，将这一宝贵资源分享给同学使用，用VPN也非常方便。</p><h2 id="why-pritunl">Why Pritunl</h2><p>我试过很多VPN方案，例如PPTP，OpenVPN，IPSec等等。其实使用VPN过程中的一个痛点在于用户管理要尽可能方便，虽然我也比较多的在用命令行工具，但是使用命令行工具去管理用户体验还是非常差。Pritunl提供了OpenVPN的网页GUI管理界面。这也是我为什么推荐使用Priunl的原因。而且，Pritunl中免费用户就可以使用无数量限制的账户和设备，这对于个人用户来说足够了。</p><p>另一方面，Pritunl的客户端支持也非常全面</p><h2 id="how-to-deploy">How to deploy</h2><h3 id="installation">Installation</h3><p>官方文档在这里: <a href="https://docs.pritunl.com/docs/installation" target="_blank" rel="noopener">Installation</a>。事实上按照官方文档的推荐，Pritunl最好部署在企业级的Linux OS上，如Red Hat, Oracle Linux, CentOS等。不过对于个人用户，对于性能，稳定性和安全性要求没有那么严格的情况下，用Debian系的系统也未尝不可。我的Pritunl服务器就是部署在Ubuntu上的，几个月使用下来，性能和稳定性都非常好。</p><p>对于不同版本的系统，安装脚本不同。例如，Ubuntu 16.04，安装脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list &lt;&lt; EOF</span><br><span class="line">deb https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.0 multiverse</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo tee /etc/apt/sources.list.d/pritunl.list &lt;&lt; EOF</span><br><span class="line">deb http://repo.pritunl.com/stable/apt xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 9DA31620334BD75D9DCB49F368818C72E52529D4</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 7568D9BB55FF9E5287D586017AE645C0CF8E292A</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get --assume-yes install pritunl mongodb-org</span><br><span class="line">sudo systemctl start pritunl mongod</span><br><span class="line">sudo systemctl enable pritunl mongod</span><br></pre></td></tr></table></figure><h3 id="configuration">Configuration</h3><p>在安装完Pritunl之后，访问服务器的443端口，即可以看到配置引导界面。</p><figure><img src="https://imgs.codewoody.com/uploads/big/04288b446ec0e7ad27b790dd4890d71b.png" alt="配置界面"><figcaption>配置界面</figcaption></figure><p>其中需要输入的主要是第一项Setup Key。数据库部分，如果你是使用上面的脚本安装的话，那么Pritunl服务本机上就已经安装运行了MongoDB，这里第二个配置MongoDB URI就不需要变动。要获取Setup Key，ssh进入部署服务器，运行<code>pritunl setup-key</code>即可.</p><p>完成这一步设置以后就来到管理员登录界面：</p><figure><img src="https://imgs.codewoody.com/uploads/big/5310344dc5cd485d83835f900fdf38df.png" alt="管理员登录界面"><figcaption>管理员登录界面</figcaption></figure><p>初始时用户名和密码都是<code>pritunl</code>，在完成第一次登录之后会被要求修改管理员的用户名和密码：</p><figure><img src="https://imgs.codewoody.com/uploads/big/88164d6b435cfb64cc84a35bd6188235.png" alt="修改密码"><figcaption>修改密码</figcaption></figure><h2 id="further-reading">Further Reading</h2><p>Pritunl的使用方法非常直观，文档可以参见<a href="https://docs.pritunl.com/docs/connecting" target="_blank" rel="noopener">Connecting</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/0f3a766a78effb06b6770d8a61ad2e55.png&quot; alt=&quot;Pritunl&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="vpn" scheme="http://www.codewoody.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Linux下OpenVPN客户端配置</title>
    <link href="http://www.codewoody.com/posts/38823/"/>
    <id>http://www.codewoody.com/posts/38823/</id>
    <published>2019-05-17T02:46:41.000Z</published>
    <updated>2019-05-17T03:21:20.760Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.codewoody.com/uploads/big/cb54becbed976afbcd2d21733fcf85c6.png" alt="OpenVPN"> <a id="more"></a></p><h2 id="环境配置">环境配置</h2><p>安装OpenVPN的方法很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn</span><br></pre></td></tr></table></figure><h2 id="使用方法">使用方法</h2><p>首先你需要从OpenVPN服务提供商那里得到<code>*.ovpn</code>配置文件，然后在服务器上运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo openvpn --config your.ovpn</span><br></pre></td></tr></table></figure><p>不过这个命令会在前台运行，当我们退出SSH之后就会终止。为了让OpenVPN能够在后台运行，且能够自动开机启动，我们需要借助于Systemctl的帮助。首先我们将ovpn文件复制到<code>/etc/openvpn/client/</code>下，<strong>将后缀直接修改为<code>.conf</code></strong>。如果配置文件需要我们手动输入密码，我们需要将密码以配置文件的形式固定下来，不然自动启动会失败。在<code>/etc/openvpn/client/</code>新建一个<code>account.txt</code>文件，在其中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username</span><br><span class="line">password</span><br></pre></td></tr></table></figure><blockquote><p>有些OpenVPN服务端工具只会生成密码（例如Pritunl），在这里username可以随意输入一个，然后在下面一行添加密码。</p></blockquote><p>然后进入配置文件，找到<code>auth-user-pass</code>。默认情况下这个配置条目后面是空的，我们将其修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth-user-pass /etc/openvpn/client/account.txt</span><br></pre></td></tr></table></figure><p>假设前面我们复制过来的配置文件的名字为<code>default.conf</code>。输入下面的命令以启用这个vpn：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn-client@default</span><br></pre></td></tr></table></figure><p>要启动这个vpn，使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvpn-client@default</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/cb54becbed976afbcd2d21733fcf85c6.png&quot; alt=&quot;OpenVPN&quot;&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="linux" scheme="http://www.codewoody.com/tags/linux/"/>
    
      <category term="vpn" scheme="http://www.codewoody.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib in Virtualenv</title>
    <link href="http://www.codewoody.com/posts/30912/"/>
    <id>http://www.codewoody.com/posts/30912/</id>
    <published>2019-05-16T05:56:36.000Z</published>
    <updated>2019-06-28T08:40:38.956Z</updated>
    
    <content type="html"><![CDATA[<p>我使用的是macOS系统。当在虚拟环境中尝试使用matplotlib时，会出现如下的报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of &apos;python&apos; with &apos;pythonw&apos;. See &apos;Working with Matplotlib on OSX&apos; in the Matplotlib FAQ for more informatio</span><br></pre></td></tr></table></figure><a id="more"></a><p>根据错误信息，要么我们使用Python as Framework，要么我们更换使用的后端（backend）。Matplot专门就matplotlib的后端问题有一个网页：<a href="https://matplotlib.org/faq/virtualenv_faq.html" target="_blank" rel="noopener">Working with Matplotlib in Virtual environments</a>。文章中提到，<code>Tk</code>这个框架（即<code>TkAgg</code>后端）一般来说总是可用的，不需要额外的外部依赖。（不过在特定的Linux发行版本中可能需要安装<code>python-tk</code>）。要使用<code>Tk</code>需要做如下配置过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">"TkAgg"</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>每次这么配置比较麻烦，我们可以通过<code>~/.matplotlib/matplitlibrc</code>文件来固化配置（如果这个文件不存在可以手动创建），文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backend: TkAgg</span><br></pre></td></tr></table></figure><p>不过我在使用过程中发现使用<code>TkAgg</code>时会出现系统级的错误，抛出了<code>Terminating app due to uncaught exception</code>的错误。因此我尝试替换成其他后端。我主要选择包括：</p><figure><img src="https://imgs.codewoody.com/uploads/big/bdd0f72aede5a20bf5378bc373287e55.png" alt="Matplotlib可用后端类型"><figcaption>Matplotlib可用后端类型</figcaption></figure><p>而又因为<code>PySide</code>只支持比较早的python版本，因此我选择了Qt5作为后端。在这之前，我们需要安装下面的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install qt</span><br><span class="line">pip install PySide2</span><br></pre></td></tr></table></figure><p>安装完成后配置过程和<code>TkAgg</code>的类似，后端的名字为<code>QT5Agg</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我使用的是macOS系统。当在虚拟环境中尝试使用matplotlib时，会出现如下的报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ImportError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of &amp;apos;python&amp;apos; with &amp;apos;pythonw&amp;apos;. See &amp;apos;Working with Matplotlib on OSX&amp;apos; in the Matplotlib FAQ for more informatio&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="python" scheme="http://www.codewoody.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ns3 在模块中使用第三方库</title>
    <link href="http://www.codewoody.com/posts/53831/"/>
    <id>http://www.codewoody.com/posts/53831/</id>
    <published>2019-05-12T12:47:21.000Z</published>
    <updated>2019-05-12T13:31:18.615Z</updated>
    
    <content type="html"><![CDATA[<p>ns3使用了waf编译系统，因此在ns3中尝试引入第三方模块时，就没有make那么直接了。</p><a id="more"></a><p>其实思路的核心还是想办法最终为编译器提供<code>-L</code>和<code>-I</code>的设置。这个过程我们通过<code>wscript</code>中的<code>configure</code>函数来实现。这里我们假设模块使用的库的位置放在模块源码目录下的<code>libs</code>子目录。库的名字为<code>example-lib</code>。目录结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libs</span><br><span class="line">└── example-lib</span><br><span class="line">  ├── include</span><br><span class="line">  └── libexample-lib.a</span><br></pre></td></tr></table></figure><p>其中，<code>include</code>文件夹内为头文件，<code>libexample-lib.a</code>为静态库文件。</p><p>修改<code>wscript</code>文件中的configure函数，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(conf)</span>:</span></span><br><span class="line">    root_dir = conf.path.abspath()</span><br><span class="line">    example_lib_dir = os.path.join(root_dir, <span class="string">"libs/example-lib"</span>)</span><br><span class="line">    conf.env.append_value(<span class="string">"LINKFLAGS"</span>, </span><br><span class="line">        [<span class="string">"-L%s/"</span> % example_lib_dir])</span><br><span class="line">    conf.env.append_value(<span class="string">"LIB"</span>, [<span class="string">"example-lib"</span>])</span><br><span class="line">    conf.env.append_value(<span class="string">"CPPFLAGS"</span>, </span><br><span class="line">        [<span class="string">"-I%s/include"</span> % example_lib_dir, ])</span><br></pre></td></tr></table></figure><p>修改<code>configure</code>函数之后要重新运行<code>./waf configure</code>命令来让设置生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ns3使用了waf编译系统，因此在ns3中尝试引入第三方模块时，就没有make那么直接了。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>ns3 wscript: 自动寻找需编译的源文件</title>
    <link href="http://www.codewoody.com/posts/3426/"/>
    <id>http://www.codewoody.com/posts/3426/</id>
    <published>2019-05-11T08:19:17.000Z</published>
    <updated>2019-05-15T05:15:05.307Z</updated>
    
    <content type="html"><![CDATA[<p>在ns3的编译体系中，每个module会包含一个名为wscript的python脚本来提供编译信息。例如，一个通过<code>create-module.py</code>创建的module中的wscript为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def options(opt):</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def configure(conf):</span></span><br><span class="line"><span class="comment">#     conf.check_nonfatal(header_name='stdint.h', define_name='HAVE_STDINT_H')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(bld)</span>:</span></span><br><span class="line">    module = bld.create_ns3_module(<span class="string">'example-module'</span>, [<span class="string">'core'</span>])</span><br><span class="line">    module.source = [</span><br><span class="line">        <span class="string">'model/example-module.cc'</span>,</span><br><span class="line">        <span class="string">'helper/example-module-helper.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    module_test = bld.create_ns3_module_test_library(<span class="string">'example-module'</span>)</span><br><span class="line">    module_test.source = [</span><br><span class="line">        <span class="string">'test/example-module-test-suite.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    headers = bld(features=<span class="string">'ns3header'</span>)</span><br><span class="line">    headers.module = <span class="string">'example-module'</span></span><br><span class="line">    headers.source = [</span><br><span class="line">        <span class="string">'model/example-module.h'</span>,</span><br><span class="line">        <span class="string">'helper/example-module-helper.h'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bld.env.ENABLE_EXAMPLES:</span><br><span class="line">        bld.recurse(<span class="string">'examples'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bld.ns3_python_bindings()</span></span><br></pre></td></tr></table></figure><p>其中，<code>module.source</code>中包含需要编译的<code>.cc</code>源文件，而<code>headers.source</code>中包含对应的头文件。每次新建C++源代码文件时，都需要手动添加到这里的列表中。下面我给出一个自动从<code>module</code>的<code>model</code>, <code>helper</code>目录下搜索源文件的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def options(opt):</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def configure(conf):</span></span><br><span class="line"><span class="comment">#     conf.check_nonfatal(header_name='stdint.h', define_name='HAVE_STDINT_H')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_list_sources</span><span class="params">(bld, suffix)</span>:</span></span><br><span class="line">    root_dir = bld.path.abspath()</span><br><span class="line">    res = [</span><br><span class="line">        x <span class="keyword">for</span> x <span class="keyword">in</span> </span><br><span class="line">            [os.path.join(<span class="string">"model"</span>, y) <span class="keyword">for</span> y <span class="keyword">in</span> os.listdir(os.path.join(root_dir, <span class="string">"model"</span>))]</span><br><span class="line">        <span class="keyword">if</span> x.endswith(suffix)</span><br><span class="line">    ]</span><br><span class="line">    res += [</span><br><span class="line">        x <span class="keyword">for</span> x <span class="keyword">in</span> </span><br><span class="line">            [os.path.join(<span class="string">"helper"</span>, y) <span class="keyword">for</span> y <span class="keyword">in</span> os.listdir(os.path.join(root_dir, <span class="string">"helper"</span>))]</span><br><span class="line">        <span class="keyword">if</span> x.endswith(suffix)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(bld)</span>:</span></span><br><span class="line">    module = bld.create_ns3_module(<span class="string">'example-module'</span>, [<span class="string">"core"</span>])</span><br><span class="line">    module.source = _list_sources(bld, <span class="string">".cc"</span>)</span><br><span class="line"></span><br><span class="line">    module_test = bld.create_ns3_module_test_library(<span class="string">'example-module'</span>)</span><br><span class="line">    module_test.source = [</span><br><span class="line">        <span class="string">'test/mix-autonomy-test-suite.cc'</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    headers = bld(features=<span class="string">'ns3header'</span>)</span><br><span class="line">    headers.module = <span class="string">'example-module'</span></span><br><span class="line">    headers.source = _list_sources(bld, <span class="string">".h"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bld.env.ENABLE_EXAMPLES:</span><br><span class="line">        bld.recurse(<span class="string">'examples'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bld.ns3_python_bindings()</span></span><br></pre></td></tr></table></figure><blockquote><p>注意不要直接套用上面的范例文件，需要将&quot;example-module&quot;的名字改为你的module的名字</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在ns3的编译体系中，每个module会包含一个名为wscript的python脚本来提供编译信息。例如，一个通过&lt;code&gt;create-module.py&lt;/code&gt;创建的module中的wscript为&lt;/p&gt;
&lt;figure class=&quot;highlight py
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="ns3" scheme="http://www.codewoody.com/tags/ns3/"/>
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线原理</title>
    <link href="http://www.codewoody.com/posts/50553/"/>
    <id>http://www.codewoody.com/posts/50553/</id>
    <published>2019-05-10T02:38:26.000Z</published>
    <updated>2019-05-10T03:03:53.812Z</updated>
    
    <content type="html"><![CDATA[</p><p>这是一篇<a href="https://www.cnblogs.com/hnfxs/p/3148483.html" target="_blank" rel="noopener">转载文章</a>。Bézier curve(贝塞尔曲线)是应用于二维图形应用程序的数学曲线。 曲线定义：起始点、终止点（也称锚点）、控制点。通过调整控制点，贝塞尔曲线的形状会发生变化。 1962年，法国数学家Pierre Bézier第一个研究了这种矢量绘制曲线的方法，并给出了详细的计算公式，因此按照这样的公式绘制出来的曲线就用他的姓氏来命名，称为贝塞尔曲线。</p><h2 id="抛物线三切线定理">抛物线三切线定理</h2><p>设<span class="math inline">\(P_0\)</span>，<span class="math inline">\(P_0^2\)</span>，<span class="math inline">\(P_2\)</span>是一跳抛物线上顺序不同的三个点。过<span class="math inline">\(P_0\)</span>和<span class="math inline">\(P2\)</span>的切线交于<span class="math inline">\(P_1\)</span>。过<span class="math inline">\(P_0^2\)</span>的切线交<span class="math inline">\(P_0 P_1\)</span>和<span class="math inline">\(P_2 P_1\)</span>相交于<span class="math inline">\(P_0^1\)</span>和<span class="math inline">\(P_1^1\)</span>，则有如下比例成立：</p><p><span class="math display">\[\begin{equation}\frac{P_{0} P_{0}^{1}}{P_{0}^{1} P_{1}}=\frac{P_{1} P_{1}^{1}}{P_{1}^{1} P_{2}}=\frac{P_{0}^{1} P_{0}^{2}}{P_{0}^{2} P_{1}^{1}}\end{equation}\]</span></p><figure><img src="https://imgs.codewoody.com/uploads/big/c6362fee9c4a8ffabc786c7b8c37a826.gif" alt="抛物线三切线定理示意图"><figcaption>抛物线三切线定理示意图</figcaption></figure><p>此即为抛物线的三切线定理。</p><h2 id="二次贝塞尔曲线">二次贝塞尔曲线</h2><p>当<span class="math inline">\(P_0\)</span>，<span class="math inline">\(P_2\)</span>固定时，引入参数<span class="math inline">\(t\)</span>，令上述比例值为<span class="math inline">\(t:(1-t)\)</span>，即有：</p><p><span class="math display">\[\begin{equation}\begin{array}{l}{P_{0}^{1}=(1-t) P_{0}+t P_{1}} \\ {P_{1}^{1}=(1-t) P_{1}+t P_{2}} \\ {P_{0}^{2}=(1-t) P_{0}^{1}+t P_{1}^{1}}\end{array}\end{equation}\]</span></p><p>将第一，二个式子代入第三个有：</p><p><span class="math display">\[\begin{equation}P_{0}^{2}=(1-t)^{2} P_{0}+2 t(1-t) P_{1}+t^{2} P_{2}\end{equation}\]</span></p><p>当<span class="math inline">\(t\)</span>从0变到1时，<span class="math inline">\(P_0^2\)</span>点经过的轨迹即为上图中的抛物线，也即为由三顶点<span class="math inline">\(P_0\)</span>, <span class="math inline">\(P_1\)</span>, <span class="math inline">\(P_2\)</span>决定的一条二次贝塞尔曲线。也可以认为这条二次贝塞尔曲线是由两个前顶点<span class="math inline">\((P_0, P_1)\)</span>以及两个后顶点<span class="math inline">\((P_1, P_2)\)</span>决定的。</p><h2 id="更高阶的贝塞尔曲线">更高阶的贝塞尔曲线</h2><p>类似于二次贝塞尔曲线的推导过程，我们可以推广到更高阶的贝塞尔曲线。</p><p>由四个控制点定义的三次Bezier曲线<span class="math inline">\(P_0^3\)</span>可被定义为分别由<span class="math inline">\((P_0,P_1,P_2)\)</span>和<span class="math inline">\((P_1,P_2,P_3)\)</span>确定的二条二次Bezier曲线的线性组合，由<span class="math inline">\((n+1)\)</span>个控制点<span class="math inline">\(P_i(i=0,1,...,n)\)</span>定义的n次Bezier曲线<span class="math inline">\(P_0^n\)</span>可被定义为分别由前、后<span class="math inline">\(n\)</span>个控制点定义的两条<span class="math inline">\((n-1)\)</span>次Bezier曲线<span class="math inline">\(P_0^{n-1}\)</span>与<span class="math inline">\(P+0^{n-1}\)</span>的线性组合：</p><p><span class="math display">\[\begin{equation}P_{0}^{n}=(1-t) P_{0}^{n-1}+t P_{1}^{n-1} \quad t \in[0,1]\end{equation}\]</span></p><p>由此可以得到Bezier曲线的踢腿计算公式</p><p><span class="math display">\[\begin{equation}P_{i}^{k}=\left\{\begin{array}{c}{P_{i}} &amp; {k=0} \\ {(1-t) P_{i}^{k-1}+t P_{i+1}^{k-1}} &amp; {k=1,2, \cdots, n, i=0,1, \cdots, n-k}\end{array}\right.\end{equation}\]</span></p><p>这就是de Castelijau算法。</p><h2 id="贝塞尔曲线原理动图">贝塞尔曲线原理动图</h2><figure><img src="https://imgs.codewoody.com/uploads/big/bcaaa9ffd59424956ecaf9bf9997ad41.gif" alt="一阶贝塞尔曲线"><figcaption>一阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/5f61dfa0ca56be6f035a7800a5be35d2.gif" alt="二阶贝塞尔曲线"><figcaption>二阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/8fad9c6df6e51bc78f83b44ee9fb65d1.gif" alt="三阶贝塞尔曲线"><figcaption>三阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/318c16114eacc2f0899fdf6f19df996b.gif" alt="四阶贝塞尔曲线"><figcaption>四阶贝塞尔曲线</figcaption></figure><figure><img src="https://imgs.codewoody.com/uploads/big/16bd24901ea98b88916dcbb0ead66cd7.gif" alt="五阶贝塞尔曲线"><figcaption>五阶贝塞尔曲线</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgs.codewoody.com/uploads/big/16bd24901ea98b88916dcbb0ead66cd7.gif&quot; alt=&quot;五阶贝塞尔曲线&quot;&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.codewoody.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="转载" scheme="http://www.codewoody.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="processing" scheme="http://www.codewoody.com/tags/processing/"/>
    
      <category term="数学" scheme="http://www.codewoody.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Docker Volume的权限问题</title>
    <link href="http://www.codewoody.com/posts/25188/"/>
    <id>http://www.codewoody.com/posts/25188/</id>
    <published>2019-05-08T06:38:09.000Z</published>
    <updated>2019-06-28T08:40:36.057Z</updated>
    
    <content type="html"><![CDATA[<p>这里我们要解决的是使用Docker过程中常见的Volume权限问题。具体而言，当我们用<code>-v</code>将宿主机的路径绑定到Docker镜像的内部路径时，有时候会导致Docker镜像缺少对这个目录的访问权限，从而导致进程出错。</p><a id="more"></a><h2 id="why">Why</h2><p>当我们绑定宿主目录到镜像时，如果该目录不存在，Docker也会自动创建该目录。这种方式创建出来的目录的拥有者是root用户。如果该目录已经存在，那么其拥有者就取决于宿主配置的情况了。</p><p>由于Docker内部的用户空间和宿主的用户空间是独立的，如果镜像内运行进程的用户和宿主目录的拥有者不符合，就会出现权限问题。</p><h2 id="how-to-solve-it">How to solve it</h2><p>由于镜像内和宿主的用户名空间是不同的，所以通过用户名的方式来变更宿主目录的所有权会失效。然而，事实上用户系统是通过uid来标识不同的用户的，我们只需要将宿主的路径的拥护者改为镜像内用户相通的uid即可。镜像内用户的uid可以通过如下方式查看，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jovyan@8fed6b266a3c:~$ id</span><br><span class="line">uid=1000(jovyan) gid=100(users) groups=100(users)</span><br></pre></td></tr></table></figure><p>继而再修改宿主机上对应目录的拥有者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R 1000 /path/to/volume</span><br></pre></td></tr></table></figure><h2 id="further-research">Further Research</h2><p>上面的方法可以解决Volume访问权限的问题，不过会产生潜在的漏洞。从镜像内获得的uid在宿主上可能表示的是不同的用户，在宿主机上修改目录的拥有者会导致数据被同一服务器上的其他用户访问，带来安全性上的问题。</p><p>另一方面，如果有多个镜像需要共享一个Volume，而他们内部的运行用户的uid不同的话，就需要在宿主上进行更加复杂的用户以及组的配置。</p><p>更优雅的执行方法有下面两种：</p><h3 id="use-named-volume">Use Named Volume</h3><p>Named Volumes</p><h3 id="由容器自行配置权限问题">由容器自行配置权限问题</h3><h2 id="reference">Reference</h2><ol type="1"><li><a href="https://yq.aliyun.com/articles/53990" target="_blank" rel="noopener">谈谈 Docker Volume 之权限管理（一）</a></li><li><a href="https://stackoverflow.com/questions/23544282/what-is-the-best-way-to-manage-permissions-for-docker-shared-volumes?spm=a2c4e.11153940.blogcont53990.8.3421149142aS92" target="_blank" rel="noopener">What is the (best) way to manage permissions for Docker shared volumes?</a></li><li><a href="https://medium.com/@ramangupta/why-docker-data-containers-are-good-589b3c6c749e" target="_blank" rel="noopener">Why Docker Data Containers (Volumes!) are Good</a></li><li><a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">Use volumes</a></li><li><a href="https://success.docker.com/article/different-types-of-volumes" target="_blank" rel="noopener">Different Types of Volumes</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我们要解决的是使用Docker过程中常见的Volume权限问题。具体而言，当我们用&lt;code&gt;-v&lt;/code&gt;将宿主机的路径绑定到Docker镜像的内部路径时，有时候会导致Docker镜像缺少对这个目录的访问权限，从而导致进程出错。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Debug" scheme="http://www.codewoody.com/tags/Debug/"/>
    
      <category term="docker" scheme="http://www.codewoody.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>读书破万卷,下笔如有神</title>
    <link href="http://www.codewoody.com/posts/60435/"/>
    <id>http://www.codewoody.com/posts/60435/</id>
    <published>2019-05-06T03:00:06.000Z</published>
    <updated>2019-06-28T01:46:57.496Z</updated>
    
    <content type="html"><![CDATA[<p>能够获得暴利的职业，都有一个共同特点：可扩展性（scaling），一次劳动可以服务成千上万的人。</p><p>软件、电影、游戏行业都具有可扩展性，作品的生产成本是固定的，但可以被消费无数次，所以有巨大的获利空间，创造出许许多多的富豪。另一方面，理发师、厨师、出租车司机一次劳动，只能服务少数几个人，就不具有可扩展性，很难获得暴利，生存得很辛苦。</p><p>最近，我读到美国一个风险投资家的<a href="https://andrewchen.co/professional-blogging/" target="_blank" rel="noopener">文章</a>。他说了一句发人深思的话：</p><p>&quot;写作是最具可扩展性的活动。你呆在家里，不去参加活动/会议，只是在网上写下自己的想法，然后你就具有了最好的可扩展性。&quot;</p><p>我想了一下，还真是这样。你写了一篇文章，想让其他人看到，只要到处张贴就行了。每次转贴，就是扩展了一次。这比其他产品的扩展容易多了。面包师傅想要更多的人尝到自己的面包，只能多开面包店；网站要扩展，只能购买更多的服务器。相比之下，文字的扩展简直是零成本。</p><p>大公司每年花费数十亿美元用于广告，以求人们关注他们的产品。但是，一个好的作家可以免费获得这种扩展性。这就是为什么你应该把自己的想法写下来的原因，这么好的免费传播渠道，为什么不用呢？你以为，写下来不会有人看。错，其实是有人会看到的，如果他们觉得有价值，就会帮你传播出去。</p><div class="note info">            <p>这篇文章转载自<a href="http://www.ruanyifeng.com/blog/2019/05/weekly-issue-54.html" target="_blank" rel="noopener">阮一峰的博客</a>。这篇文章其实说了一个非常简洁明了却价值巨大的道理，也给我们启示：我们应该如何规划自己的职业道路。只是靠出售自己的时间，即便是清北的同学，也只是能做到一个尚算富裕，但是辛苦中产阶级。要更上一层楼，还是需要手握资本。而怎么获得资本呢？其实就是靠文章里说的“可扩展性的工作”。</p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;能够获得暴利的职业，都有一个共同特点：可扩展性（scaling），一次劳动可以服务成千上万的人。&lt;/p&gt;
&lt;p&gt;软件、电影、游戏行业都具有可扩展性，作品的生产成本是固定的，但可以被消费无数次，所以有巨大的获利空间，创造出许许多多的富豪。另一方面，理发师、厨师、出租车司机一次
      
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Pandoc渲染引擎导致Hexo Tag渲染失败的临时解决办法</title>
    <link href="http://www.codewoody.com/posts/62502/"/>
    <id>http://www.codewoody.com/posts/62502/</id>
    <published>2019-04-25T06:06:21.000Z</published>
    <updated>2019-04-25T06:20:14.806Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.codewoody.com/posts/20215/">Hexo+Next: 使用Latex公式</a>这篇文章中我发现在使用<code>Pandoc</code>作为Hexo的渲染引擎时，Hexo的标签功能会有问题，具体表现为Hexo的标签内部的内容会输出markdown源码，而非渲染后的html。 <a id="more"></a></p><h2 id="问题研究">问题研究</h2><p>经过我的研究，这是因为<code>hexo-render-pandoc</code>在注册自己的<code>renderer</code>时，只注册了异步渲染的renderer，而没有注册同步渲染的renderer，而Hexo的标签中主要是用同步renderer。以当时我使用的NexT的note标签为例。其实现代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postNote</span>(<span class="params">args, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;div class="note <span class="subst">$&#123;args.join(<span class="string">' '</span>)&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;hexo.render.renderSync(&#123;text: content, engine: <span class="string">'markdown'</span>&#125;</span>).split('\n').join('')&#125;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">'note'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">hexo.extend.tag.register(<span class="string">'subnote'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>由于没有注册同步渲染器，这里的<code>hexo.render.renderSync</code>渲染会失败，从而返回的是<code>content</code>中的原本内容，也即Markdown形式的源码。</p><h2 id="解决办法">解决办法</h2><p>彻底的解决办法，自然是在<code>hexo-render-pandoc</code>中同时注册同步渲染器。不过我自己尝试之后发现作为同步渲染器，<code>pandoc</code>和Hexo使用模板引擎貌似有冲突。更细致深入的修改最好还是由原作者来进行（我已经提交了<a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/33" target="_blank" rel="noopener">Issue</a>）。</p><p>这里我给出一个临时的解决办法：既然<code>hexo-render-pandoc</code>只注册了异步渲染代码，那么我们在Tag的实现代码中调用异步渲染的接口就可以了。仍然以NexT主题的note标签为例，可以将代码修改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postNote</span>(<span class="params">args, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hexo.render.render(&#123;<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`&lt;div class="note <span class="subst">$&#123;args.join(<span class="string">' '</span>)&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;res.split(<span class="string">'\n'</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">          &lt;/div&gt;`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">// return `&lt;div class="note $&#123;args.join(' ')&#125;"&gt;</span></span><br><span class="line">  <span class="comment">//           $&#123;hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;).split('\n').join('')&#125;</span></span><br><span class="line">  <span class="comment">//         &lt;/div&gt;`;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">'note'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">hexo.extend.tag.register(<span class="string">'subnote'</span>, postNote, &#123;<span class="attr">ends</span>: <span class="literal">true</span>, <span class="attr">async</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>经过这样修改就可以了。不过这种方法仍然只是权宜之计，要是去修改每个Tag的实现，就太繁琐了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.codewoody.com/posts/20215/&quot;&gt;Hexo+Next: 使用Latex公式&lt;/a&gt;这篇文章中我发现在使用&lt;code&gt;Pandoc&lt;/code&gt;作为Hexo的渲染引擎时，Hexo的标签功能会有问题，具体表现为Hexo的标签内部的内容会输出markdown源码，而非渲染后的html。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Next: 使用Latex公式</title>
    <link href="http://www.codewoody.com/posts/20215/"/>
    <id>http://www.codewoody.com/posts/20215/</id>
    <published>2019-04-24T04:55:54.000Z</published>
    <updated>2019-04-25T05:27:15.577Z</updated>
    
    <content type="html"><![CDATA[<p>这次更换主题的很大一个动因就是因为在NexT这个主题上，开启Latex的支持很方便。网上关于这方面的文章其实不少，但是大部分都不全面，照本宣科下来，很可能不能用。这些教程一般就给了<code>_config.yml</code>文件的配置以及<code>pandoc</code>依赖安装，但是一些关键细节缺失了。这篇文章里我梳理了一下整个流程。 <a id="more"></a></p><h2 id="reference">0. Reference</h2><p>英语好的话，其实可以尝试直接阅读<a href="https://theme-next.org/docs/third-party-services/math-equations" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="install-dependencies">1. Install Dependencies</h2><p>Next支持<code>mathjax</code>和<code>katex</code>两种渲染方式，其中<code>katex</code>的速度更快，但是对于Latex的支持有一定的限制。所以除非你的博客数量实在是过于庞大，不然就可以直接使用<code>mathjax</code>。</p><p><code>mathjax</code>可以选用下面两种渲染引擎的中的任一一种</p><ul><li><code>hexo-renderer-kramed</code></li><li><code>hexo-render-pandoc</code></li></ul><div class="note info">            <p>使用<code>hexo-render-pandoc</code>还需要安装pandoc渲染引擎。其安装方法可以参考 <a href="http://pandoc.org/installing.html" target="_blank" rel="noopener">pandoc官网</a>。如果在macOS上可以使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>安装.</p>          </div><p>这里以<code>pandoc</code>为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要先卸载默认的渲染引擎</span></span><br><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><div class="note danger">            <p>替换渲染器之后会导致NexT note功能出现问题，note内的元素内容无法渲染，会输出markdown源代码。 这个问题我在<code>hexo-render-pandoc</code>上提了一个<a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/33" target="_blank" rel="noopener">Issue</a>，看原作者什么时候能够更新解决吧。</p>          </div><h2 id="configuration">2. Configuration</h2><p>配置NexT主题的<code>_config.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="comment">#engine: katex</span></span><br></pre></td></tr></table></figure><p>很多文章都漏掉了在配置中一个重要的信息：在主题配置<code>math</code>下有一个名为<code>per_page</code>的选项，其值为<code>true</code>或者<code>false</code>。这个选项用来控制是否对每个篇文章都渲染数学公式。默认情况下是<code>true</code>，这意味只对Front Matter中含有<code>mathjax: true</code>的文章进行公式渲染。将<code>per_page</code>设置为<code>false</code>，则会对每一篇文章都尝试进行公式渲染。</p><p>由于公式渲染时一个很费时的操作，因此还是保持默认配置，通过Front Matter进行渲染控制.</p><h2 id="how-to-use">3. How to use</h2><h3 id="行内嵌套公式">3.1 行内嵌套公式</h3><p>如：质能方程<span class="math inline">\(e=mc^2\)</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：质能方程$e=mc^2$</span><br></pre></td></tr></table></figure><h3 id="独占一行的公式">3.2 独占一行的公式</h3><p>如： <span class="math display">\[1=\sum_{i=0}^{m}\sum_{k=0}^{W_i-1}b_{i,k}=\sum_{i=0}^{m}b_{i,0}\sum_{k=0}^{W_i-1}\frac{W_i-k}{W_i}=\sum_{i=0}^{m}b_{i,0}\frac{W_i+1}{2}\\=\frac{b_{0,0}}{2}\left[W\left(\sum_{i=0}^{m-1}(2p)^i+\frac{(2p)^m}{1-p}\right) + \frac{1}{1-p}\right]\]</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">$$</span><br><span class="line">1=\sum_&#123;i=0&#125;^&#123;m&#125;\sum_&#123;k=0&#125;^&#123;W_i-1&#125;b_&#123;i,k&#125;=\sum_&#123;i=0&#125;^&#123;m&#125;b_&#123;i,0&#125;\sum_&#123;k=0&#125;^&#123;W_i-1&#125;\frac&#123;W_i-k&#125;&#123;W_i&#125;=\sum_&#123;i=0&#125;^&#123;m&#125;b_&#123;i,0&#125;\frac&#123;W_i+1&#125;&#123;2&#125;\\</span><br><span class="line">=\frac&#123;b_&#123;0,0&#125;&#125;&#123;2&#125;\left[W\left(\sum_&#123;i=0&#125;^&#123;m-1&#125;(2p)^i+\frac&#123;(2p)^m&#125;&#123;1-p&#125;\right) + \frac&#123;1&#125;&#123;1-p&#125;\right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><div class="note info">            <p>更多latex的使用方法，请参考官方文档</p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次更换主题的很大一个动因就是因为在NexT这个主题上，开启Latex的支持很方便。网上关于这方面的文章其实不少，但是大部分都不全面，照本宣科下来，很可能不能用。这些教程一般就给了&lt;code&gt;_config.yml&lt;/code&gt;文件的配置以及&lt;code&gt;pandoc&lt;/code&gt;依赖安装，但是一些关键细节缺失了。这篇文章里我梳理了一下整个流程。
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://www.codewoody.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>清华GPA事件备份:2019.04.16</title>
    <link href="http://www.codewoody.com/posts/34235/"/>
    <id>http://www.codewoody.com/posts/34235/</id>
    <published>2019-04-16T06:42:27.000Z</published>
    <updated>2019-04-23T08:55:08.071Z</updated>
    
    <content type="html"><![CDATA[<p>大图预警 <a id="more"></a> <img src="https://imgs.codewoody.com/uploads/big/d08181298573faecd2ad04bcdf7931dc.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大图预警
    
    </summary>
    
      <category term="杂谈" scheme="http://www.codewoody.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.codewoody.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Haproxy支持Ipv6</title>
    <link href="http://www.codewoody.com/posts/12489/"/>
    <id>http://www.codewoody.com/posts/12489/</id>
    <published>2019-04-13T08:47:20.000Z</published>
    <updated>2019-05-10T03:06:06.896Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="haproxy">Haproxy</h2><p><a href="http://www.haproxy.org/" target="_blank" rel="noopener">Haproxy is a reliable, high performance TCP/HTTP Load Balancer</a></p><p>这是官网对于Haproxy的介绍，其作用的类似于Nginx，是一个均衡负载的服务器。其相比于Nginx的好处是其代理TCP流量的功能配置起来非常的简单。我这里主要拿Haproxy来配置Shadowsocks的跳板机。</p><p>前一段时间，GFW的墙好像又加高了，很多时候在教育网外连接服务器不是很可靠。所以我考虑干脆在教育网环境下做一个跳板服务器，这样在外面可以先跳到教育网，然后再从教育网过墙。</p><p>教育网的另一个好处是有IPv6。貌似IPv6上面的拦截比较弱，而且，绝大多数的高校对于IPv6都是免流量费的。因此，我们可以从IPv4公口进，然后走IPv6出。</p><h2 id="how-to">How to</h2><p>不过，问题是通过apt安装的haproxy是<a href="https://github.com/Entware/Entware-ng/issues/426" target="_blank" rel="noopener">不支持IPv6的</a>！</p><p>我们只能自己动手从源码编译了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.haproxy.org/download/1.7/src/haproxy-1.7.2.tar.gz</span><br><span class="line">tar -xzf haproxy-1.7.2.tar.gz</span><br><span class="line">cd haproxy-1.7.2</span><br><span class="line">make TARGET=linux2626 USE_GETADDRINFO=1</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><!-- \begin{equation*}x = \sum_{i=1}^{N}x^2\end{equation*} -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;haproxy&quot;&gt;Haproxy&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.haproxy.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haproxy is a reliable, h
      
    
    </summary>
    
      <category term="教程" scheme="http://www.codewoody.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://www.codewoody.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Shadowsocks" scheme="http://www.codewoody.com/tags/Shadowsocks/"/>
    
  </entry>
  
</feed>
